<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Computer Science | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/computer-science/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-11-17T08:52:44-05:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Methods to Remember Things by: Ruby Memoization]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/11/10/methods-to-remember-things-by-ruby-memoization/"/>
    <updated>2015-11-10T09:03:09-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/11/10/methods-to-remember-things-by-ruby-memoization</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/xUrmE6PJBEbni" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>A couple of months ago, I wrote <a href="http://vaidehijoshi.github.io/blog/2015/08/25/unlocking-ruby-keywords-begin-end-ensure-rescue/">a blog post</a> on some basic Ruby keywords including <code>begin</code>, <code>end</code>, <code>rescue</code>, and <code>ensure</code>. A few days after publishing said post, another Rubyist friend of mine sent me a message telling me to read about memoization. &ldquo;You basically describe memoization in your post without ever explicitly explaining it,&rdquo; she had said. At the time, I had added it to my ever-growing list of &ldquo;things to learn more about&rdquo;, but promptly forgot to make the time to learn about the concept.</p>

<p>Cut to last week, when I was trying to write a controller action that had to do something a bit more complex than simply render a JSON-formatted response of a given resource. So, I started off by implementing a <code>begin</code> <code>end</code> block to execute a bunch of code that needed to run on it&rsquo;s own. I remembered writing about how to use these two keywords, so I pulled up my post and was suddenly reminded of&hellip;<strong>memoization</strong>. It turned out that I actually needed to use memoization in this controller action, and had already been using it elsewhere in the very same project! But, I still didn&rsquo;t understand what it was, or in what way I had been using it so far.</p>

<p>After putting it off for months, it was finally time to learn about this memoization business. For those of us (myself included!) who haven&rsquo;t quite gotten the memo on memoization, here&rsquo;s the brief lowdown: the term dates back to the year 1968, when it was <a href="https://en.wikipedia.org/wiki/Memoization">coined by</a> Donald Michie, a British artificial intelligence researcher who worked alongside Alan Turing at the Code and Cypher School at Bletchley Park during WWII. The basic idea of a memoization function is that it can &ldquo;remember&rdquo; the result that corresponds to a set of given inputs. In other words, it can store the results of an expensive function call by &ldquo;saving&rdquo; the result such that when you call the same function again with the same parameters, you don&rsquo;t need to rerun the function. In the context of computer science specifically, this is a kind of optimization technique that is used to make programs more efficient and much faster. There are a few different ways that memoization pops up in Ruby and Rails, which is exactly what we&rsquo;ll need to learn about next!</p>

<!--more-->


<h2>Multiple Memoization</h2>

<iframe src="//giphy.com/embed/yg4IHVMEvUxby" width="480" height="240" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>There are effectively two types of memoization when it comes to Rails applications: simple, single-line memoization, and the more complex form found in multiple-line memoization. They still are the same concept and we can implement them using the same conditional operator; the fundamental difference between the two types hinges upon how much logic needs to be run for the object that we&rsquo;re trying to &ldquo;remember&rdquo;, or in other words, <em>memoize</em>.</p>

<p>Let&rsquo;s start with a simple memoization example. In our bookstore application, we have a piece of functionality that allows users to write reviews for books that they have purchased. Currently however, our <code>ReviewsController</code> doesn&rsquo;t account for that functionality. It only has a simple <code>index</code> action that is currently rendering all the <code>Reviews</code> that have been <code>published</code>:</p>

<pre><code class="ruby">class ReviewsController &lt; ApplicationController
    def index
        render json: Review.published
    end
end
</code></pre>

<p>The <code>published</code> method that we&rsquo;re chaining on here is just a simple scope that we <a href="http://vaidehijoshi.github.io/blog/2015/11/03/hunting-down-the-scoop-on-activerecord-scopes/">learned about last week</a>, and added on to our <code>Review</code> model:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    scope :published, -&gt; {
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', Time.zone.now)
    }
end
</code></pre>

<p>We can implement some simple memoization by abstracting out what&rsquo;s currently happening in the <code>index</code> action of our <code>ReviewsController</code>. Since memoization roughly translates to the concept of &ldquo;remembering&rdquo; the return value of a function without having to call it again, we could use Ruby&rsquo;s instance variable to store the return value of an expensive function call. In our case, the function that we&rsquo;re calling and saving to our instance variable is the <code>published</code> scope on our <code>Review</code> class:</p>

<pre><code class="ruby">class ReviewsController &lt; ApplicationController
    def index
        render json: reviews
    end

    private
    def reviews
        @reviews ||= Review.published
    end
end
</code></pre>

<p>Now our <code>index</code> action is calling the private <code>reviews</code> method, which is &ldquo;remembering&rdquo;, or essentially assigning and saving the return value of <code>Review.published</code> to the instance variable <code>@reviews</code>. Right now it doesn&rsquo;t look like much, but this could help keep our code clean as we continue to build out this controller.</p>

<p>The tricky thing to keep in mind with controllers is that they are nothing more than Ruby classes. This is important to remember because this instance variable will exist for the lifespan of a single request; if we make a network call (probably a <code>GET</code> request) when we query the <code>index</code> endpoint of our <code>ReviewsController</code>, the <code>@reviews</code> instance variable will be assigned and exist for the duration of that request. Once that request has completed, that instance of the controller is no longer needed and a new one would be created. Right now, we&rsquo;re not doing very much in our existing codebase with this piece of functionality. But why might that be important? Let&rsquo;s find out.</p>

<p>Imagine that the <code>index</code> action of our <code>ReviewsController</code> needs to be rewritten to account for a new piece of functionality. Instead of merely loading all of our <code>published</code> book reviews, we now want to be able to account for some query params. For example, if a user navigated to a route such as <code>/the-sound-and-fury/reviews</code>, they should be able to see all the published books reviews for that specific book, based on the book slug that is used in the URL. We immediately know that we need to change our <code>reviews</code> method. But it&rsquo;s not going to be as simple as just chaining on another method; we have a bit more complicated logic going on here.</p>

<p>First, we&rsquo;ll need to check whether there&rsquo;s a <code>book_slug</code> parameter being passed in. If there is, we&rsquo;ll need to query for the correct book reviews based on that query param. If there is no parameter being passed in, we&rsquo;ll just want to return our <code>published</code> Reviews. To account for this new feature, our method may now look something like this:</p>

<pre><code class="ruby">class ReviewsController &lt; ApplicationController
        def index
        render json: reviews
    end

    private
        def reviews
        @reviews ||= begin

        _reviews = Review.published

        if params[:book_slug].present?
            _reviews = _reviews.where(book_slug: params[:book_slug])
        end

        _reviews
      end
    end
end
</code></pre>

<p>Here, we&rsquo;re implementing the multiple-line form of memoization, which calls for the use of our favorite Ruby keywords, <code>begin</code> and <code>end</code>. We&rsquo;re first setting a local <code>_reviews</code> variable to all the <code>published</code> reviews; if there&rsquo;s a <code>book_slug</code> query parameter being passed in for this <code>GET</code> request, we&rsquo;re modifying this variable to select only the published reviews that have a <code>book_slug</code> attribute that matches the query param that was passed in. Ultimately, we&rsquo;re returning our <code>_reviews</code> variable, which will either be just an array of all the published reviews, or the published reviews that match our query parameter.</p>

<p>We don&rsquo;t necessarily have to use a variable name prepended with an <code>_</code> underscore, but I&rsquo;ve seen other developers do this in their code and I&rsquo;ve come to realize that this can be one way of denoting to other developers that this variable is being modified but not explicitly used. It can be a way of indicating that this variable is only necessary to <em>assign</em> the instance variable <code>@reviews</code>, and is never called or referenced outside of our <code>begin</code> <code>end</code> code block. We should also note that our <code>index</code> action hasn&rsquo;t changed one bit. All of our modified logic still lives in the same method, and is still accessible from our <code>@reviews</code> instance variable, from any action within this controller.</p>

<p>Sometimes, the <code>begin</code> <code>end</code> block for multiple-line memoization is simply used because all of the code won&rsquo;t fit on a single line. The <code>begin</code> <code>end</code> block ensures that the code will be executed together in a single chunk, which effectively encapuslates the block of code in the same way, as though it were written on a single line, but makes it look much prettier and far easier to read.</p>

<h2>Crazy For Conditionals</h2>

<iframe src="//giphy.com/embed/fNlRJ7Gwr4Lba" width="480" height="202" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>In order to really understand what&rsquo;s going on with memoization, it&rsquo;s important to identify the behind the scenes action of Ruby&rsquo;s &ldquo;or equals&rdquo; (sometimes referred to as the &ldquo;double pipe&rdquo;) operator: <code>||=</code>.</p>

<p>When I first learned about this operator, I initially thought that it functioned by telling the Ruby interpreter something equivalent to, <em>Hey, if a value for this variable already exists, please return that. Otherwise, if this variable doesn&rsquo;t have a value yet, assign it to whatever block of code comes next</em>. But apparently, that&rsquo;s not exactly what&rsquo;s going on here. In actuality, this operator is far more nuanced that most people may initially think it to be. Peter Cooper&rsquo;s <a href="http://www.rubyinside.com/what-rubys-double-pipe-or-equals-really-does-5488.html">Ruby Inside blog post</a> does a fantastic job of unpacking all the different edge cases of the or equals operator, including the various scenarios when it can be a bit problematic. I really like the way that he summarizes the misconception behind the &ldquo;or equals&rdquo; operator quite simply as follows:</p>

<blockquote><p>A common misconception is that <code>a ||= b</code> is equivalent to <code>a = a || b</code>, but it behaves like <code>a || a = b</code>. In <code>a = a || b</code>, <code>a</code> is set to something by the statement on every run, whereas with <code>a || a = b</code>, <code>a</code> is only set if <code>a</code> is logically false (i.e. if it&rsquo;s <code>nil</code> or <code>false</code>) because <code>||</code> is &lsquo;short circuiting&rsquo;. That is, if the left hand side of the <code>||</code> comparison is true, there&rsquo;s no need to check the right hand side.</p></blockquote>

<p>In other words, what he&rsquo;s saying here is that when we write something like this:</p>

<pre><code class="ruby">@review ||= Review.find(params[:id])
</code></pre>

<p>what we&rsquo;re <em>actually</em> doing is saying something along these lines to the Ruby interpreter: <em>If</em> <code>@reviews</code> <em>currently evaluates to</em> <code>false</code><em>, then set it to the the return value of</em> <code>Review.find(params[:id])</code><em>. But, if</em> <code>@reviews</code> <em>is not a falsey value, don&rsquo;t assign or set the variable to anything. Just stop running and exit out of the method.</em></p>

<p>It&rsquo;s also worth bringing up the fact that both <code>nil</code> and <code>false</code> are &ldquo;falsey&rdquo; values, which means that if <code>@review</code> was <code>nil</code> and empty when this line runs, the method would <em>not</em> short circuit, and would continue to execute after the <code>||=</code> operator, thereby assigning the <code>@review</code> instance variable during method execution. This is significant if you are integrating with an external API where you can&rsquo;t be sure if your instance variable will be falsey or not:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    def goodreads_reviews
        @goodreads_reviews ||= begin
            # Some logic here that uses a third-party
            # API like Goodreads and returns an array 
            # of reviews, if any happen to exist.
        end
    end
end
</code></pre>

<p>In this case, if our API endpoint that we&rsquo;re querying happens to return <code>nil</code> for a set of reviews or for a particular book that may have no reviews, every single place that we&rsquo;re calling this method will be running the logic inside of the <code>begin</code> <code>end</code> block. This pretty much makes our idea of &ldquo;memoizing&rdquo; the result of this expensive query a moot point, because we&rsquo;re not &ldquo;remembering&rdquo; the return value, but instead just running that line of code again and again. We could fix this by writing a less beautiful but more flexible method like this:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    def goodreads_reviews
        unless defined? @goodreads_reviews

        @goodreads_reviews ||= begin
            # This will only execute now if
            # @goodreads_reviews is undefined
            # as nil, and not otherwise.
        end

        @goodreads_reviews
    end
end
</code></pre>

<p>This isn&rsquo;t as big of an issue if we&rsquo;re using an <code>ActiveRecord</code> method or a scope, which would return an empty array <code>[]</code>, and not <code>nil</code>. But it&rsquo;s important to keep the memoization of falsey values in mind, since we could very easily be making a lot more queries to our database than we might realize.</p>

<p>Finally, there&rsquo;s another tricky situation when it comes to memoizing a method that accepts an argument. Justin Weiss&#8217; <a href="http://www.justinweiss.com/articles/4-simple-memoization-patterns-in-ruby-and-one-gem/">blog post</a> explains how to get around this by using the Ruby <code>Hash</code> initializer method (<code>Hash.new</code>), which ensures that the only time a block will be executed is if we try to access a key that doesn&rsquo;t yet have a value assigned to it in the context of our hash. This can be a little hard to understand at first, but is pretty useful for more complex forms of method memoization.</p>

<h2>Of memos long gone</h2>

<p>Memoization has clearly been around for a long time in the computer science world, but interestingly, it&rsquo;s had a bit of a rocky history in Railsland. It turns out that there actually used to be an entire <code>ActiveSupport::Memoizable</code> <a href="http://apidock.com/rails/v3.2.13/ActiveSupport/Memoizable/memoize">module</a> back in an older version of Rails 3! Apparently, there was a lot of controversy surrounding that particular module, and it was deprecated and, eventually, completely removed in 2011.</p>

<p>At the time of deprecation, the Rails core team encouraged everyone to use the <code>||=</code> &ldquo;or equals&rdquo; operator format of method memoization, and what&rsquo;s really cool about this is that you can actually see examples of how the core team members changed the code in <a href="https://github.com/rails/rails/commit/f2c0fb32c0dce7f8da0ce446e2d2f0cba5fd44b3">the exact commit</a> where the Memoizable module was removed. Here&rsquo;s one example in the Rails source code of method memoization in the <code>DateTimeSelector</code> class:</p>

<pre><code class="ruby">class DateTimeSelector
    @month_names ||= begin
        month_names = @options[:use_month_names] || translated_month_names
        month_names.unshift(nil) if month_names.size &lt; 13
        month_names
    end
end
</code></pre>

<p>Pretty cool, right!?</p>

<p>Of course, some Rubyists were not a big fan of this commit and module deprecation. In fact, some developers have fought to keep the module alive in the form of gems! The two that are the most popular are <a href="https://github.com/dkubb/memoizable">the <code>memoizable</code> gem</a> as well as <a href="https://github.com/matthewrudy/memoist">the <code>memoist</code> gem</a>. Both of them ultimately allow us to write a memoizable method like this:</p>

<pre><code class="ruby">require 'memoist'
class Order
    extend Memoist

        def card_last_4
        # Logic to decrypt and
        # return last 4 digits
        # of credit card on the
        # order, properly formatted.
    end
    memoize :card_last_4
end
</code></pre>

<p>Effectively, this continues what the <code>ActiveSupport::Memoizable</code> module used to allow. In the method above, calling <code>card_last_4</code> on an instance of an <code>Order</code> class would only be calculated once, and would be memoized from that point on.</p>

<p>I haven&rsquo;t used either of these gems because I personally would prefer to follow Rails conventions. But, I plan on playing around with them a bit in order to try and understand why it was deprecated, and why it implemented in the first place. Of course, we could also read the entire <a href="https://github.com/rails/rails/commit/36253916b0b788d6ded56669d37c96ed05c92c5c">Github discussion</a> that took place at the time of deprecation, but that&rsquo;s a whole lot of comments to read.</p>

<p>No matter what form of method memoization we choose to use, there are certain times when it makes a lot of sense and is clearly the right tool for the job. Anytime we find ourselves making repeated database queries, or time-consuming expensive calculations, or repeated calculations that are never <em>really</em> going to chance for an instance of a class or a controller, memoization using Ruby&rsquo;s <code>||=</code> operator is probably our best bet. And now that we know the theory and history behind Ruby method memoization, we&rsquo;ll never forget!</p>

<p>I hope.</p>

<iframe src="//giphy.com/embed/TidlFj5lXMEkU" width="480" height="201" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>Memoization is a long-standing computer science concept that is basically the idea of &ldquo;remembering&rdquo; the value of a function to avoid running expensive method calls and calculations multiple times in our code.</li>
<li>The crux of Ruby&rsquo;s memoization techniques relies upon using the conditional &ldquo;or equals&rdquo; operator <code>||=</code>, which assigns a value and executes the following line of code <em>only</em> if the variable being assigned is not falsey (i.e. not <code>nil</code> or <code>false</code>).</li>
<li>There are some great blog posts on the basics of Ruby memoization. This two-part series (<a href="http://gavinmiller.io/2013/basics-of-ruby-memoization/">part one</a> and <a href="http://gavinmiller.io/2013/advanced-memoization-in-ruby/">part two</a>) is a pretty good place to start.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Querying at Warp Drive: Using ActiveRecord Includes]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/04/07/querying-at-warp-drive-using-activerecord-includes/"/>
    <updated>2015-04-07T08:36:54-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/04/07/querying-at-warp-drive-using-activerecord-includes</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/Wkym7gz6fu1Nu" width="480" height="271" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>There comes a time in the life of every developer when you stop thinking about whether your code works. Instead, you concern yourself with something else entirely: how <em>efficiently</em> your code works.</p>

<p>In fact, you can trace this back to Kent Beck&rsquo;s <a href="http://c2.com/cgi/wiki?MakeItWorkMakeItRightMakeItFast">philosophy</a> of &ldquo;Make it work, make it right, make it fast.&rdquo; Once you&rsquo;ve got your code doing what you want it to do, you need to make it better. But what do you do with your improved code once you&rsquo;ve set it right? Make sure that it&rsquo;s working as fast as it possibly can, of course!</p>

<p>Code efficiency is a bit of an advanced topic, and I&rsquo;m definitely no expert in it. But I recently learned a pretty awesome querying method that&rsquo;s neither difficult to understand nor too complex to implement. In fact, this method has always been right under your nose, hidden inside of the magic that is ActiveRecord. So what is this magical method, exactly? Well, it&rsquo;s called <strong>includes</strong>, and once you start using it, you&rsquo;ll never make database queries the same way again.</p>

<!--more-->


<h2>Inquiries on Querying</h2>

<p>The best way to know how to make your code run at warp drive is by first figuring out how fast it is to start with. But before we get into the issue of speed, let&rsquo;s check out what our code base looks like:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Order</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'>  <span class="n">belongs_to</span> <span class="ss">:user</span>
</span><span class='line'>  <span class="kp">attr_accessor</span> <span class="ss">:details</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;class User &amp;lt; ActiveRecord::Base</span>
</span><span class='line'><span class="sr">  has_many :orders&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>  <span class="k">class</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="nb">self</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">all_order_details</span>
</span><span class='line'>      <span class="no">User</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">each</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
</span><span class='line'>        <span class="n">user</span><span class="o">.</span><span class="n">orders</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">order</span><span class="o">|</span>
</span><span class='line'>          <span class="n">order</span><span class="o">.</span><span class="n">details</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Nothing <em>too</em> fancy happening here. We&rsquo;ve got a one-to-many relationship here, with a <code>User</code> object having many <code>Orders</code>, and each <code>Order</code> belonging to a <code>User</code>. There&rsquo;s also a class method called <code>all_order_details</code> in our <code>User</code> class. This method queries for all of the <code>User</code> objects in our database, and loops through each <code>User</code> instance, grabbing each order, and calling <code>details</code> on it. And if we take a look at our <code>Order</code> class, we&rsquo;ll see that <code>details</code> is just an attribute on <code>Order</code>. (Forget what that weird <code>class &lt;&lt; self</code> syntax means? Jog your memory with <a href="http://vaidehijoshi.github.io/blog/2015/02/24/class-inheritance-part-2-singletons-and-eigens-oh-my/">this post</a> from a few weeks ago.)</p>

<p>Our plan is to use this method in an admin panel or dashboard, which is probably the only place where someone would want to see all the order details of every single order placed by every single user in our system. But even though we&rsquo;re not going to be using this method within all of our views, it&rsquo;s still important that we take a look at what it&rsquo;s doing in order to understand whether we can refactor it and make it faster.</p>

<p>So, this code does pretty much exactly what we want it to do. But how fast does it do its job? The only way to find out is by checking out what happens in our server logs when we call our method:
<code>
2.2.0 :001 &gt; User.all_order_details
  User Load (1.1ms)  SELECT "users".* FROM "users"
  Order Load (0.6ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 1]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 2]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 3]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 4]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 5]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 6]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 7]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 8]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 9]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 10]]
 =&gt; # returns an array of order details
</code></p>

<p>Whoa, whoa, whoa &ndash; hold up. We&rsquo;ve got a problem.</p>

<iframe src="//giphy.com/embed/iJxHzcuNcCJXi" width="480" height="360" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Sure, we got an array of <code>Order</code> details, which is great. But doesn&rsquo;t it seem kind of weird that we had to make so many queries? Are the red flags going off in your head, too? Time to investigate.</p>

<h2>The N + 1 Problem</h2>

<p>Okay, so maybe you didn&rsquo;t recoil in horror when you saw all those queries. But let me explain why you probably should. In our database, we currently have 10 <code>Users</code>, each of whom has one <code>Order</code>. If we look at the queries we&rsquo;re currently making, you&rsquo;ll notice that we&rsquo;re first loading all of our <code>User</code> objects:
<code>ruby
User Load (1.1ms)  SELECT "users".* FROM "users"
</code></p>

<p>Loading all of our <code>Users</code> takes 1.1 milliseconds. But what about our <code>Order</code> details? We need to go through our <code>Users</code> table in order to grab each <code>Order</code>&rsquo;s details. That&rsquo;s exactly what&rsquo;s happening in each one of the queries that looks like this:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Order</span> <span class="no">Load</span> <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">6</span><span class="n">ms</span><span class="p">)</span>  <span class="no">SELECT</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">orders</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">.</span><span class="n">&lt;em</span><span class="o">&gt;</span> <span class="no">FROM</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">orders</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span> <span class="no">WHERE</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">orders</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">.</span><span class="n">&amp;ldquo</span><span class="p">;</span><span class="n">user_id</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span> <span class="o">=</span> <span class="p">?</span>  <span class="o">[[&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">user_id</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="mi">1</span><span class="o">]]</span>
</span><span class='line'><span class="no">Order</span> <span class="no">Load</span> <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">1</span><span class="n">ms</span><span class="p">)</span>  <span class="no">SELECT</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">orders</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">.</span><span class="n">&lt;</span><span class="sr">/em&gt; FROM &amp;ldquo;orders&amp;rdquo; WHERE &amp;ldquo;orders&amp;rdquo;.&amp;ldquo;user_id&amp;rdquo; = ?  [[&amp;ldquo;user_id&amp;rdquo;, 2]]&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">more</span> <span class="n">queries</span> <span class="k">for</span> <span class="n">each</span> <span class="n">user</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span><span class="n">s</span> <span class="n">orders</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;</span>
</span><span class='line'><span class="sr">We&#39;re first loading all the `Orders` when we look for a `User` with an `id` of `1`, which takes us 0.6 milliseconds. And as we continue querying through the remaining 9 `Users` in our database, each query takes us 0.1 milliseconds.</span>
</span><span class='line'>
</span><span class='line'><span class="sr">Right now, this might not seem like that big of a deal. But we have to keep in mind that we only have ten users so far! Hopefully, we&#39;ll have a *lot* more as our user base grows. And that&#39;s where our problem comes in. Actually, our problem is quite common, and it&#39;s even got a name: **the n + 1 problem**.</span>
</span><span class='line'>
</span><span class='line'><span class="sr">The crux of the n + 1 problem is essentially this: the number of queries you make will directly correspond to the number of objects (n) that you have in your database. This means that we&#39;ll have 1 query to get all of our `User` objects, and n number of *additional* queries for each `User` object we want to get order details from.</span>
</span><span class='line'>
</span><span class='line'><span class="sr">With only 10 users, we&#39;ll make 11 queries in total: 1 query for our users, and 10 for each user we query to load the user&#39;s order details. But what if we have 10,000 users? Or if we&#39;re being optimistic, 100,000 user? ...Or even a million? Making over a hundred thousand queries is just way too slow and simply not acceptable.</span>
</span><span class='line'>
</span><span class='line'><span class="sr">Thankfully, this problem is so common that Rails has a fantastic solution, tailor-made to handle it.</span>
</span><span class='line'>
</span><span class='line'><span class="sr">## Smarter Querying</span>
</span><span class='line'>
</span><span class='line'><span class="sr">Rails is a pretty smart cookie -- it allows you to load a bunch of stuff at once ahead of time if you know exactly what you want to query. This is referred to as **eager loading**, and a really easy way to eager load your associations is by using the ActiveRecord method `includes`.</span>
</span><span class='line'>
</span><span class='line'><span class="sr">You can call `includes` on an object an pass it a parameter of the table you want to load as a symbol name. We can implement this directly on our `all_order_details` method:</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;def all_order_details</span>
</span><span class='line'><span class="sr">  User.all.includes(:orders).each |user|</span>
</span><span class='line'><span class="sr">    user.orders.each do |order|</span>
</span><span class='line'><span class="sr">      order.details</span>
</span><span class='line'><span class="sr">    end</span>
</span><span class='line'><span class="sr">  end</span>
</span><span class='line'><span class="sr">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>This may look pretty similar to our original code at first, but when we look at our server logs, we can see a world of difference:
<code>ruby
2.2.0 :002 &gt; User.all_order_details
  User Load (0.2ms)  SELECT "users".* FROM "users"
  Order Load (0.3ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
 =&gt; # returns an array of order details
</code></p>

<p>Nice. We have something really cool happening here. Instead of making &ldquo;n + 1&rdquo; number of queries, we&rsquo;re only making two queries. We spend 0.2 milliseconds getting our users, and 0.3 milliseconds loading our orders. We&rsquo;re only spending 0.5 milliseconds compared to the 2.6 milliseconds we were spending before.</p>

<p>How does this work, exactly? Eager loading allows you to specify exactly which tables you want to load into memory. Just by loading them, we&rsquo;re reducing the number of queries we&rsquo;re making. It&rsquo;s like telling ActiveRecord, <em>Hey, I already know I want all the Users and I know I want to do something with their associated Orders. So instead of querying the table one instance at a time, why don&rsquo;t you just be super efficient and grab &lsquo;em all for me in one shot?</em> And that&rsquo;s pretty much exactly what Rails will do.</p>

<p>I also like the way that <a href="http://www.theodinproject.com/ruby-on-rails/active-record-queries">the Odin Project</a> explains how <code>includes</code> works:</p>

<blockquote><p>&ldquo;Includes basically takes the name of one or more associations that you&rsquo;d like to load at the same time as your original object and brings them into memory. You can chain it onto other methods like where or order clauses.&rdquo;</p></blockquote>

<p>Other helpful methods that do similar things to solve the n + 1 problem are <code>joins</code>, used for joining multiple tables together, and <code>pluck</code>, which grabs a specific column and returns it in an array format.</p>

<h2>Big O Puts the O In &ldquo;Uh Oh&rdquo;</h2>

<iframe src="//giphy.com/embed/fcpJebgkQ14UE" width="480" height="192" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Dealing with issues of efficiency and speed is a pretty advanced topic, mostly because it gets into the deep depths of computer science and the dreaded concept of <strong>Big O Notation</strong>. Big O deals with the space time complexity of different algorithms.</p>

<p>The n + 1 problem is actually nothing more than a Big O problem, because it has to do with how well your algorithm runs. The Big O complexity of an n + 1 problem is <strong>O(n)</strong>, pronounced &ldquo;Oh of n&rdquo;. An O(n) algorithm is one whose performance will grow linearly, and will be directly proportional to the size of input data (the more <code>Users</code> we have, the larger our query of each user&rsquo;s order details).</p>

<p>Big O should always be <a href="http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/">taken into consideration</a> while building an app. But that being said, it should never be the first thing that you think about &ndash; particularly if you are a reatively junior developer. The space time complexity of your algorithm is something you can think about while refactoring your code, or rethinking how you&rsquo;re approaching or solving a problem.</p>

<p>Being able to evaluate an algorithm&rsquo;s efficiency is definitely something to work towards, but it&rsquo;s also something that takes practice. Implementing ActiveRecord&rsquo;s <code>includes</code> method is a good way to start playing around with speed and efficiency &ndash; plus, you&rsquo;ll make some kickass queries in the process, and that always feels pretty awesome. (I mean, obviously it&rsquo;s not as awesome as going warp speed on the Enterprise, but hey, it&rsquo;s an acceptable alternative.)</p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>includes</code> method can be chained on to any ActiveRecord model, and takes parameters of an association/table name, passed in as a symbol. Read more about it in the <a href="http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations">Rails docs</a>.</li>
<li>If you&rsquo;re still curious about the n + 1 problem, check out another good example of it <a href="http://www.sitepoint.com/silver-bullet-n1-problem/">over here</a>.</li>
<li>Big O Notation got you down? Check out <a href="http://nathanmlong.com/2015/03/understanding-big-o-notation/">this awesome resource</a>, which has graphs to go along with each code snippet example of different types of notation.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Machine State of Mind, Part 2: Implementing State Machines]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/03/24/a-machine-state-of-mind-part-2-implementing-state-machines/"/>
    <updated>2015-03-24T08:03:14-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/03/24/a-machine-state-of-mind-part-2-implementing-state-machines</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/CYMzelWRqbQv6" width="480" height="345" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p><em>This blog post is part of a series on State Machines. Read Part 1 <a href="http://vaidehijoshi.github.io/blog/2015/03/17/a-machine-state-of-mind-part-1-understanding-state-machines/">here</a>.</em></p>

<p>Until you encounter a state machine in a gem, framework, or within someone else&rsquo;s code, you probably won&rsquo;t find one very easily. But as we learned last week, they&rsquo;re rather pervasive. I discovered state machines while helping build a large-scale eCommerce website.</p>

<p>But there actually weren&rsquo;t even that many state machines in our code! We were relying on state machines that lived in the source code of a Rails library with a variety of gems, commonly referred to as <a href="https://github.com/spree">spree</a>. (Why reinvent ecommerce platforms when so many people have already made &lsquo;em, amirite?)</p>

<p>So, I did what any self-respecting, completely unaware new developer would do: I dove into the spree source code. And boy, was <em>that</em> a rabbit hole. But, I learned some things about how state machines work in Rails and how to make them. It&rsquo;s good to conceptually understand the theory behind state machines, but the best way to learn something is by doing it. It&rsquo;s time to take off the training wheels and actually <em>build</em> our own state machine!</p>

<!--more-->


<h2>Starting Up The Machine Engine</h2>

<p>There are a few different options for implementing state machines in a Rails application; spree, for example, uses the <a href="https://github.com/pluginaweek/state_machine/tree/master">state_machine plugin</a>. Personally, I prefer the <a href="https://github.com/aasm/aasm">acts_as_state_machine gem</a> (aasm), as I&rsquo;ve found it to be a bit easier to use and understand.</p>

<p>Once we <code>gem install aasm</code> and add it to our application&rsquo;s <code>Gemfile</code>, we&rsquo;ll want to include it in the body of the class we&rsquo;re trying to implement the state machine on. In the case of our bookstore application, our <code>Order</code> objects are what will be transitioning from one state to another. As the application begins to grow, it&rsquo;ll be useful to namespace our objects (<code>Book::Order</code>) before including the module:</p>

<pre><code class="ruby">class Book::Order
  include AASM
end
</code></pre>

<p>Including the gem is the easy part. The next part is slightly trickier, yet remains pretty intuitive. First, we&rsquo;ll start by defining two states: an initial <code>state</code> that we want our object to start off in, and a second <code>state</code> we want our object to transition to. Then, we&rsquo;ll want to adding an <code>event</code> with an <code>from</code> and <code>to</code> in its <code>transition</code>:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">aasm</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">state</span> <span class="ss">:unplaced</span><span class="p">,</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="kp">true</span>
</span><span class='line'>  <span class="n">state</span> <span class="ss">:submitted</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  event :submit do</span>
</span><span class='line'><span class="sr">    transitions :from =&gt; :unplaced, :to =&gt; :submitted</span>
</span><span class='line'><span class="sr">  end</span>
</span><span class='line'><span class="sr">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Notice that the <code>event :submit</code> is the present tense verb form of the <code>state :submitted</code>. And when the <code>submit</code> event is called, the <code>Book::Order</code> object&rsquo;s <code>state</code> will transition from one state to the other.</p>

<p>That&rsquo;s pretty much all you really need to implement a state machine. But of course, we&rsquo;ve only got two states here, which isn&rsquo;t really much of a machine and definitely doesn&rsquo;t take advantage of all the functionalities that <code>aasm</code> provides us with.</p>

<p>Let&rsquo;s continue to build on the state machine based on <a href="http://i.imgur.com/Nd3ityK.png">the diagram</a> from last week&rsquo;s post and add a few more states and events:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="n">aasm</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">state</span> <span class="ss">:unplaced</span><span class="p">,</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="kp">true</span>
</span><span class='line'>    <span class="n">state</span> <span class="ss">:submitted</span>
</span><span class='line'>    <span class="n">state</span> <span class="ss">:processing</span>
</span><span class='line'>    <span class="n">state</span> <span class="ss">:shipped</span>
</span><span class='line'>    <span class="n">state</span> <span class="ss">:completed</span>
</span><span class='line'>    <span class="n">state</span> <span class="ss">:returned</span>
</span><span class='line'>    <span class="n">state</span> <span class="ss">:deleted</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;event :submit do</span>
</span><span class='line'><span class="sr">  transitions :from =&amp;gt; :unplaced, :to =&amp;gt; :submitted</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'>
</span><span class='line'><span class="sr">event :process do</span>
</span><span class='line'><span class="sr">  transitions :from =&amp;gt; [:submitted, :returned], :to =&amp;gt; :processing</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'>
</span><span class='line'><span class="sr">event :ship do</span>
</span><span class='line'><span class="sr">  transitions :from =&amp;gt; :processing, :to =&amp;gt; :shipped</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'>
</span><span class='line'><span class="sr">event :complete do</span>
</span><span class='line'><span class="sr">  transitions :from =&amp;gt; :shipped, :to =&amp;gt; :completed</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'>
</span><span class='line'><span class="sr">event :return do</span>
</span><span class='line'><span class="sr">  transitions :from =&amp;gt; :complete, :to =&amp;gt; :returned</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'>
</span><span class='line'><span class="sr">event :delete do</span>
</span><span class='line'><span class="sr">  transitions :from =&amp;gt; :processing, :to =&amp;gt; :deleted</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  end&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Whoa &ndash; now we&rsquo;re talking! This state machine is even more complex than the diagram we started off with!</p>

<p>You&rsquo;ll notice that we even have a <code>state :returned</code> and an <code>event :return</code>, which transition from a <code>complete</code> state to a <code>returned</code> one. And if you&rsquo;ve got a really good eye, you&rsquo;ll see that the <code>process</code> event has changed, too. Now, we can call the <code>process</code> event on the object when it&rsquo;s either in the <code>submitted</code> state or the <code>returned</code> state.</p>

<p>Our state machine is now a <em>self-referential</em> structure, which means that the <code>process</code> event looks back to states within the machine to determine whether it can continue forward or not. This all seems pretty cool, but you better buckle in &ndash; it&rsquo;s about to get <em>even cooler</em>.</p>

<h2>Test Driving Your Machine</h2>

<p>It&rsquo;s lovely that we have this machine and all, but what&rsquo;s the fun if you can&rsquo;t take it out for a whirl? So, let&rsquo;s see what this thing can do.</p>

<p>This gem in particular provides us with a variety of public methods for any instances of our <code>Book::Order</code> class, all via our state machine:</p>

<pre><code>order = Book::Order.new # =&gt; =&gt; #&lt;Book::Order:0x007fad3d51aa30&gt;
order.unplaced?         # =&gt; true
order.may_submit?       # =&gt; true
order.submit            # calls the `submit` event

order.submitted?        # =&gt; true
order.unplaced?         # =&gt; false
order.may_submit?       # =&gt; false
order.submit            # =&gt; raises AASM::InvalidTransition
</code></pre>

<p><em>Protip</em>: If you&rsquo;re not a big fan of raising exceptions in your application, just add <code>aasm :whiny_transitions =&gt; false do</code> right inside of your class, and you&rsquo;ll return basic <code>boolean</code> values instead of exceptions.</p>

<p>Whew! So that&rsquo;s a lot of methods. But we didn&rsquo;t have to write <em>any</em> of them! Isn&rsquo;t that fantastic? Hopefully the usefulness of state machines is starting to come together now. Remember before we knew what a state machine was? How would we have had to handle all of this functionality?</p>

<p>We would&rsquo;ve had to do all of the following, multiple times:</p>

<ol>
<li>Make a migration that adds a <code>state</code> or <code>status</code> column in our <code>Book::Object</code> class, with a <code>string</code> value.</li>
<li>Give the <code>state</code> column an initial default value of <code>unplaced</code>.</li>
<li>Add an instance method called <code>unplaced?</code> with a <code>boolean</code> return value.</li>
<li>Add another instance method called <code>submit</code>, which changes the object&rsquo;s <code>state</code> property from <code>"unplaced"</code> to <code>"submitted"</code>.</li>
<li>Add yet <em>another</em> instance method called <code>submitted?</code>, with (at the very least), a single-line <code>if</code> conditional.</li>
<li>Add some more instance methods for good measure, all with some logic in them to keep track of our object&rsquo;s <code>state</code>.</li>
<li>Repeat steps 3-6 for every single new <code>state</code> we wanted to add.</li>
</ol>


<iframe src="//giphy.com/embed/ToMjGpx9F5ktZw8qPUQ" width="480" height="391" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>If we compare this horrifying list to our state machine, it&rsquo;s pretty clear that our machine takes care of all of this! Yes, it requires a little bit of setup when we create our class, but come on, it&rsquo;s like, four lines of code for each state! So much better. And you get all these methods for free! And they&rsquo;re pretty powerful, because we can call them anywhere in our code, on any instance of our object.</p>

<p>But can we customize this machine even further? Heck yes, we can!</p>

<h2>Trick Out Yo&#8217; Ride</h2>

<p>Now that we&rsquo;ve created a basic state machine, we can trick it out with any (or all!) of these options:</p>

<h3>1. Pass a block to an <code>event</code></h3>

<p>Whenever you want a specific event to call a particular method, simply pass a block to the method. The block will only be called if the transition occurs successfully.
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">order_shipped_email</span>
</span><span class='line'>  <span class="c1"># Sends an email informing the User</span>
</span><span class='line'>  <span class="c1"># that their Order has been shipped</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;order.ship do</span>
</span><span class='line'><span class="sr">  order.user.send_order_shipped_email</span>
</span><span class='line'><span class="sr">end&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="no">Only</span> <span class="k">if</span> <span class="n">order</span><span class="o">.</span><span class="n">may_ship?</span> <span class="n">returns</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kp">true</span><span class="o">&lt;</span><span class="sr">/code&gt;,&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">will</span> <span class="n">the</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">send_order_shipped_email</span><span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="nb">method</span> <span class="n">actually</span> <span class="n">fire</span><span class="o">.</span><span class="n">&lt;</span><span class="sr">/h1&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;</span>
</span><span class='line'><span class="sr">### 2. Use a callback</span>
</span><span class='line'><span class="sr">The `aasm` documentation defines a list of different callbacks you can use for your transitions; the callbacks will only be triggered when certain conditions are met (for example, when you exit a particular `state`).</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;state :shipped, :before_enter =&gt; :print_return_label</span>
</span><span class='line'><span class="sr">state :deleted&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="n">event</span> <span class="ss">:ship</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">transitions</span> <span class="ss">:from</span> <span class="o">=&gt;</span> <span class="ss">:processing</span><span class="p">,</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:shipped</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;event :delete do, :after =&gt; :send_delete_confirmation do</span>
</span><span class='line'><span class="sr">  transitions :from =&gt; :processing, :to =&gt; :deleted</span>
</span><span class='line'><span class="sr">  end</span>
</span><span class='line'><span class="sr">end&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">print_return_label</span>
</span><span class='line'>  <span class="c1"># Prints order details along with</span>
</span><span class='line'>  <span class="c1"># the return label information.</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;def send_delete_confirmation</span>
</span><span class='line'><span class="sr">  # Sends a confirmation email</span>
</span><span class='line'><span class="sr">  # that the &lt;code&gt;Order&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="n">has</span> <span class="n">been</span> <span class="n">deleted</span><span class="o">.</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>These callbacks work exactly as you might think, hooking into either a state or an event. Before the <code>Order</code> switches states from <code>processed</code> to <code>shipped</code>, the <code>print_return_label</code> method will fire. But the <code>send_delete_confirmation</code> method will only be called after the <code>delete event</code> is finished &ndash; only after the transition from <code>processing</code> to <code>deleted</code> occurs successfully.</p>

<h3>3. Implement a guard</h3>

<p>If you want to only allow a transition if a particular condition is defined; if the guard returns <code>false</code>, the transition will be denied, and will either return <code>false</code> or raise an error.</p>

<pre><code class="ruby">event :submit do
  transitions :from =&gt; :unplaced, :to =&gt; :submitted, :guard =&gt; :payment_successfully_processed?
end

def payment_successfully_processed?
  # Returns a truthy value based on
  # whether the user's credit card info
  # has been processed successfully or not
end
</code></pre>

<p>These are just three things you can do to spice up your state machine. Creating a state machine with this gem gives you a fair amount of flexibility. You can use multiple guards or build multiple transitions for a single event. As your state machine grows, you can call the <code>aasm.current_event</code> to keep track of where you are in your code.</p>

<p>Now that you know how to implement a state machine, hopefully you now realize the value in them and don&rsquo;t feel too intimidated. As long as you take it a step at a time, you can create your own state machine, with the exact kind of functionality your program needs. With that said, there&rsquo;s only one thing left to do: go forth implement one yourself! Fly young grasshopper, fly!</p>

<iframe src="//giphy.com/embed/dH89UD4eJuOeQ" width="480" height="269" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>State machines can be broken down into <code>states</code> and <code>events</code>. Events control the flow of one <code>state</code> to another.</li>
<li>Each <code>event</code> has a <code>from</code> and a <code>to transition</code>. Only if a transition occurs successfully will an object&rsquo;s <code>state</code> change. You can manipulate how an event or transition works using callbacks, blocks, and guards.</li>
<li>Find more great blog posts that implement FSM&rsquo;s <a href="http://www.sitepoint.com/state-machines-in-ruby/">here</a> and <a href="http://bits.citrusbyte.com/state-design-pattern-with-ruby/?utm_source=rubyweekly&utm_medium=email">here</a>. And if you want to get really fancy, learn how to use <a href="https://github.com/wvanbergen/state_machine-audit_trail">this</a>!</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Machine State of Mind, Part 1: Understanding State Machines]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/03/17/a-machine-state-of-mind-part-1-understanding-state-machines/"/>
    <updated>2015-03-17T08:11:22-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/03/17/a-machine-state-of-mind-part-1-understanding-state-machines</id>
    <content type="html"><![CDATA[<p><img src="http://www.kurzweilai.net/images/flowchart.png" style="display: block; margin-left: auto; margin-right: auto;"></p>

<p>My favorite thing about programming is the fact that you never run out of opportunities to be completely floored. There&rsquo;s literally <em>always</em> either a concept, theory, framework, or language that you don&rsquo;t know. This is actually fantastic, because there&rsquo;s no dearth of opportunity when it comes to learning. And you always come head-to-head with these facts when you pair program with a more experienced developer.</p>

<p>One of the new concepts that I encountered this week was the idea of <strong>state machines</strong>, sometimes referred to as &ldquo;finite state machines&rdquo;. At first I thought that this was something unique to the gem that we are using in one of our large-scale applications, but it turns out it&rsquo;s not a Rails thing. In fact, it&rsquo;s not even a Ruby thing! It&rsquo;s a <em>Computer Science</em> thing; to be a bit more specific, it&rsquo;s a mathematical abstraction used to design complex algorithms. But for all intents and purposes, it&rsquo;s a Computer Science theory that we use almost all the time, whether we know it or not.</p>

<p>If you got through that paragraph without freaking out, you deserve a medal. All this CS theory sounds terrifying, right? Well, don&rsquo;t worry. For programming purposes, you don&rsquo;t actually need to think too much about how state machines are constructed and what&rsquo;s being abstracted away. Even though state machines can get incredibly complex, relatively quickly, let&rsquo;s not overwhelm ourselves; we only need to think about state machines in the context of programming. So we&rsquo;ll keep it simple and focus on what state machines are, how they work, and when to use them.</p>

<!--more-->


<h2>State Machines: What Are They?</h2>

<p>A state machine is nothing more than a flow chart. And here&rsquo;s the thing about flowcharts: <em>they&rsquo;re everywhere</em>. If you think about it, a flowchart is just a way of controlling the flow of a set of actions. You have different conditions, and depending on your condition &ndash; or &ldquo;state&rdquo;, as we refer to it in programmatic terms &ndash; you&rsquo;ll take a certain action.</p>

<p>For example, if you&rsquo;re hungry, you&rsquo;ll eat some food, probably a slice of cheesecake. If you&rsquo;re still hungry, you&rsquo;ll eat another slice. When you&rsquo;re full, you&rsquo;ll stop eating cheesecake (LOL, like anyone could ever be &ldquo;too full&rdquo; from cheesecake). You have different states of being, and certain events trigger you to move from one state to another &ndash; from hungry, to less hungry, to completely full.</p>

<p>One of the simplest definitions that I found for state machines in the context of programming comes from a <a href="http://lamsonproject.org/docs/introduction_to_finite_state_machines.html">Lamson Project blog post</a> :</p>

<blockquote><p>A practical finite state machine is basically four things: 1) A bunch of functions, or things that need to get done. 2) A bunch of events, or reasons to call these functions. 3) Some piece of data that tracks the &ldquo;state&rdquo; this bunch of functions is in. 4) Code inside the functions that says how to &ldquo;transition&rdquo; or &ldquo;change&rdquo; into the next state for further processing.</p></blockquote>

<p>At the risk of sounding a bit philosophical, it all boils down to actions that are taken, and the reasons we take certain actions. State machines are how we keep track of different events, and control the flow between those events.</p>

<h2>A State Of Being: How to Use State Machines</h2>

<p>The best way of understanding <em>how</em> to use a state machine in your own application is by seeing an example of it in another application. A good place to start is usually a commonly-used, large-scale web application. Since we&rsquo;ve been using my bookstore application in <a href="http://vaidehijoshi.github.io/blog/2015/03/10/its-all-in-the-family-using-acts-as-tree/">prior blog posts</a>, we&rsquo;ll use another eCommerce example to understand state machines. Here&rsquo;s a very simplified example of a basic order processing state machine:</p>

<p><img src="http://i.imgur.com/Nd3ityK.png" style="display: block; margin-left: auto; margin-right: auto;"></p>

<p>If we follow the event flow, we start to get an idea of the different actions that trigger different states. Each <code>Order</code> starts off with an initial state (something that we&rsquo;ll explore a bit more when we build our own state machine), and requires a certain event to occur for its state to change. This means that only if an <code>Order</code> is <em>placed</em>, will the <code>Order</code>&rsquo;s state be changed to <code>submitted</code>.</p>

<p>The event triggers are important because without them, there wouldn&rsquo;t be enough clarity to move from one state to another. Take a look at the <code>Order</code> when it&rsquo;s in the <code>processing</code> state. The <code>Order</code> must be either <code>fulfilled</code> or <code>canceled</code> in order for it to proceed to the next state.</p>

<p>This particular state machine is <em>very</em> simple, and doesn&rsquo;t even account for the return or refund process! Imagine what that might look like! You could have states that could have events that <em>refer back</em> to themselves, which would make them <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graphs</a>. Things would start to get really complicated, really fast.</p>

<p>But, if we think back to the Lamson Project&rsquo;s definition of a state machine, our order processing example still fits the bill:</p>

<ol>
<li>Our <strong>functions</strong>, the stuff that needs to get done, are the different things that need to happen for an event to trigger. For example, the <code>User</code> has to input a valid credit card number, cvv, expiration date, and shipping address just so that the <code>Order</code> can transition from <code>unplaced</code> to <code>submitted</code>.</li>
<li>Our <strong>events</strong>, the reasons to call the functions, are the actual actions taken during the flow of the machine. The <code>User</code> actually has to successfully <em>submit</em> the form and the data has to be passed from the <code>User</code> and stored in the database so that the event can successfully occur.</li>
<li>Our <strong>states</strong>, the data that tracks these functions, are the different conditions that our order can be in. If the <code>Order</code> is <code>processing</code>, all the functionality of fulfilling, packaging, and shipping the order must all be contained within that state.</li>
<li>Our <strong>code inside the functions</strong> would be all the intricate methods that do all the work prior to each event occurring and each state changing. For example, you&rsquo;d probably have a validation to check whether the user had input a valid zip code (something like <code>validates :zip_code_length</code>) before transitioning from an <code>unplaced</code> <code>Order</code> to a <code>submitted</code> one. And you&rsquo;d probably want to execute an <code>in_stock?</code> method before switching from the <code>processing</code> state to the <code>shipped</code> state.</li>
</ol>


<h2>The Case For State Machines</h2>

<p>While understanding state machines is great, is it always the right tool for the job? From my research and reading, it seems like most of the time, it is. <a href="http://www.skorks.com/2011/09/why-developers-never-use-state-machines/">This post</a> by Alan Skorkin gives some pretty good insight into <em>why</em> developers never use state machines. Many developers seem to be intimidated by the very concept of state machines, or sometimes don&rsquo;t even understand them in the first place, which can be cause to avoid them at all costs. Other programmers see them as complex and overly complicated, and perhaps not necessary when you&rsquo;re first starting off in building your application. And sometimes it&rsquo;s just hard to foresee how your application is going to grow, and determine whether or not a state machine is the right tool for the job.</p>

<p>Even though setting up a state machine takes a bit of initial effort, it can save you a lot of pain in the long run. Even though many programmers can&rsquo;t predict when they&rsquo;ll need a state machine, almost every application has some form of flow that fits the bill. And let&rsquo;s face it: almost every web application these days actually strives to <em>do</em> something, which means that it will inevitably have some sort of flow of events.</p>

<p>This fantastic <a href="http://www.shopify.com/technology/3383012-why-developers-should-be-force-fed-state-machines">Shopify blog post</a> makes a great case for why ever programmer needs to be &ldquo;force-fed&rdquo; the state machine concept. The most important part of all of this debate, however, is understanding the state machine pattern. You have to understand the pattern first, and then you can figure out whether you need to spend the time in actually implementing it.</p>

<p>Thankfully, there are a few common red flags that indicate if this is the case:</p>

<ol>
<li><p>A <code>state</code> or a <code>status</code> attribute on any of your objects: <code>Book::Order.first.status</code></p></li>
<li><p>Instance methods that return a <code>boolean</code> value: <code>Book::Order.first.shipped?</code></p></li>
<li><p>Records that are only valid for a certain period of time: <code>User::Membership.first.subscriptions #=&gt; "expired"</code></p></li>
</ol>


<p>If your code base has any of these, you can probably benefit from a state machine. I went back and looked at my old web apps, and found that each and every one of them had at least one, if not more, of these situations. In fact, almost every Rails application is bound to have some variation of these three different scenarios, which means that we should all learn how to use state machines and become better developers!</p>

<p>So how do you actually go about creating a state machine? Well, that&rsquo;s a whole other <del>game</del> blog post entirely. Tune in again next Tuesday, when I&rsquo;ll explore how to actually go about <em>implementing</em> a state machine in your Rails application! Get excited! Like this:</p>

<iframe src="//giphy.com/embed/FlWgXEtj5aM5G" width="480" height="259" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>State machines control the flow of events in a web application by using certain events to trigger different states or conditions.</li>
<li>If you find that your app has methods like <code>state</code> or <code>status</code> and <code>shipped?</code> or <code>received?</code>, you should try using a state machine.</li>
<li>Still interested in the CS theory behind state machines? Check out these two super helpful blog posts on the subject <a href="http://blog.markshead.com/869/state-machines-computer-science/">here</a> and <a href="http://www.i-programmer.info/babbages-bag/223-finite-state-machines.html">here</a>.</li>
</ul>

]]></content>
  </entry>
  
</feed>
