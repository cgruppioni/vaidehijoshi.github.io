<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-11-10T08:49:14-05:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Methods to Remember Things by: Ruby Memoization]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/11/10/methods-to-remember-things-by-ruby-memoization/"/>
    <updated>2015-11-10T09:03:09-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/11/10/methods-to-remember-things-by-ruby-memoization</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/xUrmE6PJBEbni" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>A couple of months ago, I wrote <a href="http://vaidehijoshi.github.io/blog/2015/08/25/unlocking-ruby-keywords-begin-end-ensure-rescue/">a blog post</a> on some basic Ruby keywords including <code>begin</code>, <code>end</code>, <code>rescue</code>, and <code>ensure</code>. A few days after publishing said post, another Rubyist friend of mine sent me a message telling me to read about memoization. &ldquo;You basically describe memoization in your post without ever explicitly explaining it,&rdquo; she had said. At the time, I had added it to my ever-growing list of &ldquo;things to learn more about&rdquo;, but promptly forgot to make the time to learn about the concept.</p>

<p>Cut to last week, when I was trying to write a controller action that had to do something a bit more complex than simply render a JSON-formatted response of a given resource. So, I started off by implementing a <code>begin</code> <code>end</code> block to execute a bunch of code that needed to run on it&rsquo;s own. I remembered writing about how to use these two keywords, so I pulled up my post and was suddenly reminded of&hellip;<strong>memoization</strong>. It turned out that I actually needed to use memoization in this controller action, and had already been using it elsewhere in the very same project! But, I still didn&rsquo;t understand what it was, or in what way I had been using it so far.</p>

<p>After putting it off for months, it was finally time to learn about this memoization business. For those of us (myself included!) who haven&rsquo;t quite gotten the memo on memoization, here&rsquo;s the brief lowdown: the term dates back to the year 1968, when it was <a href="https://en.wikipedia.org/wiki/Memoization">coined by</a> Donald Michie, a British artificial intelligence researcher who worked alongside Alan Turing at the Code and Cypher School at Bletchley Park during WWII. The basic idea of a memoization function is that it can &ldquo;remember&rdquo; the result that corresponds to a set of given inputs. In other words, it can store the results of an expensive function call by &ldquo;saving&rdquo; the result such that when you call the same function again with the same parameters, you don&rsquo;t need to rerun the function. In the context of computer science specifically, this is a kind of optimization technique that is used to make programs more efficient and much faster. There are a few different ways that memoization pops up in Ruby and Rails, which is exactly what we&rsquo;ll need to learn about next!</p>

<!--more-->


<h2>Multiple Memoization</h2>

<iframe src="//giphy.com/embed/yg4IHVMEvUxby" width="480" height="240" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>There are effectively two types of memoization when it comes to Rails applications: simple, single-line memoization, and the more complex form found in multiple-line memoization. They still are the same concept and we can implement them using the same conditional operator; the fundamental difference between the two types hinges upon how much logic needs to be run for the object that we&rsquo;re trying to &ldquo;remember&rdquo;, or in other words, <em>memoize</em>.</p>

<p>Let&rsquo;s start with a simple memoization example. In our bookstore application, we have a piece of functionality that allows users to write reviews for books that they have purchased. Currently however, our <code>ReviewsController</code> doesn&rsquo;t account for that functionality. It only has a simple <code>index</code> action that is currently rendering all the <code>Reviews</code> that have been <code>published</code>:</p>

<pre><code class="ruby">class ReviewsController &lt; ApplicationController
    def index
        render json: Review.published
    end
end
</code></pre>

<p>The <code>published</code> method that we&rsquo;re chaining on here is just a simple scope that we <a href="http://vaidehijoshi.github.io/blog/2015/11/03/hunting-down-the-scoop-on-activerecord-scopes/">learned about last week</a>, and added on to our <code>Review</code> model:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    scope :published, -&gt; {
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', Time.zone.now)
    }
end
</code></pre>

<p>We can implement some simple memoization by abstracting out what&rsquo;s currently happening in the <code>index</code> action of our <code>ReviewsController</code>. Since memoization roughly translates to the concept of &ldquo;remembering&rdquo; the return value of a function without having to call it again, we could use Ruby&rsquo;s instance variable to store the return value of an expensive function call. In our case, the function that we&rsquo;re calling and saving to our instance variable is the <code>published</code> scope on our <code>Review</code> class:</p>

<pre><code class="ruby">class ReviewsController &lt; ApplicationController
    def index
        render json: reviews
    end

    private
    def reviews
        @reviews ||= Review.published
    end
end
</code></pre>

<p>Now our <code>index</code> action is calling the private <code>reviews</code> method, which is &ldquo;remembering&rdquo;, or essentially assigning and saving the return value of <code>Review.published</code> to the instance variable <code>@reviews</code>. Right now it doesn&rsquo;t look like much, but this could help keep our code clean as we continue to build out this controller.</p>

<p>The tricky thing to keep in mind with controllers is that they are nothing more than Ruby classes. This is important to remember because this instance variable will exist for the lifespan of a single request; if we make a network call (probably a <code>GET</code> request) when we query the <code>index</code> endpoint of our <code>ReviewsController</code>, the <code>@reviews</code> instance variable will be assigned and exist for the duration of that request. Once that request has completed, that instance of the controller is no longer needed and a new one would be created. Right now, we&rsquo;re not doing very much in our existing codebase with this piece of functionality. But why might that be important? Let&rsquo;s find out.</p>

<p>Imagine that the <code>index</code> action of our <code>ReviewsController</code> needs to be rewritten to account for a new piece of functionality. Instead of merely loading all of our <code>published</code> book reviews, we now want to be able to account for some query params. For example, if a user navigated to a route such as <code>/the-sound-and-fury/reviews</code>, they should be able to see all the published books reviews for that specific book, based on the book slug that is used in the URL. We immediately know that we need to change our <code>reviews</code> method. But it&rsquo;s not going to be as simple as just chaining on another method; we have a bit more complicated logic going on here.</p>

<p>First, we&rsquo;ll need to check whether there&rsquo;s a <code>book_slug</code> parameter being passed in. If there is, we&rsquo;ll need to query for the correct book reviews based on that query param. If there is no parameter being passed in, we&rsquo;ll just want to return our <code>published</code> Reviews. To account for this new feature, our method may now look something like this:</p>

<pre><code class="ruby">class ReviewsController &lt; ApplicationController
        def index
        render json: reviews
    end

    private
        def reviews
        @reviews ||= begin

        _reviews = Review.published

        if params[:book_slug].present?
            _reviews = _reviews.where(book_slug: params[:book_slug])
        end

        _reviews
      end
    end
end
</code></pre>

<p>Here, we&rsquo;re implementing the multiple-line form of memoization, which calls for the use of our favorite Ruby keywords, <code>begin</code> and <code>end</code>. We&rsquo;re first setting a local <code>_reviews</code> variable to all the <code>published</code> reviews; if there&rsquo;s a <code>book_slug</code> query parameter being passed in for this <code>GET</code> request, we&rsquo;re modifying this variable to select only the published reviews that have a <code>book_slug</code> attribute that matches the query param that was passed in. Ultimately, we&rsquo;re returning our <code>_reviews</code> variable, which will either be just an array of all the published reviews, or the published reviews that match our query parameter.</p>

<p>We don&rsquo;t necessarily have to use a variable name prepended with an <code>_</code> underscore, but I&rsquo;ve seen other developers do this in their code and I&rsquo;ve come to realize that this can be one way of denoting to other developers that this variable is being modified but not explicitly used. It can be a way of indicating that this variable is only necessary to <em>assign</em> the instance variable <code>@reviews</code>, and is never called or referenced outside of our <code>begin</code> <code>end</code> code block. We should also note that our <code>index</code> action hasn&rsquo;t changed one bit. All of our modified logic still lives in the same method, and is still accessible from our <code>@reviews</code> instance variable, from any action within this controller.</p>

<p>Sometimes, the <code>begin</code> <code>end</code> block for multiple-line memoization is simply used because all of the code won&rsquo;t fit on a single line. The <code>begin</code> <code>end</code> block ensures that the code will be executed together in a single chunk, which effectively encapuslates the block of code in the same way, as though it were written on a single line, but makes it look much prettier and far easier to read.</p>

<h2>Crazy For Conditionals</h2>

<iframe src="//giphy.com/embed/fNlRJ7Gwr4Lba" width="480" height="202" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>In order to really understand what&rsquo;s going on with memoization, it&rsquo;s important to identify the behind the scenes action of Ruby&rsquo;s &ldquo;or equals&rdquo; (sometimes referred to as the &ldquo;double pipe&rdquo;) operator: <code>||=</code>.</p>

<p>When I first learned about this operator, I initially thought that it functioned by telling the Ruby interpreter something equivalent to, <em>Hey, if a value for this variable already exists, please return that. Otherwise, if this variable doesn&rsquo;t have a value yet, assign it to whatever block of code comes next</em>. But apparently, that&rsquo;s not exactly what&rsquo;s going on here. In actuality, this operator is far more nuanced that most people may initially think it to be. Peter Cooper&rsquo;s <a href="http://www.rubyinside.com/what-rubys-double-pipe-or-equals-really-does-5488.html">Ruby Inside blog post</a> does a fantastic job of unpacking all the different edge cases of the or equals operator, including the various scenarios when it can be a bit problematic. I really like the way that he summarizes the misconception behind the &ldquo;or equals&rdquo; operator quite simply as follows:</p>

<blockquote><p>A common misconception is that <code>a ||= b</code> is equivalent to <code>a = a || b</code>, but it behaves like <code>a || a = b</code>. In <code>a = a || b</code>, <code>a</code> is set to something by the statement on every run, whereas with <code>a || a = b</code>, <code>a</code> is only set if <code>a</code> is logically false (i.e. if it&rsquo;s <code>nil</code> or <code>false</code>) because <code>||</code> is &lsquo;short circuiting&rsquo;. That is, if the left hand side of the <code>||</code> comparison is true, there&rsquo;s no need to check the right hand side.</p></blockquote>

<p>In other words, what he&rsquo;s saying here is that when we write something like this:</p>

<pre><code class="ruby">@review ||= Review.find(params[:id])
</code></pre>

<p>what we&rsquo;re <em>actually</em> doing is saying something along these lines to the Ruby interpreter: <em>If</em> <code>@reviews</code> <em>currently evaluates to</em> <code>false</code><em>, then set it to the the return value of</em> <code>Review.find(params[:id])</code><em>. But, if</em> <code>@reviews</code> <em>is not a falsey value, don&rsquo;t assign or set the variable to anything. Just stop running and exit out of the method.</em></p>

<p>It&rsquo;s also worth bringing up the fact that both <code>nil</code> and <code>false</code> are &ldquo;falsey&rdquo; values, which means that if <code>@review</code> was <code>nil</code> and empty when this line runs, the method would <em>not</em> short circuit, and would continue to execute after the <code>||=</code> operator, thereby assigning the <code>@review</code> instance variable during method execution. This is significant if you are integrating with an external API where you can&rsquo;t be sure if your instance variable will be falsey or not:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    def goodreads_reviews
        @goodreads_reviews ||= begin
            # Some logic here that uses a third-party
            # API like Goodreads and returns an array 
            # of reviews, if any happen to exist.
        end
    end
end
</code></pre>

<p>In this case, if our API endpoint that we&rsquo;re querying happens to return <code>nil</code> for a set of reviews or for a particular book that may have no reviews, every single place that we&rsquo;re calling this method will be running the logic inside of the <code>begin</code> <code>end</code> block. This pretty much makes our idea of &ldquo;memoizing&rdquo; the result of this expensive query a moot point, because we&rsquo;re not &ldquo;remembering&rdquo; the return value, but instead just running that line of code again and again. We could fix this by writing a less beautiful but more flexible method like this:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    def goodreads_reviews
        unless defined? @goodreads_reviews

        @goodreads_reviews ||= begin
            # This will only execute now if
            # @goodreads_reviews is undefined
            # as nil, and not otherwise.
        end

        @goodreads_reviews
    end
end
</code></pre>

<p>This isn&rsquo;t as big of an issue if we&rsquo;re using an <code>ActiveRecord</code> method or a scope, which would return an empty array <code>[]</code>, and not <code>nil</code>. But it&rsquo;s important to keep the memoization of falsey values in mind, since we could very easily be making a lot more queries to our database than we might realize.</p>

<p>Finally, there&rsquo;s another tricky situation when it comes to memoizing a method that accepts an argument. Justin Weiss&#8217; <a href="http://www.justinweiss.com/articles/4-simple-memoization-patterns-in-ruby-and-one-gem/">blog post</a> explains how to get around this by using the Ruby <code>Hash</code> initializer method (<code>Hash.new</code>), which ensures that the only time a block will be executed is if we try to access a key that doesn&rsquo;t yet have a value assigned to it in the context of our hash. This can be a little hard to understand at first, but is pretty useful for more complex forms of method memoization.</p>

<h2>Of memos long gone</h2>

<p>Memoization has clearly been around for a long time in the computer science world, but interestingly, it&rsquo;s had a bit of a rocky history in Railsland. It turns out that there actually used to be an entire <code>ActiveSupport::Memoizable</code> <a href="http://apidock.com/rails/v3.2.13/ActiveSupport/Memoizable/memoize">module</a> back in an older version of Rails 3! Apparently, there was a lot of controversy surrounding that particular module, and it was deprecated and, eventually, completely removed in 2011.</p>

<p>At the time of deprecation, the Rails core team encouraged everyone to use the <code>||=</code> &ldquo;or equals&rdquo; operator format of method memoization, and what&rsquo;s really cool about this is that you can actually see examples of how the core team members changed the code in <a href="https://github.com/rails/rails/commit/f2c0fb32c0dce7f8da0ce446e2d2f0cba5fd44b3">the exact commit</a> where the Memoizable module was removed. Here&rsquo;s one example in the Rails source code of method memoization in the <code>DateTimeSelector</code> class:</p>

<pre><code class="ruby">class DateTimeSelector
    @month_names ||= begin
        month_names = @options[:use_month_names] || translated_month_names
        month_names.unshift(nil) if month_names.size &lt; 13
        month_names
    end
end
</code></pre>

<p>Pretty cool, right!?</p>

<p>Of course, some Rubyists were not a big fan of this commit and module deprecation. In fact, some developers have fought to keep the module alive in the form of gems! The two that are the most popular are <a href="https://github.com/dkubb/memoizable">the <code>memoizable</code> gem</a> as well as <a href="https://github.com/matthewrudy/memoist">the <code>memoist</code> gem</a>. Both of them ultimately allow us to write a memoizable method like this:</p>

<pre><code class="ruby">require 'memoist'
class Order
    extend Memoist

        def card_last_4
        # Logic to decrypt and
        # return last 4 digits
        # of credit card on the
        # order, properly formatted.
    end
    memoize :card_last_4
end
</code></pre>

<p>Effectively, this continues what the <code>ActiveSupport::Memoizable</code> module used to allow. In the method above, calling <code>card_last_4</code> on an instance of an <code>Order</code> class would only be calculated once, and would be memoized from that point on.</p>

<p>I haven&rsquo;t used either of these gems because I personally would prefer to follow Rails conventions. But, I plan on playing around with them a bit in order to try and understand why it was deprecated, and why it implemented in the first place. Of course, we could also read the entire <a href="https://github.com/rails/rails/commit/36253916b0b788d6ded56669d37c96ed05c92c5c">Github discussion</a> that took place at the time of deprecation, but that&rsquo;s a whole lot of comments to read.</p>

<p>No matter what form of method memoization we choose to use, there are certain times when it makes a lot of sense and is clearly the right tool for the job. Anytime we find ourselves making repeated database queries, or time-consuming expensive calculations, or repeated calculations that are never <em>really</em> going to chance for an instance of a class or a controller, memoization using Ruby&rsquo;s <code>||=</code> operator is probably our best bet. And now that we know the theory and history behind Ruby method memoization, we&rsquo;ll never forget!</p>

<p>I hope.</p>

<iframe src="//giphy.com/embed/TidlFj5lXMEkU" width="480" height="201" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>Memoization is a long-standing computer science concept that is basically the idea of &ldquo;remembering&rdquo; the value of a function to avoid running expensive method calls and calculations multiple times in our code.</li>
<li>The crux of Ruby&rsquo;s memoization techniques relies upon using the conditional &ldquo;or equals&rdquo; operator <code>||=</code>, which assigns a value and executes the following line of code <em>only</em> if the variable being assigned is not falsey (i.e. not <code>nil</code> or <code>false</code>).</li>
<li>There are some great blog posts on the basics of Ruby memoization. This two-part series (<a href="http://gavinmiller.io/2013/basics-of-ruby-memoization/">part one</a> and <a href="http://gavinmiller.io/2013/advanced-memoization-in-ruby/">part two</a>) is a pretty good place to start.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hunting Down the Scoop on ActiveRecord Scopes]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/11/03/hunting-down-the-scoop-on-activerecord-scopes/"/>
    <updated>2015-11-03T08:43:46-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/11/03/hunting-down-the-scoop-on-activerecord-scopes</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/PzrPi0UVzgYHm" width="480" height="254" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Over the past forty or so Tuesdays &mdash; has it really been that many?! &mdash; I&rsquo;ve written on a spread of topics. There&rsquo;s a slight problem with this: sometimes I forget what I have and haven&rsquo;t written about. Here&rsquo;s a case in point for you: last week, I wrote about <a href="http://vaidehijoshi.github.io/blog/2015/10/27/digging-into-the-finder-object-pattern/">finder objects</a>, and casually tossed in some scopes into my models. It turns out, I&rsquo;ve never actually written about how scopes work, or what they really do!</p>

<p>I know, I know, that&rsquo;s pretty terrible of me. I actually learned about scopes awhile ago, and now I use them fairly often in my applications. However, I got so used to writing them, that I never really thought that much about how they work behind the scenes. In fact, when I sat down to write <em>this</em> post, I had to go on a hunt into the Rails source code and Ruby blogosphere to figure out what was going on under the hood every single time I implemented a scope in my code.</p>

<p>The main reason that I like to use <strong>ActiveRecord scopes</strong> is because they allow us to specify commonly-used queries, but encapsulate these queries into methods, which we can then call on our models or association objects. However, my hunt lead me to find out that scopes have been around for awhile in Railsland, so they&rsquo;re not exactly that new. But, what&rsquo;s interesting about them is how their implementation has changed and grown with different releases of Rails. There&rsquo;s also a lot of debate over how and when scopes are different from their counterparts, or simpler class methods. But what makes a scope exactly? Well, it&rsquo;s finally time for us to hunt down the answer to that question.</p>

<!--more-->


<h2>The simplest of scopes</h2>

<iframe src="//giphy.com/embed/uH37VANhgHDaM" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>While developing applications, we often run into a situation where we want to select a particular group of objects (read: rows from our database) based on the characteristics that they share. The basic implementation of scopes can be summed up as this simple idea: being able to narrow down the objects that we want into a specific subset, based on some given parameters. We can tell <code>ActiveRecord</code> (an Object Relational Mapper, or ORM) to select a certain group of objects by implementing a scope that is specific to a model. Luckily, scopes aren&rsquo;t too difficult to define, and mostly adhere to a simple structure.</p>

<p>In our bookstore app for example, we have a <code>Review</code> object, that we allow our users to write about the <code>Book</code>s that they purchase through our store. For now, our <code>Review</code>s belong to a <code>User</code>, and they have some basic attributes which map to columns in our database, including a <code>published_at</code> datetime attribute, that we set when our User clicks the submit button, which saves their &ldquo;drafted&rdquo; review and turns it into a &ldquo;published&rdquo; review.</p>

<p>However, one side effect of having this attribute (and effectively, two different states or &ldquo;types&rdquo; of reviews) is that we now have no obvious form of selecting only our &ldquo;published&rdquo; reviews &mdash; that is to say, reviews that have a <code>published_at</code> date attribute set on them. How can we fix this? Well, we can write a class method that, when invoked, will run a query on our <code>ActiveRecord</code> object and only return the reviews that have this attribute. If we did that, our model might look something like this:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    belongs_to :user

    def self.published
        where('published_at IS NOT NULL')
    end
end
</code></pre>

<p>Okay, that&rsquo;s a good start. Remember that the implicit <code>self</code> in the body of this class method is our <code>Review</code> class, so we&rsquo;re basically running <code>Review.where('published_at IS NOT NULL')</code>. But now we run into another problem: this query isn&rsquo;t all that specific, is it? What makes a <code>published</code> review, exactly? Well, it&rsquo;s not just the fact that the <code>published_at</code> date should be set; we also need to account for the fact that some reviews could be set to be published in the <em>future</em>, at a later date. What we <em>really</em> want to select are our reviews that have a <code>published_at</code> date that has already happened; in other words, a date which occurred in the past. We can modify our class method to account for this:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    belongs_to :user

    def self.published
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', Time.zone.now)
    end
end
</code></pre>

<p>If we try out this class method, we can see the exact SQL that gets executed:</p>

<pre><code class="ruby">♥ rails c
Loading development environment (Rails 4.1.4)
irb(main):001:0&gt; Review.published
# SELECT "reviews".* FROM "reviews" WHERE "reviews".
"published_at" IS NOT NULL AND "reviews"."published_
at" &lt;= 2015-10-27 08:07:36 -0400
</code></pre>

<p>However, instead of writing this functionality into the body of a class method, we could accomplish the exact same thing by using a scope:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    belongs_to :user

    scope :published, -&gt; {
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', Time.zone.now)
    }
end
</code></pre>

<p>which allows us to invoke a method in the console that pretty much looks like the method we had before:</p>

<pre><code class="ruby">irb(main):002:0&gt; Review.published
  Review Load (2.6ms)  SELECT "reviews".* FROM 
  "reviews" WHERE "reviews".
"published_at" IS NOT NULL AND "reviews"."published_
at" &lt;= 2015-10-27 08:07:36 -0400
=&gt; #&lt;ActiveRecord::Relation []&gt;
</code></pre>

<p>Okay, wait &mdash; what&rsquo;s going on here?! How did that even happen? Well, let&rsquo;s break it down:</p>

<ol>
<li>First, we&rsquo;re using something called the <code>scope</code> method. This class method is defined within the <code>ActiveRecord::Scoping::Named</code> module.</li>
<li>Second, the <code>scope</code> class method requires two important arguments: a <strong>name</strong> for the scope, and a <strong>callable object</strong> that includes a query criteria. That last part about passing a callable object is pretty important, because only procs and lambdas are callable objects. In fact, that <code>-&gt; {}</code> syntax that we&rsquo;re using is just another way of writing a lambda in Ruby.</li>
<li>Third, and most interestingly, the return value of our scope was an <code>ActiveRecord::Relation</code> object. This is significant because <code>ActiveRecord::Relation</code> objects are <em>not</em> eagerly-loaded &mdash; they&rsquo;re <em>lazily-loaded</em>. Lazy-loading basically means that we&rsquo;re never going to query to the database until we actually <em>need</em> to. What makes this really awesome is that lazy-loading allows us to call more methods (read: scopes galore!) on our returned <code>ActiveRecord::Relation</code> object.</li>
</ol>


<p>It looks like perhaps there&rsquo;s some funky stuff going on here. But, all of these things still don&rsquo;t really answer our burning question: why use a scope when we could just write a class method?!</p>

<h2>Class methods by any other name</h2>

<iframe src="//giphy.com/embed/fwok0XCSAIivm" width="480" height="729" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>What&rsquo;s in a scope? A class method by any other name would smell just as sweet! Oops, I got carried away there. Enough poetry, let&rsquo;s talk prose. Or scopes, rather, and why we might want to use them.</p>

<p>We want to change the implementation of our <code>published</code> class method such that it accepts an argument that makes our query more flexible. Let&rsquo;s say that we want to be able to filter our <code>Review</code>s by a specific publication date. We might now have a class method that looks like this:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    belongs_to :user

    def self.published(on)
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', on)
    end
end
</code></pre>

<p>The <code>on</code> parameter would ideally be a <code>Date</code> or a <code>Datetime</code> object that would dynamically change the rows that we&rsquo;ll query for in our database. This will behave exactly like we want it to, until&hellip;it breaks. How can we break this? Well, let&rsquo;s say that we now want to order our published reviews by their <code>position</code> attribute, which for the time being, is just an integer. No problem, we can do that, right?</p>

<pre><code class="ruby">irb(main):003:0&gt; Review.published(Time.zone.now)
    .order(position: asc)
    Review Load (0.2ms)  SELECT "review".* FROM 
    "review"  WHERE (published_at IS NOT NULL AND 
    published_at &lt;= 2015-11-02 08:07:36 -0400) 
    ORDER BY "review"."position" ASC
=&gt; #&lt;ActiveRecord::Relation [#&lt;Review id: 1, published_at: 
"2015-08-02 00:04:22", position: 5&gt;, #&lt;Review id: 2, 
published_at: nil, position: 10, published_at: 
"2015-10-02 00:02:00"&gt;]&gt;
</code></pre>

<p>Sure, no problem! This returns exactly what we&rsquo;d expect. But what if we&rsquo;re relying on this method elsewhere and somehow don&rsquo;t pass in a parameter to our <code>published</code> method. What happens then?</p>

<pre><code class="ruby">irb(main):004:0&gt; Review.published(nil).order(position: asc)
=&gt; NoMethodError: undefined method `order' for nil:NilClass
</code></pre>

<p>BOOM! Everything broke. Oops. What happened here? We tried to call the <code>order</code> method on a falsy object (aka <code>nil</code>). Obviously Ruby is unhappy, because it looks like <code>Review.published(nil)</code> returns <code>nil</code>, which doesn&rsquo;t respond to a method called <code>order</code>!</p>

<p>Now, let&rsquo;s go fast forward to our new scope implementation in the Review class:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    belongs_to :user

    scope :published, -&gt; (on) {
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', on)
    }
end
</code></pre>

<p>We&rsquo;ve changed our callable object to accept a parameter, which is how we&rsquo;re going to determine our <code>published_at</code> date. We can be pretty certain that this will execute the same query if we pass an actual <em>date</em> to this scope. But what if we pass <code>nil</code> again?</p>

<pre><code class="ruby">irb(main):005:0&gt; Review.published(nil)
    .order(position: asc)
   Review Load (0.2ms)  SELECT "review".* 
   FROM "review"  WHERE (published_at IS NOT 
   NULL AND published_at &lt;= 2015-11-02 08:07:36 -0400) 
   ORDER BY "review"."position" ASC
=&gt; #&lt;ActiveRecord::Relation [#&lt;Review id: 1, published_at: 
nil, position: 1, created_at: "2015-11-02 00:45:22", 
updated_at: "2015-11-02 00:45:22"&gt;, #&lt;Review id: 2, 
published_at: nil, position: 2, created_at: 
"2015-11-02 00:46:22", updated_at: "2015-11-02 00:46:22"&gt;]&gt;
</code></pre>

<p>Well, would you look at that! It didn&rsquo;t break! It ran our expected query, but because scopes return <code>ActiveRecord::Relation</code> objects, it didn&rsquo;t call <code>order</code> on <code>nil</code>, it just kept chaining on to our query. The first part of our query (responsible for finding any reviews that were published on a date) didn&rsquo;t return anything, but the second part of our query (responsible for just ordering whatever got returned by our first query) did work! How, exactly? Well, <a href="http://aspiringwebdev.com/use-activerecord-scopes-not-class-methods-in-rails-to-avoid-errors/">it just so happens</a> that calling a method on a blank <code>ActiveRecord::Relation</code> object returns that same relation. An important thing to note: if we had a query that was scoping down our reviews to ones that were published on a date and ordering <em>those</em> objects by their position, we would have gotten an empty relation:</p>

<pre><code class="sql">SELECT "review".* FROM "review"  WHERE 
(published_at IS NOT NULL AND published_at 
&lt;= 2015-11-02 08:07:36 -0400 AND 
(ORDER BY "review"."position" ASC))
</code></pre>

<p>The above query narrows down our scope quite a bit, which we could do if we wanted to specify that to SQL. But in our case, our <code>ORDER BY</code> clause isn&rsquo;t grouped inside of the <code>AND</code>, but instead exists outside of it, which is why we&rsquo;re not getting an empty relation returned to us.</p>

<p>While we&rsquo;re on the topic of relations, it&rsquo;s also important to note that the method we have right now <em>does not</em> return an object to us! Relations are not objects! We&rsquo;d need to explicitly query for a record if we wanted to return it:</p>

<pre><code class="ruby">irb(main):006:0&gt; Review.published(nil)
    .order(position: asc).first
=&gt; #&lt;Review id: 1, published_at: nil, position: 1, 
created_at: "2015-11-02 00:45:22", 
updated_at: "2015-11-02 00:45:22"&gt;
</code></pre>

<p>Hopefully we should now be able to easily see that the <code>order</code> method that we&rsquo;re chaining on right there at the end could really be abstracted into its own scope! Let&rsquo;s fix that, shall we?</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    belongs_to :user

    scope :published, -&gt; (on) {
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', on)
    }

    scope :ordered, -&gt; { order(position: :asc) } 
end
</code></pre>

<p>Much better. Now we can just chain on our <code>order</code> scope to our <code>published</code> scope without ever having to worry that our scopes will break. But wait, there&rsquo;s even more we can do with scopes!</p>

<h2>Special scope tricks</h2>

<p>Because scopes accept lambdas and procs, we can pass in different arguments. We did that before when we passed in a datetime parameter. But this kind of flexibility can be especially powerful, because we can do things like pass in limits:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    scope :published, -&gt; (limit: 20) {
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', Time.zone.now)
    }
end
</code></pre>

<p>This will run our same SQL query, but will add <code>LIMIT 10</code> to the end of it. We can customize this scope further, or we can add more if we need to. We also might want to just perpetually apply a scope to all queries on a specific model. When we run into this situation, we can use the <code>default_scope</code> method.</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    default_scope -&gt; { order(published_at: :desc) }
end
</code></pre>

<p>This will automatically append all of our SQL queries on this model with <code>ORDER BY "review"."position" DESC</code>. What&rsquo;s really nice about having a default scope is that we don&rsquo;t need to write and perpetually call a method named something like <code>by_published_date</code> on this model; it will be applied and invoked by default on all instances of this class.</p>

<p>According to <a href="http://guides.rubyonrails.org/active_record_querying.html#scopes">the documentation</a>, if we want to get <em>super</em> fancy with our default scope and have so much logic that it&rsquo;s bursting from our callable object&rsquo;s so-called seams, we can also define it in an alternate way as a class method:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
  def self.default_scope
    # Get fancy in here, but just make sure 
    # to return an ActiveRecord::Relation.
    # Otherwise, any scopes we chain onto 
    # this will automatically break!
  end
end
</code></pre>

<p>We&rsquo;re also not limited to just using the <code>where</code> method! We can use plenty of other <code>ActiveRecord::Relation</code> methods, such as <code>joins</code> or <code>includes</code>, which will eager load other relations when we want to. Here&rsquo;s a handy scope we could add to our <code>Shipment</code> model that <a href="http://vaidehijoshi.github.io/blog/2015/10/27/digging-into-the-finder-object-pattern/">we built out</a> last week:</p>

<pre><code class="ruby">class Shipment &lt; ActiveRecord::Base
    default_scope -&gt; { includes(:order, :line_items) }
end
</code></pre>

<p>This is pretty cool because we&rsquo;re using our <code>default_scope</code> method to automatically eager-load our associated <code>order</code> and <code>line_items</code> on our <code>shipment</code> without having to make two additional queries just to load them! As is the case with <code>includes</code>, it might not always be a good idea to do this, since we could be loading more records than we want, or could get stuck with a n+1 situation on our hands. But if we know what we&rsquo;re doing and are sure that this scope is necessary, it can be pretty powerful.</p>

<p>We can also merge two scopes together, which effectively allows us to mix and match different <code>WHERE</code> conditions and group them together in SQL with an <code>AND</code>:</p>

<pre><code class="ruby">class Shipment &lt; ActiveRecord::Base
    scope :shipped -&gt; { where(state: 'shipped') }
    scope :damaged -&gt; { where(condition: 'damaged') }
end
</code></pre>

<p>which we can then merge into a single SQL query by chaining our scopes together:</p>

<pre><code class="ruby">irb(main):007:0&gt; Shipment.shipped.received
=&gt; SELECT "shipments".* FROM "shipments" WHERE 
"shipments"."state" = 'shipped' AND "shipments".
"condition" = 'damaged'
</code></pre>

<p>We&rsquo;ll notice that in this situation, our <code>WHERE</code> clauses are grouped together with an <code>AND</code>, which can help us when it comes to writing super specific queries.</p>

<iframe src="//giphy.com/embed/OIIB1hkbwFs76" width="480" height="339" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>ActiveRecord scopes give us a lot of flexibility, even though they are effectively defining a class method on a model. The fundamental difference between them however, is that scopes should always return an <code>ActiveRecord::Relation</code> object, which makes them forever chainable!</li>
<li>How does the <code>scope</code> method actually work? I&rsquo;m not sure that I understand all of it, but perhaps you will! Check it out in the <a href="https://github.com/rails/rails/blob/428d47adfed8d6aa7b21aec2bf5ad890961c9de3/activerecord/lib/active_record/scoping/named.rb#L143">Rails source code</a>!</li>
<li>There are a few great primers on writing effective scopes, like <a href="http://www.informit.com/articles/article.aspx?p=2220311">this one</a>, and this <a href="http://blog.plataformatec.com.br/2013/02/active-record-scopes-vs-class-methods/">other one</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Digging Into the Finder Object Pattern]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/10/27/digging-into-the-finder-object-pattern/"/>
    <updated>2015-10-27T08:58:31-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/10/27/digging-into-the-finder-object-pattern</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/y5A0PlFbGIk4o" width="480" height="280" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Most developers aren&rsquo;t ever <em>completely</em> happy with their code. I&rsquo;m no exception to this stereotype &mdash; I almost always know that I could probably write a cleaner, more concise method, controller, or class. Usually, it&rsquo;s a matter of not know the best tool to reach for to refactor my code; eventually, I learn a new pattern or form of encapuslating logic that I later use to make my old code a lot better.</p>

<p>But a few weeks ago, I wrote 100 lines of beautiful code. I&rsquo;m talking about a goregous, straightforward, no-nonsense class that did a lot in a relatively few lines of Ruby. I still feel pretty proud of it (can you tell?), and part of the reason for this is because I also learned a new pattern while writing this class. I was actually pairing with another developer, and we wanted to try using a rather common Rails pattern to solve a problem we were running into again and again: messy queries in our controllers and models.</p>

<p>We both were familiar with the concept of &ldquo;skinny controllers&rdquo; and &ldquo;fat models&rdquo;, or the idea that your controllers shouldn&rsquo;t be responsible for containing the logic specific to a model. However, we also didn&rsquo;t want our models to get out of control in size, which is exactly what was starting to happen. So, we searched for a workaround, and found our answer in one of the most elegant patterns I&rsquo;ve seen in awhile: <strong>finder objects</strong>. Finder objects are simple Ruby classes that encapuslate the logic behind querying the database, and they are hands down, my new favorite kind of Ruby object.</p>

<!--more-->


<h2>Scopin&#8217; Down The Problem of Scopes</h2>

<iframe src="//giphy.com/embed/Y6eQqv3jdV4RO" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>In our bookstore application, we have <code>Order</code> objects, which represent the orders that a user places in our system. However, these are books that we&rsquo;re dealing with, and eventually we need to address the whole fulfillment process, which will need to be represented by a whole other set of models. For now, we&rsquo;ll try to keep it as simple as possible. Let&rsquo;s say that an <code>Order</code> has many <code>Shipments</code>, and each shipment represents a batch of <code>Book</code> objects (read: products) that need to be shipped out together.</p>

<p>Right off the bat, we know that our <code>Shipment</code> model will have some kind of state machine that will need to track the different stages of the shipment phase. Again, to keep it simple, let&rsquo;s say that there are five different stages or <code>state</code>s of a shipment:</p>

<ol>
<li>A shipment starts off as <code>processing</code> once an order has been placed.</li>
<li>Once it has been processed, it needs a label with the shipping address information, so it transitions to the <code>needs_label</code> state.</li>
<li>After it has a label generated, it&rsquo;ll need a tracking number, so transitions to the <code>needs_tracking</code> state.</li>
<li>Once it has a tracking number, it transitions to being <code>ready</code> for shipment.</li>
<li>Finally, when the shipment is actually sent out of the warehouse and to our shipping service, it should be marked as <code>shipped</code>.</li>
</ol>


<p>To be clear, this is a <em>super</em> simplified version of what would happen in a real-life application! Now, in our admin panel, let&rsquo;s say that we have a page that will render all of our shipments, which should always ordered by when they were created, so that our admins know which shipments to process, and in which order.</p>

<p>We can take it a step further and say that our main admin panel page &mdash; which will correspond to the <code>index</code> action in our controller, should show our admins the most urgent shipments that need their attention as soon as they log in; in other words, these would be the shipments that were created more than a week ago, but still haven&rsquo;t been processed.</p>

<p>I think we can all agree that basic Rails best practices should steer us away from doing something like this:</p>

<pre><code class="ruby">class ShipmentsController &lt; ApplicationController
  def index
    @shipments = Shipment.where(state: :ready)
            .where('created_at &lt;= ?', Time.zone.now + 7.days)
               .order(created_at: :desc)
  end
end
</code></pre>

<p>We <em>definitely</em> know that the controller really shouldn&rsquo;t be responsible for querying for the correct <code>Shipment</code> objects. All our controller should have to do is just render the correct ones, and not go digging for them in the database!</p>

<p>Okay, so we&rsquo;ll create some scopes for these queries instead. These scopes should live in our model, not in the controller, right? Let&rsquo;s see what our model might look like if we take that approach:</p>

<pre><code class="ruby">class Shipment &lt; ActiveRecord::Base
    belongs_to :order

    default_scope -&gt; { order(created_at: :desc) }
    scope :shipped, -&gt; { where(state: 'shipped') }
    scope :urgent, -&gt; {
        where('created_at &lt;= ?', Time.zone.now + 7.days)
    }
end
</code></pre>

<p>This cleans things up a decent bit! Scopes are actually part of the Active Record Query Interface, and they allow us to specify commonly-used queries which we can then actually reference and use in the form of method calls on our models themselves. They are really nothing more than defining class methods on a model:</p>

<pre><code class="ruby">class Shipment &lt; ActiveRecord::Base
    def self.shipped
        where(state: 'shipped')
    end
end
</code></pre>

<p>However, they&rsquo;re pretty wonderful because you can just chain them as method calls (<code>Shipment.urgent.shipped</code>), but all they do is execute the correct query for you:</p>

<pre><code class="ruby">Shipment.shipped
=&gt; SELECT "shipments".* FROM "shipments" WHERE "shipments"."state" = "shipped"
</code></pre>

<p>But the good news about scopes is also the bad <a href="news:">news:</a> you can just keep adding them and adding them, and chaining them onto everything. Our <code>Shipment</code> class has only three scopes at the moment, one of them being the <code>default</code> scope. But, we&rsquo;ll probably have a page that should only render only the shipments that are in the <code>needs_label</code> state, or a page that maps to a controller action which should only return shipments that are in the <code>needs_tracking</code> state. We <em>could</em> keep adding scopes and then have our controller actions call the scopes on the class to return the appropriate shipments from our database.</p>

<p>Or, we could try something a little different.</p>

<h2>Finder Objects</h2>

<iframe src="//giphy.com/embed/12bpEjD05ac2IM" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Our scopes don&rsquo;t actually add any new behavior to our model. As we saw earlier, they are nothing more than macros for querying for the correct rows from our <code>shipments</code> table in our database. So, it really doesn&rsquo;t make sense for our model to contain all this logic that doesn&rsquo;t <em>add</em> any new behavior to it.</p>

<p>It would be nice, however, if we could apply the rule of &ldquo;separation of concerns&rdquo; here, and have an entire class whose sole responsibility would be to dig up the correct objects based on the parameters we were querying by. Really, this class should do nothing more than <em>find the right objects</em>. You might even say that instances of this class are just&hellip;<em>finder objects</em>! (Get it? Man, I really hope you got it.)</p>

<p>Anyways, how might this class look? Well, we don&rsquo;t need any of the functionality from ActiveRecord, so we can create it as just a Plain Old Ruby Class:</p>

<pre><code class="ruby">class ShipmentFinder
end
</code></pre>

<p>Next, we&rsquo;ll want to tell our finder object which models to query for, so it will know how to construct our queries, and which table to query. Since we never really want to have this method accessible elsewhere, we can make it a private class method that will only be called from the context of another <code>ShipmentFinder</code> class method:</p>

<pre><code class="ruby">class ShipmentFinder
    class &lt;&lt; self
        private
        def resource_class
            ::Shipment
        end
    end
end
</code></pre>

<p>Now, we can use Rails&#8217; <a href="https://github.com/rails/arel">arel DSL</a> to construct a basic query. To do this, we&rsquo;ll need a method that returns the table, which can also be a private method since we&rsquo;ll never want to call it explicitly:</p>

<pre><code class="ruby">class ShipmentFinder
    class &lt;&lt; self
      private

      def table
        resource_class.arel_table
      end

      def resource_class
        ::Shipment
      end
    end
end
</code></pre>

<p>Now, we can write as many specific queries as we want. For example, we could write a <code>urgent_needs_tracking</code> class method that could constructs a query using two private methods, <code>needs_tracking</code> and <code>is_ready</code>:</p>

<pre><code class="ruby">class ShipmentFinder
    class &lt;&lt; self
      def urgent_needs_tracking
        query = needs_tracking.and(is_ready)

        resource_class.where(query)
      end

      def shipped
        resource_class.where(state: 'shipped')
      end

      private

      def urgent
        resource_class.where('created_at &lt;= ?', Time.zone.now + 7.days))
      end

      def is_ready
        table[:state].eq('ready')
      end

      def needs_tracking
        table[:state].eq('needs_tracking')
      end

      def needs_label
        table[:state].eq('needs_label')
      end

      def table
        resource_class.arel_table
      end

      def resource_class
        ::Shipment
      end
    end
end
</code></pre>

<p>Now we can rely on our <code>ShipmentFinder</code> class to find our shipments that have been created more than 7 days ago, and still don&rsquo;t have a tracking number. We also can add more functionality that can be used in specific instances, which is exactly what we&rsquo;ve done with our <code>needs_label</code> and <code>is_ready</code> private methods. We can use arel to construct queries using those methods to scope down what objects are actually returned. We don&rsquo;t have to do anything fancy, if we don&rsquo;t want to. Take a look at that <code>shipped</code> method &mdash; this is just using a simple <code>where</code> arel method to construct a query that reads like this: <code>SELECT "shipments".* FROM "shipments" WHERE "shipments"."state" = "shipped"</code>.</p>

<p>Finally, the last step: it&rsquo;s time for us to actually call on our finder object to do its job!</p>

<h2>Cleaner Querying, Cleaner Controllers</h2>

<p>Let&rsquo;s bring it all together by going back to our <code>ShipmentsController</code> and add our new finder object into it. Our <code>index</code> action should now be able to account for different types of shipments that our admins might want to query for. For now, we&rsquo;ll construct our controller to accept a query parameter in our params hash that will be that <code>status</code> of the types of shipments we want to return. Depending on the frontend framework we&rsquo;re using, this might be a dropdown or checkbox option that will set a value on the <code>status</code> key in our params hash.</p>

<p>Our controller action could now be rewritten to look something like this:</p>

<pre><code class="ruby">class ShipmentsController &lt; ApplicationController
  def index
    status = params[:status]
    status_method = status.to_sym

    if ShipmentFinder.respond_to?(status_method)
            @shipments = ShipmentFinder.send(status_method)
        else
            @shipments = Shipment.all
        end
  end
end
</code></pre>

<p>Here, we&rsquo;re accessing the query param from <code>params[:status]</code>, and turning it into a symbol (<code>status_method</code>). Next, we&rsquo;re using Ruby&rsquo;s super handy <code>respond_to?</code> method, and sending our <code>status_method</code> symbol to our <code>ShipmentFinder</code>. So, if our admin selects an option that sends the query param <code>urgent_needs_tracking</code>, we are telling our finder object to call that method, and execute that query. The return value of the query executed by our <code>ShipmentFinder</code>&rsquo;s <code>urgent_needs_tracking</code> method is what will be set as the instance variable <code>@shipments</code> for the duration of this action on the controller.</p>

<p>If no query param is set, or if our <code>ShipmentFinder</code> doesn&rsquo;t have a method that maps to a query param, we&rsquo;re just returning all of our <code>Shipment</code> objects by default.</p>

<p>This is quite an improvement from our earlier code, which had our controller digging for rows in a database that it really didn&rsquo;t have anything to do with. Now, we&rsquo;ve separated our concerns into a new finder object, which exists as its own query interface on its own. It&rsquo;s also worth noting that sometimes, creating a finder object can be overkill, and sometimes, if we have a lot of finder objects, we&rsquo;d probably want to abstract a lot of this functionality out into a <code>BaseFinder</code> class, which our finder objects could inherit from. But this is definitely a great start. No more digging for us!</p>

<iframe src="//giphy.com/embed/FqEDV3gjMhqRG" width="480" height="267" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The finder object pattern helps keep your model logic strictly related to a class&#8217; behavior, while also keeping your controller&rsquo;s skinny. Since they are nothing more than plain old Ruby classes, finder objects don&rsquo;t need to inherit from <code>ActiveRecord::Base</code>, and should be responsible for nothing more than executing queries. Read more about them on this <a href="http://twin.github.io/finder-objects/">fantastic blog post</a>.</li>
<li>Scopes are a great tool to use if a finder object seems like more work than it&rsquo;s really worth, given the size and context of your application. Read more about scopes in the Rails <a href="http://guides.rubyonrails.org/active_record_querying.html#scopes">documentation</a>.</li>
<li>Want to see more examples of implementing finder objects? Check out this <a href="https://speakerdeck.com/weppos/maintaining-a-5yo-ruby-project-shark-edition?slide=103">slidedeck</a> series.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Solutions for Slugs of All Sizes: Acts_as_url + To_param]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/10/20/solutions-for-slugs-of-all-sizes-acts-as-url-plus-to-param/"/>
    <updated>2015-10-20T08:17:21-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/10/20/solutions-for-slugs-of-all-sizes-acts-as-url-plus-to-param</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/g5FB33d3GVUkg" width="480" height="288" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Last week was my first week of working from home, which meant two things: spending a lot of time with my computer and limited time with other human beings and, more importantly, debugging things on my own without having anyone nearby to ask for help. The latter of the two actually ended up reaffirming the fact that I actually <em>can</em> debug a decent amount of things on my own if I just power through and am stubborn enough to not give up.</p>

<p>I also learned something interesting about the debugging process: while we&rsquo;re learning, we often solve the same problem again and again. At least, this was the case for one of the features I was working on which involved using an object&rsquo;s slug to generate a url. As I started thinking through how to approach solving this, I immediately had the feeling that I had done something similar in another project. Digging through another repository&rsquo;s source code confirmed my suspicions, and I rediscovered the <code>stringex</code> gem and its multiple libraries, including <code>acts_as_url</code>!</p>

<p>All of this begs the question: why didn&rsquo;t I remember that this gem existed &mdash; or that I had already used it? My guess is that it&rsquo;s because I neither wrote about it nor understood how it worked until a few days ago. This week, it&rsquo;s time to rectify that situation and dive into the <code>acts_as_url</code> library and find a solution for all slug problems, once and for all!</p>

<!--more-->


<h2>The Other Kind of Slug</h2>

<iframe src="//giphy.com/embed/C1aCu8kUyF6p2" width="480" height="350" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>We all are familiar with the Rails mantra of <em>convention over configuration</em>, aka making the lives of developers easier by eliminating the need for them to make decisions about how to structure their code. Now, this design paradigm is pretty fantastic, particularly when we&rsquo;re first learning a new framework. But eventually, there comes a time when we need to tweak our code&rsquo;s conventions just a tiny little bit.</p>

<p>What&rsquo;s an example of this? Well, take Rails convention of finding an object by it&rsquo;s <code>id</code>. This standardization pops up all over the place, but the one that we&rsquo;re particularly concerned with is the generation of a url. By default, Rails applications will build a URL path for the <code>show</code> action of any given controller based on the primary key (aka the <code>id</code> column in our database) of the object that we&rsquo;re trying to &ldquo;show&rdquo;.</p>

<p>Let&rsquo;s put this in context of our bookstore application. We have a bunch of <code>Book</code> objects, and we want to iterate through their titles and then link to their individual &ldquo;show&rdquo; pages. A very basic, not-at-all-fancy template might look something like this:</p>

<pre><code class="slim">h2 Books!
- @books.each do |book|
    p = link_to book.title, book_path(book)
</code></pre>

<p>It&rsquo;s important to note that we&rsquo;re actually passing in the <code>book</code> instance here &mdash; an <code>ActiveRecord</code> object, and <em>not</em> the <code>book</code>&rsquo;s <code>id</code>. Why is this important? Because there&rsquo;s a method that Rails is using to convert the <code>Book</code> object into a URL in order to generate the correct address for our <code>book_path</code>. That&rsquo;s why we need to pass it an <code>ActiveRecord</code> object, because the method that&rsquo;s being called expects an object and returns the <code>id</code> as parameters in the url. What does this look like, exactly? Well, right now our <code>book_path</code> takes a <code>Book</code> instance and creates a path that looks like this: <code>localhost:3000/books/25</code>.</p>

<p>Which is fine! Actually, it&rsquo;s more than fine: it&rsquo;s the expected behavior given our Rails mantra of convention over configuration. But, what if we actually <em>want</em> to configure this a little bit more. What if, instead of using the primary key of our <code>Book</code> instances, we wanted to use the title of the book? It would be lovely if we could link someone to a particular book&rsquo;s page with a more human-readable url (for example, something like <code>awesomebookstore.com/books/the-bell-jar</code> in production).</p>

<p>There&rsquo;s a solution for this problem, and it&rsquo;s called slugs. Slugs are a solution for semantic URL generation, which is also sometimes referred to as &ldquo;RESTful&rdquo; or &ldquo;SEO-friendly&rdquo; URL generation. As our application grows, not only would we want our URLs to be user-friendly, but we probably also will want them to be optimized for search engine results. So, we need to change our application&rsquo;s configuration to use a slug.</p>

<p><em>Protip:</em> if anyone ever pop quizzes you about where the term &ldquo;slug&rdquo; comes from, you can totally school them with the following interesting fact: a &ldquo;slug&rdquo; used to be <a href="https://en.wikipedia.org/wiki/Slug_(publishing)">a shorter name</a> given to a newspaper article while it was in production; during the editing process, the article would be labeled by its slug, which would more specifically indicate the content of the story to the editors and reporters. The more you know, amirite?</p>

<p>There are obviously a lot of ways to approach this, but why reinvent the wheel by writing a bunch of methods that someone else has already written? Let&rsquo;s make use of someone&rsquo;s open source work and use the <code>acts_as_url</code> library to get the job done for us!</p>

<h2>Don&rsquo;t Let Slugs Slow You Down</h2>

<iframe src="//giphy.com/embed/11zeCgKZ1MaNuE" width="480" height="342" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>The <code>acts_as_url</code> library is actually part of the <code>stringex</code> gem, which adds some useful extensions to Ruby&rsquo;s <code>String</code> class. After we add this gem to our <code>Gemfile</code> (<code>gem "stringex"</code>) and run <code>bundle install</code>, we can get started doing a quick setup.</p>

<p>The documentation for this library is fairly straightforward, and a quick read-through gives us a good idea of what we need to do in order to make it work properly. The basic implementation of this library is four-fold:</p>

<ol>
<li>We need a column in our database that will map to the attribute used in generating our url.</li>
<li>We need to call the <code>acts_as_url</code> method in our model using the attribute name that we want to use for generating our url.</li>
<li>We need to override Rails&#8217; <code>to_param</code> method (Confused? Hang tight, we&rsquo;ll get there in a second!)</li>
<li>We need to <code>find_by</code> our new url attribute inside of our controllers.</li>
</ol>


<p>Let&rsquo;s take it step by step. First, we&rsquo;ll write a migration that will add a <code>slug</code> column to our <code>books</code> database. This is going to be the column that will map to a <code>slug</code> attribute on our <code>Book</code> objects:</p>

<pre><code class="ruby">class AddSlugColumnToBooks &lt; ActiveRecord::Migration
  def change
    add_column :books, :slug, :string
  end
end
</code></pre>

<p>Once we run <code>rake db:migrate</code> and add this attribute, we will want to add the <code>acts_as_url</code> class method to our <code>Book</code> model.</p>

<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  acts_as_url :title, url_attribute: :slug
end
</code></pre>

<p>The default behavior of this method expects that we have a column and attribute called <code>url</code> on our object. Since we aren&rsquo;t using the default attribute name, we need to specify the name of the attribute that we&rsquo;re using to store the generated url string. Thankfully, <code>acts_as_url</code> takes a bunch of options, including <code>url_attribute</code>, which is what we&rsquo;re using here. There are some other useful options <a href="https://github.com/rsl/stringex">worth checking out</a> in the documentation, including <code>scope</code>, <code>limit</code>, <code>truncate_words</code>, and <code>blacklist</code>.</p>

<p>Next, we&rsquo;ll need to override Rail&rsquo;s <code>to_param</code> method in order to actually <em>use</em> our generated url attribute. Basically, we&rsquo;ll just want to write our own <code>to_param</code> method and return our <code>slug</code> attribute from inside of it.</p>

<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  acts_as_url :title, url_attribute: :slug

  def to_param
    slug
  end
end
</code></pre>

<p>And finally, we need to make sure that we&rsquo;re finding our object using the appropriate attribute from within the context of our controller. The documentation suggests we use
the <code>find_by_url</code> method, but we could also use the <code>find_by</code> method in our controller as well.</p>

<pre><code class="ruby">class BooksController &lt; ApplicationController
  def show
    @book = Book.find_by(slug: params[:id]).decorate
  end
end
</code></pre>

<p>Nothing changes about how our controller works and we can still do all the fancy things we were doing before, like use a decorator (<a href="http://vaidehijoshi.github.io/blog/2015/01/13/tidying-up-those-views-using-decorators-in-rails/">Remember those?</a>). The only thing that happens now is that our original <code>book_path</code> helper will now use the <code>book</code> instance we passed it to generate a url with a slug instead of the primary key!</p>

<p>Success! We&rsquo;ve done it! Actually, we&rsquo;ve <em>almost</em> done it. One tiny little thing that I always forget is all of the books that already exist in our database. What about them? They all have a <code>slug</code> attribute, sure, and a <code>slug</code> column &ndash; but there&rsquo;s a slight problem: the column is empty! So we can&rsquo;t <code>find_by</code> the <code>slug</code> attribute for those books, can we? In fact, if we try to call <code>to_param</code> on any of our preexisting <code>Book</code> instances right now, all we&rsquo;ll get is <code>nil</code>!</p>

<p>No worries, we just need to call a method inside of our console:</p>

<pre><code class="ruby">♥ rails c
Loading development environment (Rails 4.1.4)
irb(main):001:0&gt; Book.initialize_urls
</code></pre>

<p>Now all of the <code>Book</code> instances that had empty <code>slug</code> attributes have ben initialized, and we&rsquo;re good to go! Right? Wrong. Because I haven&rsquo;t explained the whole <code>to_param</code> situation yet, and I promised that I would get to it. Now&rsquo;s the time to figure out the magic behind that!</p>

<h2>Rails Non-Sluggish Solution: <code>to_param</code></h2>

<p>The Rails solution to generating params for an object&rsquo;s url path comes from its elegant <code>to_param</code> method. By default, this method just calls <code>to_s</code> on a Plain Old Ruby Object, and converts it to an instance of Ruby&rsquo;s <code>String</code> class. However, there are plenty of places where Rails itself <em>overrides</em> this method (which explains why we also have to do it in the context of our own controller)!</p>

<p>In fact, the Rails documentation even explains when and how to go about redefining the implementation of this method:</p>

<blockquote><p>&ldquo;Notably, the Rails routing system calls <code>to_param</code> on models to get a value for the <code>:id</code> placeholder. <code>ActiveRecord::Base#to_param</code> returns the <code>id</code> of a model, but you can redefine that method in your models.&rdquo;</p></blockquote>

<pre><code class="ruby">class User
  def to_param
    "#{id}-#{name.parameterize}"
  end
end
</code></pre>

<p>Of course, we could have easily redefined this in the context of each of our models, but using the <code>acts_as_url</code> library reduces the amount of duplicated code that we need in each of our models, and is pretty sophisticated in that it allows us to use <em>different</em> attributes across different models to generate our url path.</p>

<p>Interestingly, <a href="https://github.com/rails/rails/blob/7f18ea14c893cb5c9f04d4fda9661126758332b5/activemodel/lib/active_model/conversion.rb#L71">the source code</a> for Rails&#8217; <code>to_param</code> method reveals some elegant checks as well. This method first checks whether the object as been persisted to the database, and then returns a string representing the object&rsquo;s key. We can actually see how the <code>to_key</code> method is being called from <em>inside</em> of <code>to_param</code>, and how the default return value of an unpersisted object&rsquo;s param will be <code>nil</code>. This is the magic that goes on under the hood when we were trying to find the <code>slug</code> attributes for all of those <code>Book</code> instances before we called <code>initialize_urls</code> on them!</p>

<p>So, even though slugs have a <em>reputation</em> of being slow, now we know how to speed through this problem with an elegant and quick solution! I can&rsquo;t say the same for this poor guy, though:</p>

<iframe src="//giphy.com/embed/1KJPg114jm68U" width="480" height="169" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>acts_as_url</code> library expects an <code>url</code> attribute on a model, and uses that to generate the path for an object. You need to override Rails&#8217; <code>to_param</code> method that, by default, will use the <code>id</code> of an object to generate its path.</li>
<li>This <a href="https://gist.github.com/jcasimir/1209730">awesome gist</a> by Jeff Casimir is the best write-up on slugs and Rails&#8217; url generation out there. Give it a read!</li>
<li>The original <code>to_param</code> method used to be defined inside of <code>ActiveRecord::Base</code>, but has since moved to the <code>ActiveModel::Conversion</code> module, which handles default conversions, including <code>to_model</code>, <code>to_key</code>, and <code>to_partial_path</code>. Read more about how these methods work in the Conversion <a href="http://apidock.com/rails/ActiveModel/Conversion">module documentation</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stop Worrying and Start Being Concerned: ActiveSupport Concerns]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/10/13/stop-worrying-and-start-being-concerned-activesupport-concerns/"/>
    <updated>2015-10-13T09:22:16-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/10/13/stop-worrying-and-start-being-concerned-activesupport-concerns</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/iQA2hMPX88icM" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>A few weeks ago, while learning everything I never knew about <a href="http://vaidehijoshi.github.io/blog/2015/09/29/using-pundit-the-cool-kid-of-authorization/">user authorization</a>, I also stumbled upon a cool refactoring pattern that I didn&rsquo;t even know existed. This pattern is based on the simple idea of Ruby modules and mixins, but is particularly handy when it comes to dealing with class methods and callbacks.</p>

<p>ActiveSupport is a pretty massive component within Rails, and it&rsquo;s responsible for a ton of different functionality, including language extensions and utilities. I last wrote about ActiveSupport back when we were exploring the <a href="http://vaidehijoshi.github.io/blog/2015/09/01/inflections-everywhere-using-activesupport-inflector/">Rails inflector</a> and the libraries it provides for handling the pluralization of different strings. This was way back in September, and at the time, my understanding of ActiveSupport was pretty limited. It turns out that yes, ActiveSupport does provide a bunch of different patterns to transform simple Ruby strings&hellip;but it also has a lot more going on inside of it. For example, the <strong>ActiveSupport Concern module</strong>, which only recently made its debut in Rails 4.</p>

<p>The ActiveSupport::Concern wrapper is an interesting way of encapsulating&hellip;well, certain functionality that you might be <em>concerned</em> with. These concerns take advantage of two directories that are automatically part of the load path within a Rails application: <code>app/models/concerns</code> and <code>app/controllers/concerns</code>. So, how do you write a concern, and what should go inside of it? Don&rsquo;t worry, that&rsquo;s exactly what we&rsquo;ll concern ourselves with next.</p>

<!--more-->


<h2>Should We Be Concerned?</h2>

<iframe src="//giphy.com/embed/374pcIBVEGb6g" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Concerns are meant to make our lives less complicated. Or at the very least, we should be less concerned about the quality of our code if we use concerns, right? But what are ActiveSupport&rsquo;s Concerns really meant to be used for? And how do we know if we should be using them? Well, to answer this question, we can turn to the creator of Rails himself. In a blog post pre-Rails 4 titled <em>Put chubby models on a diet with concerns</em>, DHH explains when and why to consider using ActiveSupport&rsquo;s Concern module:</p>

<blockquote><p>&ldquo;Concerns encapsulate both data access and domain logic about a certain slice of responsibility. Concerns are also a helpful way of extracting a slice of model that doesn’t seem part of its essence (what is and isn’t in the essence of a model is a fuzzy line and a longer discussion) without going full-bore Single Responsibility Principle and running the risk of ballooning your object inventory.&rdquo;</p></blockquote>

<p>When we talk about concerns, what we really are honing in on is the most effective <em>separation of concerns</em>. I really like the way that David thinks of models having an &ldquo;essence&rdquo;, and I think that this is a great way of approaching when and when <em>not</em> to use a concern.</p>

<p>Let&rsquo;s look at our bookstore application. We have an <code>User</code> model for anyone that signs up to use our application. Whenever a <code>User</code> signs up, we want to send them an email telling them that they&rsquo;ve been registered, and probably highlighting some of the cool things that they can do to set up their profile on our application. Now, this seems like something that only the <code>User</code> model would be concerned with, right? Well, yes, until we realize that we have another model that needs to share this same functionality!</p>

<p>For example, we now have organizations that want to sign up for our application. They also need to receive the same email and be &ldquo;registered&rdquo;. As our application grows, we might even want to create a <code>Registration</code> model, which would belong to an <code>User</code> and <code>Organization</code>. Now, obviously we could accomplish what we wanted to by just adding the same lines of code to both models, but that makes for neither DRY code, nor a great separation of concerns. But wouldn&rsquo;t it be great if we could take this piece of &ldquo;registration&rdquo; functionality, wrap it up, and only pull it out when we need to use it? It turns out that is exactly what we can do with <code>ActiveSupport::Concern</code>.</p>

<h2>Extending Our Concerns</h2>

<iframe src="//giphy.com/embed/dnNuJUQvEnmjC" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Before we write our concern, let&rsquo;s look at what our <code>User</code> model looks like. Here&rsquo;s a truncated version that contains only the logic pertaining to registering a user:</p>

<pre><code class="ruby">class User &lt; ActiveRecord::Base
    after_commit :register_user, on: :create

    def register_user
        # Where our logic for registering a user
        # would go. Would call on a background job
        # to perform and send our registration email.
    end
end
</code></pre>

<p>We very well <em>could</em> stick this inside of our <code>organization.rb</code> model file, but there&rsquo;s a better way to do this. There are a few steps to creating a concern, the first of which is recognizing where to put it! Since we&rsquo;re creating a concern for a model, this will live inside of our <code>app/models/concerns</code> directory. We&rsquo;ll call this concern a  <code>Registerer</code> concern, since that&rsquo;s its single responsibility, and we can preemptively namespace our concern under <code>Users</code>, which would make its path <code>app/models/concerns/users/registerer.rb</code>.</p>

<p>Next, we&rsquo;ll want to <code>extend</code> the Rails <code>ActiveSupport::Concern</code> module itself from within our concern:</p>

<pre><code class="ruby">module Users
    module Registerer
        extend ActiveSupport::Concern
    end
end
</code></pre>

<p>Now, for the actual writing, there&rsquo;s one method that&rsquo;s going to be our new best friend: the <code>included</code> method, which takes a block. A little-known fact about this callback is that it&rsquo;s actually defined by Ruby&rsquo;s <code>Module</code> class, and it&rsquo;s called whenever a module is &ldquo;included&rdquo; into another class or module. This is where we&rsquo;ll put the important class methods and callbacks that we want to be shared amongst the models that will use our concern.</p>

<pre><code class="ruby">module Users
    module Registerer
        extend ActiveSupport::Concern

        included do
            has_one :registration, dependent: :destroy

            after_commit :register_user, on: :create
        end

        def register_user
            send_registration_email(self)

            touch(:registered_at)
        end

        def send_registration_email(self)
            RegistrationEmailerJob.perform_later(self)
        end
    end
end
</code></pre>

<p>This is mostly straightforward. All the logic for a registration now lives in this single file, including the creating of a registration association on our target object (in this case, the <code>User</code> model), the registering of a user by passing our <code>User</code> instance (<code>self</code>) to our <code>RegistrationEmailerJob</code>, and the updating of the <code>registered_at</code> attribute on our <code>User</code> model using the <a href="http://vaidehijoshi.github.io/blog/2015/09/22/working-hard-or-hardly-working-part-2-custom-jobs/">touch method</a> &mdash; assuming, of course, that we&rsquo;ve defensively coded this attribute onto our <code>User</code> model. We&rsquo;re also able to use the <code>after_commit</code> callback hook, since the <code>included</code> method can accept callback names as parameters.</p>

<p>Now that we have all this code in one place, how do we add it to our model? Well, we can do it in a single line:</p>

<pre><code class="ruby">class User &lt; ActiveRecord::Base
    include Users::Registerer
end
</code></pre>

<p>All we need to do is <code>include</code> our concern, just as we would a module. And down the road, when we find out that we need to create <code>Organization</code> model that shares this set of functionality, all we need to do is add the exact same line to our new model:</p>

<pre><code class="ruby">class Organization &lt; ActiveRecord::Base
    include Users::Registerer
end
</code></pre>

<p>And here&rsquo;s the really nice part about utilizing concerns in this way: when we realize that we need to change how this works &mdash; maybe we need to add another job or service object, or perhaps another, more specific callback &mdash; we can add it to one place and update our logic in a single file! This ties in quite nicely to DHH&rsquo;s point of a model&rsquo;s &ldquo;essence&rdquo;. In this case, being able to be &ldquo;registered&rdquo; isn&rsquo;t necessarily something that pertains to the <code>User</code> model specifically. But, it also doesn&rsquo;t need to be its own <em>object</em> per se. Instead, we really just need a set of methods that can be available to be invoked upon an object, which is exactly what <code>ActiveSupport::Concern</code> provides us with.</p>

<h2>Helpful Inclusion</h2>

<p>Because concerns are so simple to extend and include, there are lots of use cases for them. We learned earlier that Rails comes with two <code>concerns</code> directories preloaded: one for <code>models</code>, and another for <code>controllers</code>. Let&rsquo;s look at a practical example for using <code>ActiveSupport::Concern</code> in the context of a controller.</p>

<p>We <a href="http://vaidehijoshi.github.io/blog/2015/09/29/using-pundit-the-cool-kid-of-authorization/">recently added</a> the <code>pundit</code> gem to our bookstore app for user authorization. But we only had a few controller actions that actually <em>needed</em> to be authorized; the rest of our controllers didn&rsquo;t need any authorization, because they could be accessed by anyone. Our <code>Reviews</code> controller was being authorized, for example, but our <code>Comments</code> controller didn&rsquo;t need any authorization whatsoever.</p>

<p>So, for the controllers that <em>didn&rsquo;t</em> need authorization, what did we do? Well, we were adding some <code>skip_after_actions</code> lines, which were instructions that the <code>pundit</code> gem documentation had given us:</p>

<pre><code class="ruby">class CommentsController &lt; ApplicationController
  skip_after_action :verify_authorized
  skip_after_action :verify_policy_scoped

  # RESTful controller actions go here!
end
</code></pre>

<p>Now, imagine we also have a <code>BlogsController</code> with just an <code>index</code> action API endpoint, which doesn&rsquo;t need to be authorized. And maybe we also have <code>TagsController</code>, which also doesn&rsquo;t need to be authorized by <code>pundit</code>. We <em>could</em> copy and paste these two lines into every single controller&hellip;<em>or</em>, we could use our newfound knowledge of <code>ActiveSupport::Concern</code>!</p>

<p>Let&rsquo;s share some of this code, shall we? We can create a <code>skip_authorized.rb</code> file inside of <code>app/controllers/concerns</code>. And inside of it, we&rsquo;ll include <code>Pundit</code> &mdash; otherwise, our <code>skip_after_actions</code> will have no idea what actions we&rsquo;re trying to skip! Our concern might look something like this:</p>

<pre><code class="ruby">module SkipAuthorized
  extend ActiveSupport::Concern

  included do
    skip_after_action :verify_authorized
    skip_after_action :verify_policy_scoped
  end
end
</code></pre>

<p>Pretty simple, right? And suddenly, our <code>CommentsController</code>, <code>BlogsController</code>, <code>TagsController</code>, and pretty much <em>every single</em> controller that we want to share these <code>skip_after_action</code> callbacks now can be refactored to have this single line:</p>

<pre><code class="ruby">class CommentsController &lt; ApplicationController
    include SkipAuthorized

    # RESTful controller actions go here!
end
</code></pre>

<p>And now, if we wanted to <code>rescue</code> from a <code>Pundit::UnauthorizedError</code>, we could add a single line, into a single file&hellip;but all of our controllers would mix that in! Similarly, we could create an <code>Authorized</code> concern for every controller that needed to actually implement <code>pundit</code> authorization. See, there&rsquo;s no need to worry for the rest of our days, because instead, we can just be concerned &mdash; ActiveSupport concerned!</p>

<iframe src="//giphy.com/embed/jfw9xNEouCJO" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>ActiveSupport&rsquo;s <code>Concern</code> module allows us to mix in callbacks, class and instance methods, and create associations on target objects. This module has an <code>included</code> method, which takes a block, as well as an <code>append_features</code> method and <code>class_methods</code> block, which you can read about in <a href="http://api.rubyonrails.org/classes/ActiveSupport/Concern.html#method-i-included">the source code</a>.</li>
<li>This <a href="http://engineering.appfolio.com/2013/06/17/ruby-mixins-activesupportconcern/">blog post</a> is pretty fantastic in its explanation of mixins, modules, and concerns.</li>
<li>Concerns are a little controversial in Railsland. This <a href="http://www.slideshare.net/justingordon/rails-conf-2014concernsdecoratorspresentersserviceobjectshelpershelpmedecideapril222014">slide deck</a> from RailsConf 2014 shares a bit about why that&rsquo;s the case.</li>
</ul>

]]></content>
  </entry>
  
</feed>
