<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-11-24T08:46:49-05:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Peeking Under the Hood of ActionController Parameters, Part 2]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/11/24/peeking-under-the-hood-of-actioncontroller-parameters-part-2/"/>
    <updated>2015-11-24T08:56:47-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/11/24/peeking-under-the-hood-of-actioncontroller-parameters-part-2</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/Hhu5dqPScjXRm" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p><em>This blog post is part of a series on strong parameters. Read Part 1 <a href="http://vaidehijoshi.github.io/blog/2015/11/17/peeking-under-the-hood-of-actioncontroller-parameters-part-1/">here</a>.</em></p>

<p>Rails often feels like a black box, with all of the complex logic abstracted away and hidden from view. This leaves behind a clean, convention-abiding framework where form follows function. But another, perhaps less-intentional side effect of all the &ldquo;metaprogramming away&rdquo; of this framework&rsquo;s complexities is a frequent lack on clarity of what&rsquo;s going on behind the scenes.</p>

<p>In my year of working with Rails, I&rsquo;ve come to appreciate and respect so many things about it. In fact, I think that there&rsquo;s something incredibly approachable about Ruby as one&rsquo;s first programming language, with Rails as its corresponding framework. And of course, there&rsquo;s something truly unique and welcoming about the Ruby and Rails programming community. All of these factors combined make it so easy for beginners of such different backgrounds to start building applications very quickly.</p>

<p>However, once you get past the intial stage of building applications with the basic CRUD operations, or if you&rsquo;re trying to build something a bit more complex  with added functionality, or trying to integrate with another framework, you eventually hit a wall where you realize that that you&rsquo;re not completely sure how something works. This can be a hard wall to climb over, especially given the fact that you can start building things very quickly with Rails. Some people have heavily critiqued this aspect of the framework, arguing that it&rsquo;s detrimential to abstract away so much of what&rsquo;s <em>actually</em> going on, which makes it difficult for people to understand what their code is truly doing under the hood. I&rsquo;ve peronally encountered this &ldquo;wall of abstraction&rdquo; a few different times, but each time I found some piece of logic that worked differently than I thought it would, it only lead me to learn something new about the framework. Most recently, that lead me down a wild goose chase into the source code for <code>ActionController::Parameters</code> &mdash; a class that I didn&rsquo;t even know existed!</p>

<!--more-->


<h2>Quack Like A Hash</h2>

<p><img src="http://geekandpoke.typepad.com/.a/6a00d8341d3df553ef01053719d13a970b-pi" style="display: block; margin-left: auto; margin-right: auto;"/></p>

<p>There&rsquo;s a well-known saying that Rubyists often attribute to duck typing: <em>if it looks like a duck, and quacks like a duck, it probably is a duck.</em> In other words, if an object behaves like another object, it doesn&rsquo;t matter that it&rsquo;s of a certain class or &ldquo;type&rdquo; (or species!) of another object, just so long as it can respond to the correct method calls to implement the behavior of that object.</p>

<p>This saying actually comes from a concept referred to as the &ldquo;duck test&rdquo;, which is a form of abductive reasoning, which is based on the idea that one can identify an unknown object by observing its habitual characteristics. However, this can be a little bit tricky because <em>sometimes</em>, just because something quacks like a duck and waddles like a duck doesn&rsquo;t mean that we should stop questioning what it actually is and just assume that it&rsquo;s a duck!</p>

<p>Let me explain with an example. Whenever we send or receive data from the server, it appears that everything is being sent as a <code>Hash</code>. If we look at our <code>GET</code> requests or <code>POST</code> and <code>PUT</code> requests using HTTP protocol, our data usually looks like some variation on a theme of something like the following:</p>

<pre><code class="ruby">{ order: 
    { 
        total: 100.00, 
        number: 'ABC123' 
    } 
}
</code></pre>

<p>If it acts like a hash, and quacks like a hash, it must be a hash, right? Well, not exactly. Last week we learned that <code>params</code> in our controllers are actually instances of <code>ActionController::Parameters</code>. But this data that we&rsquo;re sending back and forth still looks like its a plain old Ruby <code>Hash</code>. It also seems to behave like a hash, right? We can do something like this</p>

<pre><code class="ruby">if params[:order].present?
    @order.create(order_params)
end
</code></pre>

<p>and access a key in this so-called &ldquo;hash&rdquo; the same way we would with any other <code>Hash</code> data structure. So, what&rsquo;s different about <code>ActionController::Parameters</code>?</p>

<p>Well, let&rsquo;s find out. We&rsquo;ll start by opening up <a href="https://github.com/rails/rails/blob/9ab2d030209d9608a6c866d83210f5b3b7d2319e/actionpack/lib/action_controller/metal/strong_parameters.rb#L108">the source code</a> for this class, which lives inside of the <code>ActionController</code> module. The first thing we&rsquo;ll notice is this:</p>

<pre><code class="ruby">module ActionController
    class Parameters &lt; ActiveSupport::HashWithIndifferentAccess
    end
end
</code></pre>

<p>Interesting! The <code>Parameters</code> class subclasses from <code>ActiveSupport::HashWithIndifferentAccess</code>. If we were really curious about what type of object <em>this</em> class inherits from, we could trace that back to see that <code>HashWithIndifferentAccess</code> simply <a href="https://github.com/rails/rails/blob/df6048407faefdc6774a8b5a02344fd4b1a734b1/activesupport/lib/active_support/hash_with_indifferent_access.rb#L43">inherits from</a> the class <code>Hash</code>. So, what makes <code>HashWithIndifferentAccess</code> different from plain old Ruby hashes?</p>

<p>Well, the <a href="http://api.rubyonrails.org/classes/ActiveSupport/HashWithIndifferentAccess.html
">Rails guides</a> answers this question pretty well:</p>

<blockquote><p><code>HashWithIndifferentAccess</code> implements a hash where keys <code>:foo</code> and <code>"foo"</code> are considered to be the same. Internally symbols are mapped to strings when used as keys in the entire writing interface. You are  guaranteed that the key is returned as a string. This class is intended for use cases where strings or symbols are the expected keys and it is convenient to understand both as the same. For example the <code>params</code> hash in Ruby on Rails.</p></blockquote>

<p>Awesome, this answers our question and more! This subclass gives us the flexibility to access the keys in a <code>params</code> &ldquo;hash&rdquo; by either a string or a symbol. The <code>HashWithIndifferentAccess</code> class still responds to the majority of the same methods that a Ruby <code>Hash</code> instance does, but with some added functionality, which can be especially handy if we&rsquo;re dealing with JSON responses.</p>

<p><em>Protip:</em> we can easily create <code>HashWithIndifferentAccess</code> instances by creating a Ruby <code>Hash</code> instance and calling <code>with_indifferent_access</code> on it. This method is available to us since core extensions has the <code>with_indifferent_access</code> method defined on the <code>Hash</code> class by default:</p>

<pre><code class="ruby">â™¥ rails c
Loading development environment (Rails 4.1.4)
irb(main):001:0&gt; h = {a: 'hi', b: 'hello'}
.with_indifferent_access
=&gt; {"a"=&gt;"hi", "b"=&gt;"hello"}
irb(main):002:0&gt; h.class
=&gt; ActiveSupport::HashWithIndifferentAccess
</code></pre>

<p>So, parameters aren&rsquo;t quite a hash, but they quack pretty much exactly like how a hash would quack. But there must be a good reason why they are different classes, right? Let&rsquo;s investigate further.</p>

<h2>Waddle Like A Param</h2>

<iframe src="//giphy.com/embed/jgIDKTrvTssDK" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>On a very basic level, <code>ActionController::Parameters</code> could be simplified to hashes with some serious restrictions and permissions. Because <code>ActionController::Parameters</code> inherits from <code>ActiveSupport::HashWithIndifferentAccess</code>, we can fetch values from our params &ldquo;hash&rdquo; using a symbol <code>:key</code> or a string <code>"key"</code>. But there are a few things that we can&rsquo;t do so easily, and that&rsquo;s where the functionality of <code>ActionController::Parameters</code> really starts to come into play and begins to make a lot more sense.</p>

<p>We can easily create a new instance of <code>ActionController::Parameters</code>. In fact, we do it within the context of our controllers all the time!</p>

<pre><code class="ruby">permitted_params = params.require(:order).permit(:total)

permitted_params
# =&gt; {"total"=&gt;"100.00"}

permitted_params.class
# =&gt; ActionController::Parameters
</code></pre>

<p>Except usually we wrap it in a <code>_params</code> suffixed method like this:</p>

<pre><code class="ruby">def order_params
    params.require(:order).permit(:total)
end
</code></pre>

<p>Here is one example of the added functionality of this class. When we create a new instance of a <code>ActionController::Parameters</code> class, it is by default, not permitted.</p>

<pre><code class="ruby">params = ActionController::Parameters.new

params.permitted? 
# =&gt; false
</code></pre>

<p>The <code>permitted?</code> method actually doesn&rsquo;t do anything more than return an attribute on an instance of a <code>ActionController::Parameters</code> object, called <code>@permitted</code>:</p>

<pre><code class="ruby">def permitted?
    @permitted
end
</code></pre>

<p>So the question is, where does this attribute get set? Well, there are two places that can set this attribute to <code>true</code>. The first place is a method that we&rsquo;re already familiar with: the <code>permit</code> method! As we learned last week, this method calls <code>params.permit!</code> as its last line, after it filters out any paramters that aren&rsquo;t permitted scalar values (think <code>Symbol</code>, <code>String</code>, or <code>Hash</code>). However, we can also just call <code>permit!</code> on an instance of <code>ActionController::Parameters</code> ourselves.</p>

<pre><code class="ruby">params = ActionController::Parameters.new
params.permitted?
# =&gt; false

params.permit!
params.permitted?
# =&gt; true
</code></pre>

<p>The <code>permit!</code> method sets the <code>@permitted</code> attribute to <code>true</code>, and returns <code>self</code>, which in this case is just the instance of the params class. This method <a href="https://github.com/rails/rails/blob/9ab2d030209d9608a6c866d83210f5b3b7d2319e/actionpack/lib/action_controller/metal/strong_parameters.rb#L223">is quite useful</a> for mass assignment, since it effectively removes the need to list all the permitted values. It can be handy in a controller that is used only by admins that should have control over &mdash; and can be trusted with &mdash; updating all attributes of an object:</p>

<pre><code class="ruby"># def blog_params
    # params.require(:blog).permit(:title, 
        # :author, :published_at, :tags, 
        # :excerpt, :image, :image_caption, :external_url)
# end

def blog_params
    params.require(:blog).permit!
end
</code></pre>

<p>However, this doesn&rsquo;t really make sense to use unless you are <em>sure</em> that you want to allow all the values to the params hash to be whitelisted. Proceed with caution!</p>

<h2>Heavy Metal Controllers</h2>

<p>Now that we know a little bit more about <code>ActionController::Parameters</code> and what kinds of ducks &mdash; oops, I mean <em>objects</em> &mdash; they really are, there&rsquo;s one question that we probably still have floating around in our heads: where on earth does our params come from during the request-response cycle&hellip;and <em>how</em> does it get set on a controller?</p>

<p>To answer this question, we must trace back how a parameter comes in from a request, and then how it is set on a controller. It isn&rsquo;t magic (even though it seems like that&rsquo;s the case!). In reality, it&rsquo;s actually happening in a cool place called <code>ActionController::Metal</code>. Yes, that&rsquo;s a thing, and it happens to be the very class that <code>ActionController::Base</code> <a href="https://github.com/rails/rails/blob/7978ec722172b45e72ee78baefc23ab907a91131/actionpack/lib/action_controller/base.rb#L164">inherits</a> from. By default, we should always inherit from <code>ActionController::Base</code>, because it gives us a ton of functionality and modules that help speed things up.</p>

<p>But even <code>ActionController::Base</code> has to come from <em>somewhere</em>, right? And that somewhere happens to be <code>ActionController::Metal</code>, which is the simplest possible controller that we can create in Rails, which provides little more than a Rack interface. Here&rsquo;s a very, <em>very</em> simplified version of what that class looks like in the Rails source code:</p>

<pre><code class="ruby">class Metal &lt; AbstractController::Base
    # Very truncated from the Rails source code!

    attr_internal :headers, :response, :request

    def initialize
        @_headers = {"Content-Type" =&gt; "text/html"}
        @_status = 200
        @_request = nil
        @_response = nil
        @_routes = nil
        super
    end
end
</code></pre>

<p>As a request goes out or a response comes in, these values are set as instances on the controller itself! So if there was any doubt in your mind, everything in Ruby is an object &mdash; even controllers are just objects with instance variables and attr_readers and attr_accessors.</p>

<p>So, where do our parameters get set? Well, they also live in an instance attribute called <code>@_params</code>, which is set by a <a href="https://github.com/rails/rails/blob/2910956fc9006d3c26f56992dab630fa97b7f7bc/actionpack/lib/action_controller/metal.rb#L140">params method</a>. The parameters come in from a request, and are beautifully memoized in a method that looks like this:</p>

<pre><code class="ruby">def params
    @_params ||= request.parameters
end
</code></pre>

<p>Pretty amazing, right? That black box of <code>ActionController</code> and strong parameters doesn&rsquo;t seem so intimiating any more, does it?
It&rsquo;s a little strange that we always talk about and use <code>params.require</code> and the <code>permit</code> method so often in Rails, particularly when we are first starting out, but we don&rsquo;t necessarily question where it comes from! Or how it is set or being used, for that matter! But now we know. And we&rsquo;ll never mistake our strong params for a simple Ruby hash again.</p>

<p>Or a duck, for that matter.</p>

<iframe src="//giphy.com/embed/NTSMCNXQQ1xiE" width="480" height="346" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>An instance of <code>ActionController::Parameters</code> behaves a lot like a hash that can be accessed with either symbol or string keys. This class has some added methods like <code>permitted?</code> and <code>permit!</code> which check and set the <code>@permitted</code> instance attribute on a params object.</li>
<li>Curious to learn more about how strong params handles nested attributes? Check out this great <a href="http://patshaughnessy.net/2014/6/16/a-rule-of-thumb-for-strong-parameters">blog post</a> by Pat Shaughnessy.</li>
<li>New to <code>ActionController::Metal</code>? Head over to the Rails docs <a href="http://api.rubyonrails.org/classes/ActionController/Metal.html">to learn more</a> and read this helpful <a href="http://stackoverflow.com/a/18189580">StackOverflow post</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Peeking Under the Hood of ActionController Parameters, Part 1]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/11/17/peeking-under-the-hood-of-actioncontroller-parameters-part-1/"/>
    <updated>2015-11-17T08:39:52-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/11/17/peeking-under-the-hood-of-actioncontroller-parameters-part-1</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/iKufnbkSIcliM" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>When you write code every day for a living, it&rsquo;s easy to get hyper-focused on building out new features and getting things done quickly. What&rsquo;s much harder is to take a step back and figure out exactly how something is working. Of course, sometimes this happens inherently and without any effort on your part &mdash; say for example, when you&rsquo;re fixing a bug or need to integrate with a third-party service and are forced to understand what&rsquo;s happening on a more granular level. But generally speaking, that is less common when you&rsquo;re working a within a framework that you&rsquo;re already comfortable with and use daily, without giving it a second thought.</p>

<p>I had one of those &ldquo;take a step back and question everything&rdquo; kind of moments recently. I was writing a controller for the admin interface of a Rails application, and hit a roadblock. To be clear, there wasn&rsquo;t anything super complex about the controller I was writing; it had the basic CRUD actions that any controller does, and I had written controllers like it plenty of times before. Yet somehow, when I got to writing the <code>params</code> private method for this controller, I couldn&rsquo;t remember what methods I needed to use. I was super tempted to open up another controller and just copy and paste the strong parameters from one file into another. But I realized that this wasn&rsquo;t really going to help me at all. What I <em>really</em> needed to do was grasp how strong parameters worked on a more conceptual level. If I could understand why we use the methods that we use, and to what end, I would never need to even look up the documentation for whitelisting parameters ever again!</p>

<p>So that&rsquo;s exactly what I did. I decided to peek under the hood of Rails&#8217; <code>ActionController</code>, and set my mind to learning everything there was the know about strong parameters. <em>Spoiler alert:</em> I didn&rsquo;t completely succeed, and I definitely don&rsquo;t know everything about whitelisting parameters. But what I <em>did</em> finally come to understand was why we use the methods that we do (think <code>require</code> and <code>permit</code>), and why we invoke them in that order. And hopefully I&rsquo;ll be able to explain how some that black box magic in Rails <em>actually</em> works!</p>

<!--more-->


<h2>Strong(est) Params</h2>

<iframe src="//giphy.com/embed/oB6nlaw4QJ8TS" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>When we&rsquo;re first introduced to the Rails framework, there are some fairly basic components that we learn about, including the MVC structure, which stands for Model, View, Controller. Personally, I found models and views to be far easier to grasp than controllers. Controllers were a whole other beast entirely. In fact, one of the very first concepts that <a href="http://vaidehijoshi.github.io/blog/2014/10/30/have-you-met-your-controller-yet/">I struggled with</a> was the very basics of writing a controller action! I eventually got a better at that, and now for our bookstore application, I have a more sophisticated controller (in this case, for our <code>Order</code> objects), which looks like this:</p>

<pre><code class="ruby">class OrdersController &lt; ApplicationController
    def create
        @order = Order.create(order_params)

        render json: order
    end

    def show
        render json: order
    end

    def update
    if order.update(order_params)
        render json: order
    else
        render json: {}, status: :unprocessable_entity
    end
    end

    def destroy
        order.destroy

        render json: {}
    end

    private
    def order
        @order ||= Order.find(params[:id])
    end

    def order_params
        # OH GOD WHY?!
    end
end
</code></pre>

<p>Nice! We&rsquo;re using our new <a href="http://vaidehijoshi.github.io/blog/2015/11/10/methods-to-remember-things-by-ruby-memoization/">memoization</a> technique, and we&rsquo;re rendering json responses to make it much easier to integrate with a JavaScript frontend; of course, we could have also just rendered our <code>@order</code> instance if this were a simple Rails application with no frontend framework. But&hellip;there&rsquo;s one thing that we&rsquo;re still missing, and clearly put off because I was dreading it: our strong parameters!</p>

<p>The <code>ActionController</code> <a href="http://edgeapi.rubyonrails.org/classes/ActionController/StrongParameters.html">strong parameters</a> module was introduced back in 2012 with the release of Rails 4. The idea behind strong params was to abstract out the creation of models via mass assignment into the controller, rather than in the context of a model. Prior to this feature, we used to need to whitelist attributes in our models using <code>attr_accessible</code></p>

<pre><code class="ruby">class Order &lt; ActiveRecord::Base
    attr_accessible :total, :number
end
</code></pre>

<p>in order to use mass assignment to instantiate an object from our controller actions:</p>

<pre><code class="ruby">class OrdersController &lt; ApplicationController
    def create
        @order = Order.create(params[:order])
    end
end
</code></pre>

<p>Not the best solution, right? Enter our knight in shining armor: <code>strong_parameters</code>, a <a href="https://github.com/rails/strong_parameters">gem</a> that the Rails core team released to fix this problem, which was eventually merged into Rails. Okay, let me rephrase that: our rather <em>misunderstood</em> knight in shining armor.</p>

<p>In order to comprehend how strong params permits attributes, there are two essential methods we are required to understand.</p>

<h2>Requirements</h2>

<iframe src="//giphy.com/embed/NTzW6P8cpt90Q" width="480" height="298" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>The main reason for even <em>needing</em> strong parameters of any sort is to ensure that we&rsquo;re only passing safe, protected data from our user-accesible interface. We don&rsquo;t really expect most users to try to pass in malicious data, but it&rsquo;s always a possibility. Moreover, there are various situations (dealing with money, for example, or people&rsquo;s personal information) when delicate information must be passed around securely across the web.</p>

<p>So, how can we ensure that only the correct data is being passed through, and that too in a <em>safe</em> way? The Rails solution to this problem is to <strong>whitelist</strong> a set of attributes that should be allowed to be modified and passed through by a user (regardless of whether the role of the user is that of a guest, admin, etc.).</p>

<p>The first step to whitelisting any set of attributes is making sure that the parameter we are looking to &ldquo;whitelist&rdquo; is actually present. If we think about it, this is pretty logical: how can we pass in the correct attributes to create or update an object if don&rsquo;t first check that we have the parameter that contains the attributes we need? Only once we ensure that a parameter exists can we begin to strip away the &ldquo;blacklisted&rdquo; attributes.</p>

<p>In fact, that&rsquo;s exactly what this method does under the hood. If we peek into the <a href="https://github.com/rails/rails/blob/9ab2d030209d9608a6c866d83210f5b3b7d2319e/actionpack/lib/action_controller/metal/strong_parameters.rb#L246">source code</a> for this method, this is what we&rsquo;ll find:</p>

<pre><code class="ruby">def require(key)
    value = self[key]
    if value.present? || value == false
        value
    else
        raise ParameterMissing.new(key)
    end
end
</code></pre>

<p>At this point, we should be wondering what <code>self</code> is in the context of this method. In other words, what object responds to this <code>require</code> method? And what is this <code>ParameterMissing</code> error, exactly? Let&rsquo;s take a look at the <code>require</code> <a href="http://api.rubyonrails.org/classes/ActionController/Parameters.html#method-i-require">method documentation</a> to find out:</p>

<blockquote><p><code>require</code> ensures that a parameter is present. If it&rsquo;s present, returns the parameter at the given key, otherwise raises an ActionController::ParameterMissing error.</p></blockquote>

<p>Okay, so now we know that the error being raised in the conditional is actually an <code>ActionController::ParameterMissing</code> error. One question answered. But what does <code>require</code> get invoked on? Well, it turns out that the answer to that is a new instance of an <code>ActionController::Parameters</code> object!</p>

<p>There&rsquo;s a <a href="http://stackoverflow.com/a/18426829">great StackOverflow answer</a> that points this fact pretty explicitly. The <code>params</code> object that we refer to in the context of our controllers gets treated as though it&rsquo;s just an instance of a Ruby <code>Hash</code>. But in actuality, it&rsquo;s an instance of something called <code>ActionController::Parameters</code>, which is the object that responds to the <code>require</code> method. But more on that a little bit later.</p>

<p>For now, all that matters is that the <code>require</code> method returns a new instance of an <code>ActionController::Parameters</code> object for the key that is passed into it. If that key doesn&rsquo;t exist in the object, it throws an error. What does this mean, exactly? Well, when we write our <code>order_params</code> method in our <code>OrdersController</code>, it will begin like this:</p>

<pre><code class="ruby">def order_params
    params.require(:order)
end
</code></pre>

<p>We&rsquo;re actually returning the <em>value</em> of the parameter at the key that we&rsquo;re requiring (in our case, <code>order</code>):</p>

<pre><code class="ruby">params = ActionController::Parameters.new(order: { total: 100.00, number: 'ABC123' })

params.require(:order)
# =&gt; { total: 100.00, number: 'ABC123' }
</code></pre>

<p>And what&rsquo;s more: we&rsquo;re creating a new instance of an <code>ActionController::Parameters</code> object whenever we invoke <code>params</code> in our controller! Okay, so that&rsquo;s the first step: making sure our parameter exists. The second requires a bit more&hellip;<em>permission</em> on our part.</p>

<h2>Permissions</h2>

<p>Now that we&rsquo;re sure that our parameter exists, we need to actually <em>permit</em> the correct attributes on our objects. Since our users can add more books to their cart while they&rsquo;re shopping, they should be able to update the <code>total</code> of their <code>Order</code>. However, the <code>number</code> on their order is unique (and probably has an index on it), and is generated on the backend when it&rsquo;s created. We definitely <em>don&rsquo;t</em> want them to be able to update or modify that value at any point!</p>

<p>So, we need to <code>permit</code> a single attribute on our required parameter key. That means that our whitelisted params now look like this:</p>

<pre><code class="ruby">def order_params
    params.require(:order).permit(:total)
end
</code></pre>

<p>So what&rsquo;s happening here? Well, the <code>permit</code> method also is defined on the <code>ActionController::Parameters</code> class. It returns a new <code>ActionController::Parameters</code> instance, which includes only the given filters &mdash; the arguments that we&rsquo;re passing in here as symbols &mdash; and sets <a href="https://github.com/rails/rails/blob/9ab2d030209d9608a6c866d83210f5b3b7d2319e/actionpack/lib/action_controller/metal/strong_parameters.rb#L444">an attribute</a> using a <strong>protected instance method</strong> called <code>@permitted</code> on the newly-created <code>ActionController::Parameters</code> to be <code>true</code>.</p>

<p>This means that if we invoke <code>permit</code> on our required parameters, we&rsquo;ll return the actual hash, not the value for the parameter</p>

<pre><code class="ruby">params = ActionController::Parameters.new(order: { total: 100.00, number: 'ABC123' })

params.permit(:order)
# =&gt; { order { total: 100.00, number: 'ABC123' } }
</code></pre>

<p>Wait, but how does this happen? Well, if we look at the source code, we&rsquo;ll see that the permit method takes an array of arguments named <code>filters</code>, and then iterates through them to check what type of object they are:</p>

<pre><code class="ruby">def permit(*filters)
  params = self.class.new

  filters.flatten.each do |filter|
    case filter
    when Symbol, String
      permitted_scalar_filter(params, filter)
    when Hash then
      hash_filter(params, filter)
    end
  end

  unpermitted_parameters!(params) if self.class.action_on_unpermitted_parameters

  params.permit!
end
</code></pre>

<p>The reason for the <code>case</code> statement here is to handle nested attributes, which might look like this:</p>

<pre><code class="ruby">params.require(:order).permit(
    :total,
    :books: { 
        { # book_object_1 }, 
        { # book_object_2 }, 
        { # book_object_3 } 
    }
)
</code></pre>

<p>So if we really only need these two methods to require a parameter key and then permit the correct key and value pairs inside of it, what&rsquo;s the need for having a seperate method? Why do we need to encapsulate this logic? We could very well just do something like this, right? And it would work:</p>

<pre><code class="ruby">class OrdersController &lt; ApplicationController
    def create
        @order = Order.create(params.require(:order).permit(:total))
    end
end
</code></pre>

<p>It turns out that abstracting our strong params out into a private <code>order_params</code> method is just a good practice that was established by the Rails core team. The Rails guides <a href="http://edgeapi.rubyonrails.org/classes/ActionController/StrongParameters.html">explain this</a> pretty well:</p>

<blockquote><p>Using a private method to encapsulate the permissible parameters is just a good pattern since you&rsquo;ll be able to reuse the same permit list between create and update. Also, you can specialize this method with per-user checking of permissible attributes.</p></blockquote>

<p>Another reason for having a separate method is because things can get kind of tricky once you need to permit nested attributes. At that point, it&rsquo;s especially important to understand how these methods work.</p>

<p>Tune in next week, when I&rsquo;ll continue this deep dive by exploring the <code>ActionController::Parameters</code> class and answer the super confusing question of <em>where params get instantiated</em> (no really&hellip;where?), and what makes a parameter different from a hash (no really, I promise that they&rsquo;re different!). Until then, keep peeking into that source code and stay afloat like this guy:</p>

<iframe src="//giphy.com/embed/lpLWBoCnX1IkM" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>require</code> method ensures that a parameter key is present, and throws an error of it doesn&rsquo;t exist. The <code>permit</code> method filters out the keys that we want to whitelist based on the filters (which we pass in as symbols) that are passed into it.</li>
<li>Check out the documentation on <code>ActionController::Parameters</code> in the <a href="http://api.rubyonrails.org/classes/ActionController/Parameters.html">Rails guides</a>.</li>
<li>This blog post does a great job of explaining <a href="http://blog.trackets.com/2013/08/17/strong-parameters-by-example.html">permit and require</a> by example.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Methods to Remember Things by: Ruby Memoization]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/11/10/methods-to-remember-things-by-ruby-memoization/"/>
    <updated>2015-11-10T09:03:09-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/11/10/methods-to-remember-things-by-ruby-memoization</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/xUrmE6PJBEbni" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>A couple of months ago, I wrote <a href="http://vaidehijoshi.github.io/blog/2015/08/25/unlocking-ruby-keywords-begin-end-ensure-rescue/">a blog post</a> on some basic Ruby keywords including <code>begin</code>, <code>end</code>, <code>rescue</code>, and <code>ensure</code>. A few days after publishing said post, another Rubyist friend of mine sent me a message telling me to read about memoization. &ldquo;You basically describe memoization in your post without ever explicitly explaining it,&rdquo; she had said. At the time, I had added it to my ever-growing list of &ldquo;things to learn more about&rdquo;, but promptly forgot to make the time to learn about the concept.</p>

<p>Cut to last week, when I was trying to write a controller action that had to do something a bit more complex than simply render a JSON-formatted response of a given resource. So, I started off by implementing a <code>begin</code> <code>end</code> block to execute a bunch of code that needed to run on it&rsquo;s own. I remembered writing about how to use these two keywords, so I pulled up my post and was suddenly reminded of&hellip;<strong>memoization</strong>. It turned out that I actually needed to use memoization in this controller action, and had already been using it elsewhere in the very same project! But, I still didn&rsquo;t understand what it was, or in what way I had been using it so far.</p>

<p>After putting it off for months, it was finally time to learn about this memoization business. For those of us (myself included!) who haven&rsquo;t quite gotten the memo on memoization, here&rsquo;s the brief lowdown: the term dates back to the year 1968, when it was <a href="https://en.wikipedia.org/wiki/Memoization">coined by</a> Donald Michie, a British artificial intelligence researcher who worked alongside Alan Turing at the Code and Cypher School at Bletchley Park during WWII. The basic idea of a memoization function is that it can &ldquo;remember&rdquo; the result that corresponds to a set of given inputs. In other words, it can store the results of an expensive function call by &ldquo;saving&rdquo; the result such that when you call the same function again with the same parameters, you don&rsquo;t need to rerun the function. In the context of computer science specifically, this is a kind of optimization technique that is used to make programs more efficient and much faster. There are a few different ways that memoization pops up in Ruby and Rails, which is exactly what we&rsquo;ll need to learn about next!</p>

<!--more-->


<h2>Multiple Memoization</h2>

<iframe src="//giphy.com/embed/yg4IHVMEvUxby" width="480" height="240" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>There are effectively two types of memoization when it comes to Rails applications: simple, single-line memoization, and the more complex form found in multiple-line memoization. They still are the same concept and we can implement them using the same conditional operator; the fundamental difference between the two types hinges upon how much logic needs to be run for the object that we&rsquo;re trying to &ldquo;remember&rdquo;, or in other words, <em>memoize</em>.</p>

<p>Let&rsquo;s start with a simple memoization example. In our bookstore application, we have a piece of functionality that allows users to write reviews for books that they have purchased. Currently however, our <code>ReviewsController</code> doesn&rsquo;t account for that functionality. It only has a simple <code>index</code> action that is currently rendering all the <code>Reviews</code> that have been <code>published</code>:</p>

<pre><code class="ruby">class ReviewsController &lt; ApplicationController
    def index
        render json: Review.published
    end
end
</code></pre>

<p>The <code>published</code> method that we&rsquo;re chaining on here is just a simple scope that we <a href="http://vaidehijoshi.github.io/blog/2015/11/03/hunting-down-the-scoop-on-activerecord-scopes/">learned about last week</a>, and added on to our <code>Review</code> model:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    scope :published, -&gt; {
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', Time.zone.now)
    }
end
</code></pre>

<p>We can implement some simple memoization by abstracting out what&rsquo;s currently happening in the <code>index</code> action of our <code>ReviewsController</code>. Since memoization roughly translates to the concept of &ldquo;remembering&rdquo; the return value of a function without having to call it again, we could use Ruby&rsquo;s instance variable to store the return value of an expensive function call. In our case, the function that we&rsquo;re calling and saving to our instance variable is the <code>published</code> scope on our <code>Review</code> class:</p>

<pre><code class="ruby">class ReviewsController &lt; ApplicationController
    def index
        render json: reviews
    end

    private
    def reviews
        @reviews ||= Review.published
    end
end
</code></pre>

<p>Now our <code>index</code> action is calling the private <code>reviews</code> method, which is &ldquo;remembering&rdquo;, or essentially assigning and saving the return value of <code>Review.published</code> to the instance variable <code>@reviews</code>. Right now it doesn&rsquo;t look like much, but this could help keep our code clean as we continue to build out this controller.</p>

<p>The tricky thing to keep in mind with controllers is that they are nothing more than Ruby classes. This is important to remember because this instance variable will exist for the lifespan of a single request; if we make a network call (probably a <code>GET</code> request) when we query the <code>index</code> endpoint of our <code>ReviewsController</code>, the <code>@reviews</code> instance variable will be assigned and exist for the duration of that request. Once that request has completed, that instance of the controller is no longer needed and a new one would be created. Right now, we&rsquo;re not doing very much in our existing codebase with this piece of functionality. But why might that be important? Let&rsquo;s find out.</p>

<p>Imagine that the <code>index</code> action of our <code>ReviewsController</code> needs to be rewritten to account for a new piece of functionality. Instead of merely loading all of our <code>published</code> book reviews, we now want to be able to account for some query params. For example, if a user navigated to a route such as <code>/the-sound-and-fury/reviews</code>, they should be able to see all the published books reviews for that specific book, based on the book slug that is used in the URL. We immediately know that we need to change our <code>reviews</code> method. But it&rsquo;s not going to be as simple as just chaining on another method; we have a bit more complicated logic going on here.</p>

<p>First, we&rsquo;ll need to check whether there&rsquo;s a <code>book_slug</code> parameter being passed in. If there is, we&rsquo;ll need to query for the correct book reviews based on that query param. If there is no parameter being passed in, we&rsquo;ll just want to return our <code>published</code> Reviews. To account for this new feature, our method may now look something like this:</p>

<pre><code class="ruby">class ReviewsController &lt; ApplicationController
        def index
        render json: reviews
    end

    private
        def reviews
        @reviews ||= begin

        _reviews = Review.published

        if params[:book_slug].present?
            _reviews = _reviews.where(book_slug: params[:book_slug])
        end

        _reviews
      end
    end
end
</code></pre>

<p>Here, we&rsquo;re implementing the multiple-line form of memoization, which calls for the use of our favorite Ruby keywords, <code>begin</code> and <code>end</code>. We&rsquo;re first setting a local <code>_reviews</code> variable to all the <code>published</code> reviews; if there&rsquo;s a <code>book_slug</code> query parameter being passed in for this <code>GET</code> request, we&rsquo;re modifying this variable to select only the published reviews that have a <code>book_slug</code> attribute that matches the query param that was passed in. Ultimately, we&rsquo;re returning our <code>_reviews</code> variable, which will either be just an array of all the published reviews, or the published reviews that match our query parameter.</p>

<p>We don&rsquo;t necessarily have to use a variable name prepended with an <code>_</code> underscore, but I&rsquo;ve seen other developers do this in their code and I&rsquo;ve come to realize that this can be one way of denoting to other developers that this variable is being modified but not explicitly used. It can be a way of indicating that this variable is only necessary to <em>assign</em> the instance variable <code>@reviews</code>, and is never called or referenced outside of our <code>begin</code> <code>end</code> code block. We should also note that our <code>index</code> action hasn&rsquo;t changed one bit. All of our modified logic still lives in the same method, and is still accessible from our <code>@reviews</code> instance variable, from any action within this controller.</p>

<p>Sometimes, the <code>begin</code> <code>end</code> block for multiple-line memoization is simply used because all of the code won&rsquo;t fit on a single line. The <code>begin</code> <code>end</code> block ensures that the code will be executed together in a single chunk, which effectively encapuslates the block of code in the same way, as though it were written on a single line, but makes it look much prettier and far easier to read.</p>

<h2>Crazy For Conditionals</h2>

<iframe src="//giphy.com/embed/fNlRJ7Gwr4Lba" width="480" height="202" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>In order to really understand what&rsquo;s going on with memoization, it&rsquo;s important to identify the behind the scenes action of Ruby&rsquo;s &ldquo;or equals&rdquo; (sometimes referred to as the &ldquo;double pipe&rdquo;) operator: <code>||=</code>.</p>

<p>When I first learned about this operator, I initially thought that it functioned by telling the Ruby interpreter something equivalent to, <em>Hey, if a value for this variable already exists, please return that. Otherwise, if this variable doesn&rsquo;t have a value yet, assign it to whatever block of code comes next</em>. But apparently, that&rsquo;s not exactly what&rsquo;s going on here. In actuality, this operator is far more nuanced that most people may initially think it to be. Peter Cooper&rsquo;s <a href="http://www.rubyinside.com/what-rubys-double-pipe-or-equals-really-does-5488.html">Ruby Inside blog post</a> does a fantastic job of unpacking all the different edge cases of the or equals operator, including the various scenarios when it can be a bit problematic. I really like the way that he summarizes the misconception behind the &ldquo;or equals&rdquo; operator quite simply as follows:</p>

<blockquote><p>A common misconception is that <code>a ||= b</code> is equivalent to <code>a = a || b</code>, but it behaves like <code>a || a = b</code>. In <code>a = a || b</code>, <code>a</code> is set to something by the statement on every run, whereas with <code>a || a = b</code>, <code>a</code> is only set if <code>a</code> is logically false (i.e. if it&rsquo;s <code>nil</code> or <code>false</code>) because <code>||</code> is &lsquo;short circuiting&rsquo;. That is, if the left hand side of the <code>||</code> comparison is true, there&rsquo;s no need to check the right hand side.</p></blockquote>

<p>In other words, what he&rsquo;s saying here is that when we write something like this:</p>

<pre><code class="ruby">@review ||= Review.find(params[:id])
</code></pre>

<p>what we&rsquo;re <em>actually</em> doing is saying something along these lines to the Ruby interpreter: <em>If</em> <code>@reviews</code> <em>currently evaluates to</em> <code>false</code><em>, then set it to the the return value of</em> <code>Review.find(params[:id])</code><em>. But, if</em> <code>@reviews</code> <em>is not a falsey value, don&rsquo;t assign or set the variable to anything. Just stop running and exit out of the method.</em></p>

<p>It&rsquo;s also worth bringing up the fact that both <code>nil</code> and <code>false</code> are &ldquo;falsey&rdquo; values, which means that if <code>@review</code> was <code>nil</code> and empty when this line runs, the method would <em>not</em> short circuit, and would continue to execute after the <code>||=</code> operator, thereby assigning the <code>@review</code> instance variable during method execution. This is significant if you are integrating with an external API where you can&rsquo;t be sure if your instance variable will be falsey or not:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    def goodreads_reviews
        @goodreads_reviews ||= begin
            # Some logic here that uses a third-party
            # API like Goodreads and returns an array 
            # of reviews, if any happen to exist.
        end
    end
end
</code></pre>

<p>In this case, if our API endpoint that we&rsquo;re querying happens to return <code>nil</code> for a set of reviews or for a particular book that may have no reviews, every single place that we&rsquo;re calling this method will be running the logic inside of the <code>begin</code> <code>end</code> block. This pretty much makes our idea of &ldquo;memoizing&rdquo; the result of this expensive query a moot point, because we&rsquo;re not &ldquo;remembering&rdquo; the return value, but instead just running that line of code again and again. We could fix this by writing a less beautiful but more flexible method like this:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    def goodreads_reviews
        unless defined? @goodreads_reviews

        @goodreads_reviews ||= begin
            # This will only execute now if
            # @goodreads_reviews is undefined
            # as nil, and not otherwise.
        end

        @goodreads_reviews
    end
end
</code></pre>

<p>This isn&rsquo;t as big of an issue if we&rsquo;re using an <code>ActiveRecord</code> method or a scope, which would return an empty array <code>[]</code>, and not <code>nil</code>. But it&rsquo;s important to keep the memoization of falsey values in mind, since we could very easily be making a lot more queries to our database than we might realize.</p>

<p>Finally, there&rsquo;s another tricky situation when it comes to memoizing a method that accepts an argument. Justin Weiss&#8217; <a href="http://www.justinweiss.com/articles/4-simple-memoization-patterns-in-ruby-and-one-gem/">blog post</a> explains how to get around this by using the Ruby <code>Hash</code> initializer method (<code>Hash.new</code>), which ensures that the only time a block will be executed is if we try to access a key that doesn&rsquo;t yet have a value assigned to it in the context of our hash. This can be a little hard to understand at first, but is pretty useful for more complex forms of method memoization.</p>

<h2>Of memos long gone</h2>

<p>Memoization has clearly been around for a long time in the computer science world, but interestingly, it&rsquo;s had a bit of a rocky history in Railsland. It turns out that there actually used to be an entire <code>ActiveSupport::Memoizable</code> <a href="http://apidock.com/rails/v3.2.13/ActiveSupport/Memoizable/memoize">module</a> back in an older version of Rails 3! Apparently, there was a lot of controversy surrounding that particular module, and it was deprecated and, eventually, completely removed in 2011.</p>

<p>At the time of deprecation, the Rails core team encouraged everyone to use the <code>||=</code> &ldquo;or equals&rdquo; operator format of method memoization, and what&rsquo;s really cool about this is that you can actually see examples of how the core team members changed the code in <a href="https://github.com/rails/rails/commit/f2c0fb32c0dce7f8da0ce446e2d2f0cba5fd44b3">the exact commit</a> where the Memoizable module was removed. Here&rsquo;s one example in the Rails source code of method memoization in the <code>DateTimeSelector</code> class:</p>

<pre><code class="ruby">class DateTimeSelector
    @month_names ||= begin
        month_names = @options[:use_month_names] || translated_month_names
        month_names.unshift(nil) if month_names.size &lt; 13
        month_names
    end
end
</code></pre>

<p>Pretty cool, right!?</p>

<p>Of course, some Rubyists were not a big fan of this commit and module deprecation. In fact, some developers have fought to keep the module alive in the form of gems! The two that are the most popular are <a href="https://github.com/dkubb/memoizable">the <code>memoizable</code> gem</a> as well as <a href="https://github.com/matthewrudy/memoist">the <code>memoist</code> gem</a>. Both of them ultimately allow us to write a memoizable method like this:</p>

<pre><code class="ruby">require 'memoist'
class Order
    extend Memoist

        def card_last_4
        # Logic to decrypt and
        # return last 4 digits
        # of credit card on the
        # order, properly formatted.
    end
    memoize :card_last_4
end
</code></pre>

<p>Effectively, this continues what the <code>ActiveSupport::Memoizable</code> module used to allow. In the method above, calling <code>card_last_4</code> on an instance of an <code>Order</code> class would only be calculated once, and would be memoized from that point on.</p>

<p>I haven&rsquo;t used either of these gems because I personally would prefer to follow Rails conventions. But, I plan on playing around with them a bit in order to try and understand why it was deprecated, and why it implemented in the first place. Of course, we could also read the entire <a href="https://github.com/rails/rails/commit/36253916b0b788d6ded56669d37c96ed05c92c5c">Github discussion</a> that took place at the time of deprecation, but that&rsquo;s a whole lot of comments to read.</p>

<p>No matter what form of method memoization we choose to use, there are certain times when it makes a lot of sense and is clearly the right tool for the job. Anytime we find ourselves making repeated database queries, or time-consuming expensive calculations, or repeated calculations that are never <em>really</em> going to chance for an instance of a class or a controller, memoization using Ruby&rsquo;s <code>||=</code> operator is probably our best bet. And now that we know the theory and history behind Ruby method memoization, we&rsquo;ll never forget!</p>

<p>I hope.</p>

<iframe src="//giphy.com/embed/TidlFj5lXMEkU" width="480" height="201" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>Memoization is a long-standing computer science concept that is basically the idea of &ldquo;remembering&rdquo; the value of a function to avoid running expensive method calls and calculations multiple times in our code.</li>
<li>The crux of Ruby&rsquo;s memoization techniques relies upon using the conditional &ldquo;or equals&rdquo; operator <code>||=</code>, which assigns a value and executes the following line of code <em>only</em> if the variable being assigned is not falsey (i.e. not <code>nil</code> or <code>false</code>).</li>
<li>There are some great blog posts on the basics of Ruby memoization. This two-part series (<a href="http://gavinmiller.io/2013/basics-of-ruby-memoization/">part one</a> and <a href="http://gavinmiller.io/2013/advanced-memoization-in-ruby/">part two</a>) is a pretty good place to start.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hunting Down the Scoop on ActiveRecord Scopes]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/11/03/hunting-down-the-scoop-on-activerecord-scopes/"/>
    <updated>2015-11-03T08:43:46-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/11/03/hunting-down-the-scoop-on-activerecord-scopes</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/PzrPi0UVzgYHm" width="480" height="254" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Over the past forty or so Tuesdays &mdash; has it really been that many?! &mdash; I&rsquo;ve written on a spread of topics. There&rsquo;s a slight problem with this: sometimes I forget what I have and haven&rsquo;t written about. Here&rsquo;s a case in point for you: last week, I wrote about <a href="http://vaidehijoshi.github.io/blog/2015/10/27/digging-into-the-finder-object-pattern/">finder objects</a>, and casually tossed in some scopes into my models. It turns out, I&rsquo;ve never actually written about how scopes work, or what they really do!</p>

<p>I know, I know, that&rsquo;s pretty terrible of me. I actually learned about scopes awhile ago, and now I use them fairly often in my applications. However, I got so used to writing them, that I never really thought that much about how they work behind the scenes. In fact, when I sat down to write <em>this</em> post, I had to go on a hunt into the Rails source code and Ruby blogosphere to figure out what was going on under the hood every single time I implemented a scope in my code.</p>

<p>The main reason that I like to use <strong>ActiveRecord scopes</strong> is because they allow us to specify commonly-used queries, but encapsulate these queries into methods, which we can then call on our models or association objects. However, my hunt lead me to find out that scopes have been around for awhile in Railsland, so they&rsquo;re not exactly that new. But, what&rsquo;s interesting about them is how their implementation has changed and grown with different releases of Rails. There&rsquo;s also a lot of debate over how and when scopes are different from their counterparts, or simpler class methods. But what makes a scope exactly? Well, it&rsquo;s finally time for us to hunt down the answer to that question.</p>

<!--more-->


<h2>The simplest of scopes</h2>

<iframe src="//giphy.com/embed/uH37VANhgHDaM" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>While developing applications, we often run into a situation where we want to select a particular group of objects (read: rows from our database) based on the characteristics that they share. The basic implementation of scopes can be summed up as this simple idea: being able to narrow down the objects that we want into a specific subset, based on some given parameters. We can tell <code>ActiveRecord</code> (an Object Relational Mapper, or ORM) to select a certain group of objects by implementing a scope that is specific to a model. Luckily, scopes aren&rsquo;t too difficult to define, and mostly adhere to a simple structure.</p>

<p>In our bookstore app for example, we have a <code>Review</code> object, that we allow our users to write about the <code>Book</code>s that they purchase through our store. For now, our <code>Review</code>s belong to a <code>User</code>, and they have some basic attributes which map to columns in our database, including a <code>published_at</code> datetime attribute, that we set when our User clicks the submit button, which saves their &ldquo;drafted&rdquo; review and turns it into a &ldquo;published&rdquo; review.</p>

<p>However, one side effect of having this attribute (and effectively, two different states or &ldquo;types&rdquo; of reviews) is that we now have no obvious form of selecting only our &ldquo;published&rdquo; reviews &mdash; that is to say, reviews that have a <code>published_at</code> date attribute set on them. How can we fix this? Well, we can write a class method that, when invoked, will run a query on our <code>ActiveRecord</code> object and only return the reviews that have this attribute. If we did that, our model might look something like this:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    belongs_to :user

    def self.published
        where('published_at IS NOT NULL')
    end
end
</code></pre>

<p>Okay, that&rsquo;s a good start. Remember that the implicit <code>self</code> in the body of this class method is our <code>Review</code> class, so we&rsquo;re basically running <code>Review.where('published_at IS NOT NULL')</code>. But now we run into another problem: this query isn&rsquo;t all that specific, is it? What makes a <code>published</code> review, exactly? Well, it&rsquo;s not just the fact that the <code>published_at</code> date should be set; we also need to account for the fact that some reviews could be set to be published in the <em>future</em>, at a later date. What we <em>really</em> want to select are our reviews that have a <code>published_at</code> date that has already happened; in other words, a date which occurred in the past. We can modify our class method to account for this:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    belongs_to :user

    def self.published
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', Time.zone.now)
    end
end
</code></pre>

<p>If we try out this class method, we can see the exact SQL that gets executed:</p>

<pre><code class="ruby">â™¥ rails c
Loading development environment (Rails 4.1.4)
irb(main):001:0&gt; Review.published
# SELECT "reviews".* FROM "reviews" WHERE "reviews".
"published_at" IS NOT NULL AND "reviews"."published_
at" &lt;= 2015-10-27 08:07:36 -0400
</code></pre>

<p>However, instead of writing this functionality into the body of a class method, we could accomplish the exact same thing by using a scope:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    belongs_to :user

    scope :published, -&gt; {
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', Time.zone.now)
    }
end
</code></pre>

<p>which allows us to invoke a method in the console that pretty much looks like the method we had before:</p>

<pre><code class="ruby">irb(main):002:0&gt; Review.published
  Review Load (2.6ms)  SELECT "reviews".* FROM 
  "reviews" WHERE "reviews".
"published_at" IS NOT NULL AND "reviews"."published_
at" &lt;= 2015-10-27 08:07:36 -0400
=&gt; #&lt;ActiveRecord::Relation []&gt;
</code></pre>

<p>Okay, wait &mdash; what&rsquo;s going on here?! How did that even happen? Well, let&rsquo;s break it down:</p>

<ol>
<li>First, we&rsquo;re using something called the <code>scope</code> method. This class method is defined within the <code>ActiveRecord::Scoping::Named</code> module.</li>
<li>Second, the <code>scope</code> class method requires two important arguments: a <strong>name</strong> for the scope, and a <strong>callable object</strong> that includes a query criteria. That last part about passing a callable object is pretty important, because only procs and lambdas are callable objects. In fact, that <code>-&gt; {}</code> syntax that we&rsquo;re using is just another way of writing a lambda in Ruby.</li>
<li>Third, and most interestingly, the return value of our scope was an <code>ActiveRecord::Relation</code> object. This is significant because <code>ActiveRecord::Relation</code> objects are <em>not</em> eagerly-loaded &mdash; they&rsquo;re <em>lazily-loaded</em>. Lazy-loading basically means that we&rsquo;re never going to query to the database until we actually <em>need</em> to. What makes this really awesome is that lazy-loading allows us to call more methods (read: scopes galore!) on our returned <code>ActiveRecord::Relation</code> object.</li>
</ol>


<p>It looks like perhaps there&rsquo;s some funky stuff going on here. But, all of these things still don&rsquo;t really answer our burning question: why use a scope when we could just write a class method?!</p>

<h2>Class methods by any other name</h2>

<iframe src="//giphy.com/embed/fwok0XCSAIivm" width="480" height="729" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>What&rsquo;s in a scope? A class method by any other name would smell just as sweet! Oops, I got carried away there. Enough poetry, let&rsquo;s talk prose. Or scopes, rather, and why we might want to use them.</p>

<p>We want to change the implementation of our <code>published</code> class method such that it accepts an argument that makes our query more flexible. Let&rsquo;s say that we want to be able to filter our <code>Review</code>s by a specific publication date. We might now have a class method that looks like this:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    belongs_to :user

    def self.published(on)
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', on)
    end
end
</code></pre>

<p>The <code>on</code> parameter would ideally be a <code>Date</code> or a <code>Datetime</code> object that would dynamically change the rows that we&rsquo;ll query for in our database. This will behave exactly like we want it to, until&hellip;it breaks. How can we break this? Well, let&rsquo;s say that we now want to order our published reviews by their <code>position</code> attribute, which for the time being, is just an integer. No problem, we can do that, right?</p>

<pre><code class="ruby">irb(main):003:0&gt; Review.published(Time.zone.now)
    .order(position: asc)
    Review Load (0.2ms)  SELECT "review".* FROM 
    "review"  WHERE (published_at IS NOT NULL AND 
    published_at &lt;= 2015-11-02 08:07:36 -0400) 
    ORDER BY "review"."position" ASC
=&gt; #&lt;ActiveRecord::Relation [#&lt;Review id: 1, published_at: 
"2015-08-02 00:04:22", position: 5&gt;, #&lt;Review id: 2, 
published_at: nil, position: 10, published_at: 
"2015-10-02 00:02:00"&gt;]&gt;
</code></pre>

<p>Sure, no problem! This returns exactly what we&rsquo;d expect. But what if we&rsquo;re relying on this method elsewhere and somehow don&rsquo;t pass in a parameter to our <code>published</code> method. What happens then?</p>

<pre><code class="ruby">irb(main):004:0&gt; Review.published(nil).order(position: asc)
=&gt; NoMethodError: undefined method `order' for nil:NilClass
</code></pre>

<p>BOOM! Everything broke. Oops. What happened here? We tried to call the <code>order</code> method on a falsy object (aka <code>nil</code>). Obviously Ruby is unhappy, because it looks like <code>Review.published(nil)</code> returns <code>nil</code>, which doesn&rsquo;t respond to a method called <code>order</code>!</p>

<p>Now, let&rsquo;s go fast forward to our new scope implementation in the Review class:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    belongs_to :user

    scope :published, -&gt; (on) {
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', on)
    }
end
</code></pre>

<p>We&rsquo;ve changed our callable object to accept a parameter, which is how we&rsquo;re going to determine our <code>published_at</code> date. We can be pretty certain that this will execute the same query if we pass an actual <em>date</em> to this scope. But what if we pass <code>nil</code> again?</p>

<pre><code class="ruby">irb(main):005:0&gt; Review.published(nil)
    .order(position: asc)
   Review Load (0.2ms)  SELECT "review".* 
   FROM "review"  WHERE (published_at IS NOT 
   NULL AND published_at &lt;= 2015-11-02 08:07:36 -0400) 
   ORDER BY "review"."position" ASC
=&gt; #&lt;ActiveRecord::Relation [#&lt;Review id: 1, published_at: 
nil, position: 1, created_at: "2015-11-02 00:45:22", 
updated_at: "2015-11-02 00:45:22"&gt;, #&lt;Review id: 2, 
published_at: nil, position: 2, created_at: 
"2015-11-02 00:46:22", updated_at: "2015-11-02 00:46:22"&gt;]&gt;
</code></pre>

<p>Well, would you look at that! It didn&rsquo;t break! It ran our expected query, but because scopes return <code>ActiveRecord::Relation</code> objects, it didn&rsquo;t call <code>order</code> on <code>nil</code>, it just kept chaining on to our query. The first part of our query (responsible for finding any reviews that were published on a date) didn&rsquo;t return anything, but the second part of our query (responsible for just ordering whatever got returned by our first query) did work! How, exactly? Well, <a href="http://aspiringwebdev.com/use-activerecord-scopes-not-class-methods-in-rails-to-avoid-errors/">it just so happens</a> that calling a method on a blank <code>ActiveRecord::Relation</code> object returns that same relation. An important thing to note: if we had a query that was scoping down our reviews to ones that were published on a date and ordering <em>those</em> objects by their position, we would have gotten an empty relation:</p>

<pre><code class="sql">SELECT "review".* FROM "review"  WHERE 
(published_at IS NOT NULL AND published_at 
&lt;= 2015-11-02 08:07:36 -0400 AND 
(ORDER BY "review"."position" ASC))
</code></pre>

<p>The above query narrows down our scope quite a bit, which we could do if we wanted to specify that to SQL. But in our case, our <code>ORDER BY</code> clause isn&rsquo;t grouped inside of the <code>AND</code>, but instead exists outside of it, which is why we&rsquo;re not getting an empty relation returned to us.</p>

<p>While we&rsquo;re on the topic of relations, it&rsquo;s also important to note that the method we have right now <em>does not</em> return an object to us! Relations are not objects! We&rsquo;d need to explicitly query for a record if we wanted to return it:</p>

<pre><code class="ruby">irb(main):006:0&gt; Review.published(nil)
    .order(position: asc).first
=&gt; #&lt;Review id: 1, published_at: nil, position: 1, 
created_at: "2015-11-02 00:45:22", 
updated_at: "2015-11-02 00:45:22"&gt;
</code></pre>

<p>Hopefully we should now be able to easily see that the <code>order</code> method that we&rsquo;re chaining on right there at the end could really be abstracted into its own scope! Let&rsquo;s fix that, shall we?</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    belongs_to :user

    scope :published, -&gt; (on) {
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', on)
    }

    scope :ordered, -&gt; { order(position: :asc) } 
end
</code></pre>

<p>Much better. Now we can just chain on our <code>order</code> scope to our <code>published</code> scope without ever having to worry that our scopes will break. But wait, there&rsquo;s even more we can do with scopes!</p>

<h2>Special scope tricks</h2>

<p>Because scopes accept lambdas and procs, we can pass in different arguments. We did that before when we passed in a datetime parameter. But this kind of flexibility can be especially powerful, because we can do things like pass in limits:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    scope :published, -&gt; (limit: 20) {
        where('published_at IS NOT NULL AND 
        published_at &lt;= ?', Time.zone.now)
    }
end
</code></pre>

<p>This will run our same SQL query, but will add <code>LIMIT 10</code> to the end of it. We can customize this scope further, or we can add more if we need to. We also might want to just perpetually apply a scope to all queries on a specific model. When we run into this situation, we can use the <code>default_scope</code> method.</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
    default_scope -&gt; { order(published_at: :desc) }
end
</code></pre>

<p>This will automatically append all of our SQL queries on this model with <code>ORDER BY "review"."position" DESC</code>. What&rsquo;s really nice about having a default scope is that we don&rsquo;t need to write and perpetually call a method named something like <code>by_published_date</code> on this model; it will be applied and invoked by default on all instances of this class.</p>

<p>According to <a href="http://guides.rubyonrails.org/active_record_querying.html#scopes">the documentation</a>, if we want to get <em>super</em> fancy with our default scope and have so much logic that it&rsquo;s bursting from our callable object&rsquo;s so-called seams, we can also define it in an alternate way as a class method:</p>

<pre><code class="ruby">class Review &lt; ActiveRecord::Base
  def self.default_scope
    # Get fancy in here, but just make sure 
    # to return an ActiveRecord::Relation.
    # Otherwise, any scopes we chain onto 
    # this will automatically break!
  end
end
</code></pre>

<p>We&rsquo;re also not limited to just using the <code>where</code> method! We can use plenty of other <code>ActiveRecord::Relation</code> methods, such as <code>joins</code> or <code>includes</code>, which will eager load other relations when we want to. Here&rsquo;s a handy scope we could add to our <code>Shipment</code> model that <a href="http://vaidehijoshi.github.io/blog/2015/10/27/digging-into-the-finder-object-pattern/">we built out</a> last week:</p>

<pre><code class="ruby">class Shipment &lt; ActiveRecord::Base
    default_scope -&gt; { includes(:order, :line_items) }
end
</code></pre>

<p>This is pretty cool because we&rsquo;re using our <code>default_scope</code> method to automatically eager-load our associated <code>order</code> and <code>line_items</code> on our <code>shipment</code> without having to make two additional queries just to load them! As is the case with <code>includes</code>, it might not always be a good idea to do this, since we could be loading more records than we want, or could get stuck with a n+1 situation on our hands. But if we know what we&rsquo;re doing and are sure that this scope is necessary, it can be pretty powerful.</p>

<p>We can also merge two scopes together, which effectively allows us to mix and match different <code>WHERE</code> conditions and group them together in SQL with an <code>AND</code>:</p>

<pre><code class="ruby">class Shipment &lt; ActiveRecord::Base
    scope :shipped -&gt; { where(state: 'shipped') }
    scope :damaged -&gt; { where(condition: 'damaged') }
end
</code></pre>

<p>which we can then merge into a single SQL query by chaining our scopes together:</p>

<pre><code class="ruby">irb(main):007:0&gt; Shipment.shipped.received
=&gt; SELECT "shipments".* FROM "shipments" WHERE 
"shipments"."state" = 'shipped' AND "shipments".
"condition" = 'damaged'
</code></pre>

<p>We&rsquo;ll notice that in this situation, our <code>WHERE</code> clauses are grouped together with an <code>AND</code>, which can help us when it comes to writing super specific queries.</p>

<iframe src="//giphy.com/embed/OIIB1hkbwFs76" width="480" height="339" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>ActiveRecord scopes give us a lot of flexibility, even though they are effectively defining a class method on a model. The fundamental difference between them however, is that scopes should always return an <code>ActiveRecord::Relation</code> object, which makes them forever chainable!</li>
<li>How does the <code>scope</code> method actually work? I&rsquo;m not sure that I understand all of it, but perhaps you will! Check it out in the <a href="https://github.com/rails/rails/blob/428d47adfed8d6aa7b21aec2bf5ad890961c9de3/activerecord/lib/active_record/scoping/named.rb#L143">Rails source code</a>!</li>
<li>There are a few great primers on writing effective scopes, like <a href="http://www.informit.com/articles/article.aspx?p=2220311">this one</a>, and this <a href="http://blog.plataformatec.com.br/2013/02/active-record-scopes-vs-class-methods/">other one</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Digging Into the Finder Object Pattern]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/10/27/digging-into-the-finder-object-pattern/"/>
    <updated>2015-10-27T08:58:31-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/10/27/digging-into-the-finder-object-pattern</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/y5A0PlFbGIk4o" width="480" height="280" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Most developers aren&rsquo;t ever <em>completely</em> happy with their code. I&rsquo;m no exception to this stereotype &mdash; I almost always know that I could probably write a cleaner, more concise method, controller, or class. Usually, it&rsquo;s a matter of not know the best tool to reach for to refactor my code; eventually, I learn a new pattern or form of encapuslating logic that I later use to make my old code a lot better.</p>

<p>But a few weeks ago, I wrote 100 lines of beautiful code. I&rsquo;m talking about a goregous, straightforward, no-nonsense class that did a lot in a relatively few lines of Ruby. I still feel pretty proud of it (can you tell?), and part of the reason for this is because I also learned a new pattern while writing this class. I was actually pairing with another developer, and we wanted to try using a rather common Rails pattern to solve a problem we were running into again and again: messy queries in our controllers and models.</p>

<p>We both were familiar with the concept of &ldquo;skinny controllers&rdquo; and &ldquo;fat models&rdquo;, or the idea that your controllers shouldn&rsquo;t be responsible for containing the logic specific to a model. However, we also didn&rsquo;t want our models to get out of control in size, which is exactly what was starting to happen. So, we searched for a workaround, and found our answer in one of the most elegant patterns I&rsquo;ve seen in awhile: <strong>finder objects</strong>. Finder objects are simple Ruby classes that encapuslate the logic behind querying the database, and they are hands down, my new favorite kind of Ruby object.</p>

<!--more-->


<h2>Scopin&#8217; Down The Problem of Scopes</h2>

<iframe src="//giphy.com/embed/Y6eQqv3jdV4RO" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>In our bookstore application, we have <code>Order</code> objects, which represent the orders that a user places in our system. However, these are books that we&rsquo;re dealing with, and eventually we need to address the whole fulfillment process, which will need to be represented by a whole other set of models. For now, we&rsquo;ll try to keep it as simple as possible. Let&rsquo;s say that an <code>Order</code> has many <code>Shipments</code>, and each shipment represents a batch of <code>Book</code> objects (read: products) that need to be shipped out together.</p>

<p>Right off the bat, we know that our <code>Shipment</code> model will have some kind of state machine that will need to track the different stages of the shipment phase. Again, to keep it simple, let&rsquo;s say that there are five different stages or <code>state</code>s of a shipment:</p>

<ol>
<li>A shipment starts off as <code>processing</code> once an order has been placed.</li>
<li>Once it has been processed, it needs a label with the shipping address information, so it transitions to the <code>needs_label</code> state.</li>
<li>After it has a label generated, it&rsquo;ll need a tracking number, so transitions to the <code>needs_tracking</code> state.</li>
<li>Once it has a tracking number, it transitions to being <code>ready</code> for shipment.</li>
<li>Finally, when the shipment is actually sent out of the warehouse and to our shipping service, it should be marked as <code>shipped</code>.</li>
</ol>


<p>To be clear, this is a <em>super</em> simplified version of what would happen in a real-life application! Now, in our admin panel, let&rsquo;s say that we have a page that will render all of our shipments, which should always ordered by when they were created, so that our admins know which shipments to process, and in which order.</p>

<p>We can take it a step further and say that our main admin panel page &mdash; which will correspond to the <code>index</code> action in our controller, should show our admins the most urgent shipments that need their attention as soon as they log in; in other words, these would be the shipments that were created more than a week ago, but still haven&rsquo;t been processed.</p>

<p>I think we can all agree that basic Rails best practices should steer us away from doing something like this:</p>

<pre><code class="ruby">class ShipmentsController &lt; ApplicationController
  def index
    @shipments = Shipment.where(state: :ready)
            .where('created_at &lt;= ?', Time.zone.now + 7.days)
               .order(created_at: :desc)
  end
end
</code></pre>

<p>We <em>definitely</em> know that the controller really shouldn&rsquo;t be responsible for querying for the correct <code>Shipment</code> objects. All our controller should have to do is just render the correct ones, and not go digging for them in the database!</p>

<p>Okay, so we&rsquo;ll create some scopes for these queries instead. These scopes should live in our model, not in the controller, right? Let&rsquo;s see what our model might look like if we take that approach:</p>

<pre><code class="ruby">class Shipment &lt; ActiveRecord::Base
    belongs_to :order

    default_scope -&gt; { order(created_at: :desc) }
    scope :shipped, -&gt; { where(state: 'shipped') }
    scope :urgent, -&gt; {
        where('created_at &lt;= ?', Time.zone.now + 7.days)
    }
end
</code></pre>

<p>This cleans things up a decent bit! Scopes are actually part of the Active Record Query Interface, and they allow us to specify commonly-used queries which we can then actually reference and use in the form of method calls on our models themselves. They are really nothing more than defining class methods on a model:</p>

<pre><code class="ruby">class Shipment &lt; ActiveRecord::Base
    def self.shipped
        where(state: 'shipped')
    end
end
</code></pre>

<p>However, they&rsquo;re pretty wonderful because you can just chain them as method calls (<code>Shipment.urgent.shipped</code>), but all they do is execute the correct query for you:</p>

<pre><code class="ruby">Shipment.shipped
=&gt; SELECT "shipments".* FROM "shipments" WHERE "shipments"."state" = "shipped"
</code></pre>

<p>But the good news about scopes is also the bad <a href="news:">news:</a> you can just keep adding them and adding them, and chaining them onto everything. Our <code>Shipment</code> class has only three scopes at the moment, one of them being the <code>default</code> scope. But, we&rsquo;ll probably have a page that should only render only the shipments that are in the <code>needs_label</code> state, or a page that maps to a controller action which should only return shipments that are in the <code>needs_tracking</code> state. We <em>could</em> keep adding scopes and then have our controller actions call the scopes on the class to return the appropriate shipments from our database.</p>

<p>Or, we could try something a little different.</p>

<h2>Finder Objects</h2>

<iframe src="//giphy.com/embed/12bpEjD05ac2IM" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Our scopes don&rsquo;t actually add any new behavior to our model. As we saw earlier, they are nothing more than macros for querying for the correct rows from our <code>shipments</code> table in our database. So, it really doesn&rsquo;t make sense for our model to contain all this logic that doesn&rsquo;t <em>add</em> any new behavior to it.</p>

<p>It would be nice, however, if we could apply the rule of &ldquo;separation of concerns&rdquo; here, and have an entire class whose sole responsibility would be to dig up the correct objects based on the parameters we were querying by. Really, this class should do nothing more than <em>find the right objects</em>. You might even say that instances of this class are just&hellip;<em>finder objects</em>! (Get it? Man, I really hope you got it.)</p>

<p>Anyways, how might this class look? Well, we don&rsquo;t need any of the functionality from ActiveRecord, so we can create it as just a Plain Old Ruby Class:</p>

<pre><code class="ruby">class ShipmentFinder
end
</code></pre>

<p>Next, we&rsquo;ll want to tell our finder object which models to query for, so it will know how to construct our queries, and which table to query. Since we never really want to have this method accessible elsewhere, we can make it a private class method that will only be called from the context of another <code>ShipmentFinder</code> class method:</p>

<pre><code class="ruby">class ShipmentFinder
    class &lt;&lt; self
        private
        def resource_class
            ::Shipment
        end
    end
end
</code></pre>

<p>Now, we can use Rails&#8217; <a href="https://github.com/rails/arel">arel DSL</a> to construct a basic query. To do this, we&rsquo;ll need a method that returns the table, which can also be a private method since we&rsquo;ll never want to call it explicitly:</p>

<pre><code class="ruby">class ShipmentFinder
    class &lt;&lt; self
      private

      def table
        resource_class.arel_table
      end

      def resource_class
        ::Shipment
      end
    end
end
</code></pre>

<p>Now, we can write as many specific queries as we want. For example, we could write a <code>urgent_needs_tracking</code> class method that could constructs a query using two private methods, <code>needs_tracking</code> and <code>is_ready</code>:</p>

<pre><code class="ruby">class ShipmentFinder
    class &lt;&lt; self
      def urgent_needs_tracking
        query = needs_tracking.and(is_ready)

        resource_class.where(query)
      end

      def shipped
        resource_class.where(state: 'shipped')
      end

      private

      def urgent
        resource_class.where('created_at &lt;= ?', Time.zone.now + 7.days))
      end

      def is_ready
        table[:state].eq('ready')
      end

      def needs_tracking
        table[:state].eq('needs_tracking')
      end

      def needs_label
        table[:state].eq('needs_label')
      end

      def table
        resource_class.arel_table
      end

      def resource_class
        ::Shipment
      end
    end
end
</code></pre>

<p>Now we can rely on our <code>ShipmentFinder</code> class to find our shipments that have been created more than 7 days ago, and still don&rsquo;t have a tracking number. We also can add more functionality that can be used in specific instances, which is exactly what we&rsquo;ve done with our <code>needs_label</code> and <code>is_ready</code> private methods. We can use arel to construct queries using those methods to scope down what objects are actually returned. We don&rsquo;t have to do anything fancy, if we don&rsquo;t want to. Take a look at that <code>shipped</code> method &mdash; this is just using a simple <code>where</code> arel method to construct a query that reads like this: <code>SELECT "shipments".* FROM "shipments" WHERE "shipments"."state" = "shipped"</code>.</p>

<p>Finally, the last step: it&rsquo;s time for us to actually call on our finder object to do its job!</p>

<h2>Cleaner Querying, Cleaner Controllers</h2>

<p>Let&rsquo;s bring it all together by going back to our <code>ShipmentsController</code> and add our new finder object into it. Our <code>index</code> action should now be able to account for different types of shipments that our admins might want to query for. For now, we&rsquo;ll construct our controller to accept a query parameter in our params hash that will be that <code>status</code> of the types of shipments we want to return. Depending on the frontend framework we&rsquo;re using, this might be a dropdown or checkbox option that will set a value on the <code>status</code> key in our params hash.</p>

<p>Our controller action could now be rewritten to look something like this:</p>

<pre><code class="ruby">class ShipmentsController &lt; ApplicationController
  def index
    status = params[:status]
    status_method = status.to_sym

    if ShipmentFinder.respond_to?(status_method)
            @shipments = ShipmentFinder.send(status_method)
        else
            @shipments = Shipment.all
        end
  end
end
</code></pre>

<p>Here, we&rsquo;re accessing the query param from <code>params[:status]</code>, and turning it into a symbol (<code>status_method</code>). Next, we&rsquo;re using Ruby&rsquo;s super handy <code>respond_to?</code> method, and sending our <code>status_method</code> symbol to our <code>ShipmentFinder</code>. So, if our admin selects an option that sends the query param <code>urgent_needs_tracking</code>, we are telling our finder object to call that method, and execute that query. The return value of the query executed by our <code>ShipmentFinder</code>&rsquo;s <code>urgent_needs_tracking</code> method is what will be set as the instance variable <code>@shipments</code> for the duration of this action on the controller.</p>

<p>If no query param is set, or if our <code>ShipmentFinder</code> doesn&rsquo;t have a method that maps to a query param, we&rsquo;re just returning all of our <code>Shipment</code> objects by default.</p>

<p>This is quite an improvement from our earlier code, which had our controller digging for rows in a database that it really didn&rsquo;t have anything to do with. Now, we&rsquo;ve separated our concerns into a new finder object, which exists as its own query interface on its own. It&rsquo;s also worth noting that sometimes, creating a finder object can be overkill, and sometimes, if we have a lot of finder objects, we&rsquo;d probably want to abstract a lot of this functionality out into a <code>BaseFinder</code> class, which our finder objects could inherit from. But this is definitely a great start. No more digging for us!</p>

<iframe src="//giphy.com/embed/FqEDV3gjMhqRG" width="480" height="267" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The finder object pattern helps keep your model logic strictly related to a class&#8217; behavior, while also keeping your controller&rsquo;s skinny. Since they are nothing more than plain old Ruby classes, finder objects don&rsquo;t need to inherit from <code>ActiveRecord::Base</code>, and should be responsible for nothing more than executing queries. Read more about them on this <a href="http://twin.github.io/finder-objects/">fantastic blog post</a>.</li>
<li>Scopes are a great tool to use if a finder object seems like more work than it&rsquo;s really worth, given the size and context of your application. Read more about scopes in the Rails <a href="http://guides.rubyonrails.org/active_record_querying.html#scopes">documentation</a>.</li>
<li>Want to see more examples of implementing finder objects? Check out this <a href="https://speakerdeck.com/weppos/maintaining-a-5yo-ruby-project-shark-edition?slide=103">slidedeck</a> series.</li>
</ul>

]]></content>
  </entry>
  
</feed>
