<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-05-20T22:11:42-04:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Secret Life of Your Database, Part 1: Migrations]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/05/19/the-secret-life-of-your-database-part-1-migrations/"/>
    <updated>2015-05-19T08:51:11-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/05/19/the-secret-life-of-your-database-part-1-migrations</id>
    <content type="html"><![CDATA[<p><img src="http://31.media.tumblr.com/tumblr_mcsccsfcnn1qz9l5so1_1280.gif" style="display: block; margin-left: auto; margin-right: auto;"></p>

<p>As young developers, we often get caught up in what we don&rsquo;t know. One of the first and hardest lessons to learn when you&rsquo;re starting out as a programmer is the sheer volume of things that you don&rsquo;t know. You have to get comfortable not knowing them, and you have to work towards learning as much about them as you can.</p>

<p>However, sometimes we focus so much on learning new things, that we forget to come back to what we already know &ndash; or at least, what we <em>think</em> we already know. In fact, this is exactly what I&rsquo;ve been guilty of for the past few weeks. I&rsquo;ve been focusing so much on learning new frameworks and getting comfortable with other languages, that I forgot to question my knowledge of Rails. Since it was a known domain and language, I assumed that I didn&rsquo;t need to revisit it that often.</p>

<p>But boy, was I wrong. Just because you&rsquo;re familiar with something doesn&rsquo;t mean that you understand it completely. The trick to dealing with this is to make yourself feel uncomfortable in your otherwise familiar language. And that&rsquo;s exactly what happened to me. Last week, while writing some lines of SQL (yes, really), I ran across a database migration that used an <code>up</code> and a <code>down</code> method. I saw those lines of code and realized something: I had no idea how my database really works. In fact, I&rsquo;ve written so many migrations in so many Rails applications that, at some point, I&rsquo;ve stopped thinking about what was actually going on under the hood. So, I set out to make myself uncomfortable and uncover the secret life of my database.</p>

<!--more-->


<h2>Teach Me How To Migrate</h2>

<p>Most of us were introduced to Rails databases through migrations. Migrations are how we alter our database schema over time. They implement a Ruby DSL (domain-specific language), and run SQL queries in our database for us. And, they are super easy to learn to use and understand:</p>

<pre><code class="ruby">rails generate migration CreateBooks
</code></pre>

<p>Running a command like the one above prompts Active Record to create a unique, timestamped file within our <code>/db</code> directory, with a migration class that might look something like this:</p>

<pre><code class="ruby">class CreateBooks &lt; ActiveRecord::Migration
  def change
    create_table :books do |t|
      t.string :title
      t.integer :year

      t.timestamps null: false
    end
  end
end
</code></pre>

<p>Nothing <em>too</em> surprising here; we&rsquo;ve seen this kind of <code>change</code> method before. But what you may <em>not</em> have seen &ndash; or at least, understood &ndash; is something that looks like this:</p>

<pre><code class="ruby">class CreateBooks &lt; ActiveRecord::Migration
  def up
    create_table :books do |t|
      t.string :title
      t.integer :year
    end
  end

  def down
    drop_table :books
  end
end
</code></pre>

<p>So, what does that <code>up</code> and <code>down</code> <em>actually</em> mean? What is going up, exactly&hellip;and what&rsquo;s going down? And how is this different from using the <code>change</code> method, which probably seems way simpler right about now? Well, it&rsquo;s time for us to find out.</p>

<h2>All The Migrations Fit To Run</h2>

<p>The first step to understanding how something works is by unpacking it, step by step. And that&rsquo;s what we&rsquo;ll do with our migrations. Let&rsquo;s first look at how many migrations we currently have.</p>

<p>We&rsquo;ve already generated a few migrations using the <code>rails generate migration</code> commands for our in-progress bookstore application. We can take a look at what all those migrations look like by running the <code>rake db:migrate:status</code> command, which will show us the status of our migrations, including any pending ones we may have:</p>

<pre><code class="ruby">❤ rake db:migrate:status

database: bookstore_development

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20140217160517  Create users
   up     20150424175043  Create books
   up     20150429145355  Add media columns to books
   up     20150430140850  Add author to books
   up     20150430160704  Add genre to books
   up     20150430192426  Create reading lists
   down   20150430191950  Add user id to reading lists
</code></pre>

<p>Whoa &ndash; look at all those migrations! And more importantly, look at the column to the left of the migrations: seem familiar? Each one of our migrations has a <code>status</code>, which is either <code>up</code> or <code>down</code>. Let&rsquo;s remember this, we&rsquo;re going to come back to it in a second.</p>

<p>According to the Rails <a href="https://github.com/rails/rails/blob/f47b4236e089b07cb683ee9b7ff8b06111a0ec10/activerecord/lib/active_record/railties/databases.rake#L91">source code</a>, the <code>rake:db:migrate:status</code> rake task displays the status of all our migrations. This can be helpful in determining if we have any migrations we need to run. And it looks like we do! Let&rsquo;s run <code>rake db:migrate</code> and then check the status of our migrations again with <code>rake db:migrate:status</code>:</p>

<pre><code class="ruby">❤ rake db:migrate:status

database: bookstore_development

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20140217160517  Create users
   up     20150424175043  Create books
   up     20150429145355  Add media columns to books
   up     20150430140850  Add author to books
   up     20150430160704  Add genre to books
   up     20150430192426  Create reading lists
   up     20150430191950  Add user id to reading lists
</code></pre>

<p>Hm, interesting. That last migration, which adds a <code>user_id</code> column to our <code>reading_lists</code> table, now has a status of <code>up</code>. We&rsquo;ve basically migrated our database up, meaning that we have no pending migrations and all of our migrations are up to date.</p>

<p>But what if we wanted to rollback our migration, instead? Or, better yet, what if we wanted to rollback the last two migrations? Could we go back in time? Back to when we didn&rsquo;t even have a <code>reading_lists</code> table in our database? How would we do that?</p>

<p>Well, we could run a command like <code>rake db:rollback STEP=</code>, which rolls back our database however many steps we specify. For this example, we&rsquo;ll just rollback to two migrations ago (<code>rake db:rollback STEP=2</code>). What is the state of our database now? Let&rsquo;s check the <code>migrate:status</code> again:</p>

<pre><code class="ruby">❤ rake db:migrate:status

database: bookstore_development

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20140217160517  Create users
   up     20150424175043  Create books
   up     20150429145355  Add media columns to books
   up     20150430140850  Add author to books
   up     20150430160704  Add genre to books
   down   20150430192426  Create reading lists
   down   20150430191950  Add user id to reading lists
</code></pre>

<p>Nice! We&rsquo;ve migrated our database down, back to two migrations ago. There&rsquo;s some serious <em>Back To The Future</em> stuff going down right now.</p>

<iframe src="//giphy.com/embed/uYfz9FKd0EGpG" width="480" height="255" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<h2>What Your Database Won&rsquo;t Tell You (Unless You Ask)</h2>

<p>Okay, so we can migrate up and down a database. Cool. We can go back and forth in time, to older versions of our database and to newer &ndash; and even the newest! &ndash; version of our database. Double cool. But what about what we <em>originally</em> set out to figure out? What do the <code>up</code> and <code>down</code> methods do in our migrations? And why do we only see them <em>some</em> of the time?</p>

<p>If you had an inkling that the <code>up</code> and <code>down</code> methods were somehow interlinked with the migration <code>status</code> column we saw when we ran <code>rake db:migrate:status</code>&hellip;well, your inkling was right on the money. They <em>are</em> connected, and in a really cool way.</p>

<p>The <code>up</code> and <code>down</code> methods are defined on a <code>Migration</code> class, which inherits from the <code>ActiveRecord::Migration</code> class. Active Record literally puts the M (model) in MVC, since it&rsquo;s what handles all of our database records. And Active Record is pretty darn smart. Depending on which rake task we provide it, Active Record will execute either an <code>up</code> method in a migration file, or a <code>down</code> method.</p>

<p>The Rails Guides <a href="http://edgeguides.rubyonrails.org/active_record_migrations.html">explain this</a> pretty well:</p>

<blockquote><p>&ldquo;The up method should describe the transformation you&rsquo;d like to make to your schema, and the down method of your migration should revert the transformations done by the up method. In other words, the database schema should be unchanged if you do an up followed by a down. For example, if you create a table in the up method, you should drop it in the down method. It is wise to perform the transformations in precisely the reverse order they were made in the up method.&rdquo;&#8221;</p></blockquote>

<p>As you might have guessed, these two methods are inverse of each other in both form and function. The <code>up</code> method is called when migrating &ldquo;up&rdquo; the database &ndash; <em>forward</em> in time &ndash; while the <code>down</code> method is called when migrating &ldquo;down&rdquo; the database &ndash; or, <em>back</em> in time. In other words, <strong>the <code>up</code> method is a set of directions for running a migration, while the <code>down</code> method is a set of instructions for reverting a migration</strong>. This implies that the code in these two methods should fundamentally do the opposite things of one another.</p>

<p>This also means is that only <em>one</em> of these methods can ever actually run during a migration. If we run <code>rake db:migrate</code>, all of the <code>up</code> methods will execute, and every migration that is currently set to <code>down</code> will change to a status of <code>up</code>:</p>

<pre><code class="ruby">❤ rake db:migrate:status

database: bookstore_development

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20140217160517  Create users
   up     20150424175043  Create books
   down   20150429145355  Add media columns to books
   down   20150430140850  Add author to books
   down   20150430160704  Add genre to books
   down   20150430192426  Create reading lists
   down   20150430191950  Add user id to reading lists

❤ rake db:migrate
❤ rake db:migrate:status

database: bookstore_development

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20140217160517  Create users
   up     20150424175043  Create books
   up     20150429145355  Add media columns to books
   up     20150430140850  Add author to books
   up     20150430160704  Add genre to books
   up     20150430192426  Create reading lists
   up     20150430191950  Add user id to reading lists
</code></pre>

<p>And if we run <code>rake db:rollback</code>, the most <em>recent</em> migration that was run (and had its status set to <code>up</code>) will be reverted by calling the <code>down</code> method in the migration file. If we run <code>rake db:rollback STEP=</code>, the <code>down</code> method will be invoked in every migration file we specify we want to rollback (or how many steps back we want to go in the database&rsquo;s history):</p>

<pre><code class="ruby">❤ rake db:migrate:status

database: bookstore_development

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20140217160517  Create users
   up     20150424175043  Create books
   up     20150429145355  Add media columns to books
   up     20150430140850  Add author to books
   up     20150430160704  Add genre to books
   up     20150430192426  Create reading lists
   up     20150430191950  Add user id to reading lists

❤ rake db:rollback STEP=3
❤ rake db:migrate:status

database: bookstore_development

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20140217160517  Create users
   up     20150424175043  Create books
   up     20150429145355  Add media columns to books
   up     20150430140850  Add author to books
   down   20150430160704  Add genre to books
   down   20150430192426  Create reading lists
   down   20150430191950  Add user id to reading lists
</code></pre>

<p>And, we could <em>even</em> run or revert a specific migration by giving ActiveRecord the version number/migration id of the migration:</p>

<pre><code class="ruby">❤ rake db:migrate:down VERSION=20150429145355
❤ rake db:migrate:status

database: bookstore_development

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20140217160517  Create users
   up     20150424175043  Create books
   down   20150429145355  Add media columns to books
   up     20150430140850  Add author to books
   up     20150430160704  Add genre to books
   up     20150430192426  Create reading lists
   up     20150430191950  Add user id to reading lists
</code></pre>

<p>In the example above, when we ran a <code>migrate:down</code> task, all that was happening is that only the <code>down</code> method written in the &ldquo;AddMediaColumnsToBooks&rdquo; migration file was was invoked!</p>

<iframe src="//giphy.com/embed/i2gzQAinKY3hS" width="480" height="264" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>Neat, right!? Or maybe just kind of mind-blowing if you&rsquo;ve never seen this before. Who knew that this is what migrations were really all about? Well, now you and I both know, so that&rsquo;s pretty rad.</p>

<h2>Why Change When You Can Go Up And Down?</h2>

<p>The <code>change</code> method is pretty standard when it comes to migrations partly because it&rsquo;s a newer addition to Rails. Just like <code>up</code> and <code>down</code>, the <code>change</code> method is defined on the <code>ActiveRecord::Migration</code> class. In fact, it does exactly what <code>up</code> and <code>down</code> accomplish together. The <code>change</code> method is <em>usually</em> able to automatically figure out the inverse operation you provide it; for example, if you call <code>create_table</code> inside of the <code>change</code> method, when you run <code>rake db:rollback</code>, it will <code>drop_table</code>. The same goes for <code>add_column</code> and <code>remove_column</code>.</p>

<p>So, if the <code>change</code> method can do all of these things in one go (rather than in two methods), why do we sometimes see an <code>up</code> and <code>down</code> method defined together in a migration file?</p>

<p>Well, there are many times when we might want Active Record to be smart and figure out when to drop a column or table. But other times, it might not be as clear.</p>

<p>For example, what if we wanted a migration that just created or fixed data? We wouldn&rsquo;t want ActiveRecord to try to figure out whether to add or remove a column&hellip;or worse, drop our table! Or what if we wanted to remove columns when we migrated up, and <em>add</em> columns when we migrated down? We&rsquo;d have to specify that explicitly in our <code>up</code> and <code>down</code> methods.</p>

<p>We could even get fancy with some SQL and do something a bit more granular like rename a table:</p>

<pre><code class="ruby">class RenameReadingListsToWishLists &lt; ActiveRecord::Migration
  def up
    execute &lt;&lt;-SQL
      ALTER TABLE reading_lists
        RENAME TO wish_lists;
    SQL
  end

  def down
    execute &lt;&lt;-SQL
      ALTER TABLE wish_lists
        RENAME TO reading_lists;
    SQL
  end
end
</code></pre>

<p>In this example, we&rsquo;re using the <code>execute</code> method, which takes either a string value of a SQL query, or a heredoc like the one we&rsquo;ve written above.</p>

<p>And we might even want to make it completely impossible for someone to ever revert a migration. We could specify that kind of behavior in our <code>down</code> method by raising an ActiveRecord error:</p>

<pre><code class="ruby">def down
  raise ActiveRecord::IrreversibleMigration
end
</code></pre>

<p>Depending on which migration file this <code>down</code> method lived in, that migration could never be &ldquo;migrated down&rdquo;. This can sometimes be dangerous, but also useful &ndash; particularly if we had many other data models that were depending on those tables existing in the first place!</p>

<p>It turns out that our database is a pretty powerful thing. Rails provides us with a lot of functionality and flexibility of moulding it to be exactly the way that we want it to be. It&rsquo;s just up to us to take advantage of it in the right situations! The more we learn about shaping our database, the better equipped we&rsquo;ll be to creating effective, concise, and streamlined databases for each and every one of our applications.</p>

<p>But the truth is, we&rsquo;ve only scratched the surface of databases today. Tune in again next week, when I&rsquo;ll uncover the secret life of all your&hellip;JOIN TABLES! Try and contain your enthusiasm, my friends.</p>

<iframe src="//giphy.com/embed/2yAjmbCfYcQUw" width="480" height="293" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>up</code> and <code>down</code> methods are a more granular way of defining the <code>change</code> method in a Rails migration. The <code>up</code> method is a set of instructions of what to do when you migrate, and the <code>down</code> method is a set of directions of what to do when you rollback.</li>
<li>Want to see more examples of when you might want to use the <code>up</code> and <code>down</code> methods in place of the <code>change</code> method? Check out the Rails Guides on <a href="http://api.rubyonrails.org/classes/ActiveRecord/Migration.html">Active Record Migrations</a>.</li>
<li>Need to read more on running migrations? <a href="http://guides.rubyonrails.org/v2.3.11/migrations.html#running-migrations">Read this</a>. Gotta brush up on migrations after reading this post? Head over <a href="http://edgeguides.rubyonrails.org/active_record_migrations.html">here</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tackling Those Tests, Part 3: Testing Made Easy With Gems]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/04/28/tackling-those-tests-part-3-testing-made-easy-with-gems/"/>
    <updated>2015-04-28T08:50:59-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/04/28/tackling-those-tests-part-3-testing-made-easy-with-gems</id>
    <content type="html"><![CDATA[<p><img src="https://imgs.xkcd.com/comics/shouldnt_be_hard.png" style="display: block; margin-left: auto; margin-right: auto;"></p>

<p><em>This blog post is part of a series on testing. Read Part 2 <a href="http://vaidehijoshi.github.io/blog/2015/04/21/tackling-those-tests-part-2-getting-fun-and-functional-with-factorygirl/">here</a>.</em></p>

<p>If there&rsquo;s anything that I&rsquo;ve learned about testing while writing this three-part blog post series, it&rsquo;s this: testing is freaking hard! It&rsquo;s tough to figure out the correct syntax and conventions, particularly when you&rsquo;re just starting out. Figuring out when to write a test is also a tricky business. And then sitting down to actually write the test is pretty difficult, too.</p>

<p>But there are ways to make it easier on yourself. And I should know, because I tried to write my tests the hard way, and I definitely do not recommend it. Here&rsquo;s what I <em>do</em> recommend: GEMS! And lots of &lsquo;em. There are a lot of Ruby gems out there, specifically designed to make your testing life easier.</p>

<p>So, to close off this epic series on testing in Rails, I&rsquo;m going to share my two favorite testing gems: <code>shoulda-matchers</code> and <code>database_cleaner</code>. Once you know how to implement them, your testing life will forever be easier. Because, let&rsquo;s be real &ndash; isn&rsquo;t that the way testing <em>should</em> be?</p>

<!--more-->


<h2>You Shoulda Used Shoulda</h2>

<p>Last week, we wrote some tests for a <code>ReadingList</code> object, which we tested using factories. To refresh your memory, every <code>ReadingList</code> has a <code>title</code> attribute, which is just a <code>string</code> value. An important test for this object is a <code>title</code> validation. But what would that look like? Probably something like this:</p>

<pre><code class="ruby">require 'rails_helper'

describe ReadingList do
  context 'has a title' do

    let(:real_list) { create(:reading_list, title: "my list") }

    it 'has a title' do
      expect(reading_list.title).to eq("Books I Want To Read")
    end
  end

  context 'doesn't have a title' do
    let(:fake_list) { create(:reading_list) }

    it 'raises an error' do
      expect(fake_list.save!)to raise_error
    end
  end
end
</code></pre>

<p>Man, that&rsquo;s a lot of work for a single line of Rails code, isn&rsquo;t it? Wait a second &ndash; what if we could shorten this huge test into one line of code? Is is possible? Of course it is! And it&rsquo;s easy too, because the <code>shoulda</code> gem does just that.</p>

<p>To actually use the gem, you just need to add it to the <code>test</code> group within your <code>Gemfile</code>:</p>

<pre><code class="ruby">group :test do
  gem 'rspec-rails'
  gem 'shoulda-matchers'
end
</code></pre>

<p>You also need to add <code>require 'shoulda/matchers'</code> to your <code>rails_helper.rb</code> file. Now we can rewrite our validation test as a single line:</p>

<pre><code class="ruby">require 'rails_helper'

describe ReadingList do
  it { should validate_presence_of(:title) } 
end
</code></pre>

<p>Pretty awesome, right? We can do this for all of our validations now! But wait &ndash; there&rsquo;s more! The <code>shoulda</code> gem takes care of more than just validations. It can also test for associations in ActiveRecord and actions in our controllers! You can even write super specific validations scoped to a particular attribute or object, like this:</p>

<pre><code class="ruby">it { should validate_uniqueness_of(:reading_list).scoped_to(:title, :user) }
</code></pre>

<p>YAHHHHSSS we are on a test-writing roll!</p>

<iframe src="//giphy.com/embed/NaNHdFMPAoL2E" width="480" height="241" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>Clean Yo Database</h2>

<p>Now that you can write tests like a pro, you probably have an overwhelming desire to write all the tests and create all the objects and build all the factories. And you totally should. But you should also make sure they don&rsquo;t come back to haunt you.</p>

<p>What do I mean by that, exactly? Well, whenever you run your test suite, you want to be sure that you clean out your database and get rid of any old or repeat data. This is super important when you have a lot of tests. You want to be sure that your test database is getting cleaned after each test, so that the next test starts with an blank database.</p>

<p>Enter <code>database_cleaner</code>, a gem that does exactly what you think it does. Although we&rsquo;re using this gem in conjunction with Rails and RSpec, it also comes in handy for testing with <a href="https://github.com/jnicklas/capybara">capybara</a> and <a href="http://docs.seleniumhq.org/">selenium</a>. I was introduced to this gem by another developer who took one look at my failing test and asked me whether or not I had repeat data. I didn&rsquo;t even realize that database inconsistencies were thing. But they are! And that&rsquo;s why we&rsquo;ll want to use the <code>database_cleaner</code> gem.</p>

<p>Inside of our <code>/spec/rails_helper.rb</code> file, there&rsquo;s a large block that starts with the line <code>RSpec.configure do |config|</code>. That&rsquo;s exactly where our <code>database_cleaner</code> gem code is going to live &ndash; inside of that block.</p>

<p>Inside of that block, we&rsquo;ll stick in this little bit of code:</p>

<pre><code class="ruby">config.before(:suite) do
end

config.around(:each) do |example|
end
</code></pre>

<p>Our <code>config.before(:suite)</code> block is for all the things we want to do before our entire test suite runs. We&rsquo;ll probably want to put in some code that will get rid of old data from previous test suites that we ran earlier.</p>

<p>The <code>config.around(:each)</code> block is for each individual test example that runs in our suite. This is where we would put certain lines of that only need to run for more specific tests (like a capybara test, for example).</p>

<p>But our tests are relatively simple in this example. So, inside of our <code>before(:suite)</code> block, we&rsquo;ll add some instructions:</p>

<pre><code class="ruby">config.before(:suite) do
  begin
    DatabaseCleaner.strategy = :transaction
    DatabaseCleaner.clean_with(:truncation)
    DatabaseCleaner.start
  ensure
    DatabaseCleaner.clean
  end
end
</code></pre>

<p>The <code>start</code> and <code>clean</code> methods hook into the beginning and end of our test suite, ensuring that whatever lines are above actually get executed properly. But what do the two lines above <em>do</em>, exactly?</p>

<p>Well, the <code>clean_with(:truncation)</code> method clears out our test database completely, and the <code>strategy = :transaction</code> method sets the behavior of the database &ldquo;cleaning strategy&rdquo; to be a transaction. Avdi Grimm has a <a href="http://devblog.avdi.org/2012/08/31/configuring-database_cleaner-with-rails-rspec-capybara-and-selenium/">great blog post</a> on what all of this means, and his explanation of transactions is easy to understand:</p>

<blockquote><p>Transactions are very fast, and for all the tests where they do work—that is, any test where the entire test runs in the RSpec process—they are preferable.</p></blockquote>

<p>Okay, cool. But what about our other block? We gotta put some stuff in there, too. But since we don&rsquo;t have any specific instructions or strategies for any of our tests, we&rsquo;ll just run each of our examples normally, inside of a single block:</p>

<pre><code class="ruby">config.around(:each) do |example|
  DatabaseCleaner.cleaning do
    example.run
  end
end
</code></pre>

<p>Nice! In just a handful of lines, we&rsquo;ve saved ourselves hours of heartache trying to figure out why one of our tests isn&rsquo;t passing. Well, at least <em>you</em> saved yourself hours of heartache. I already went through the pain of that while trying to debug my poorly-written tests! But one of us will never have to go through that, which I think is a cause for celebration!</p>

<iframe src="//giphy.com/embed/rO7Rqg58ZbJLO" width="480" height="259" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>shoulda-matchers</code> gem helps you keep your code DRY and test for associations and validations. The <code>database_cleaner</code> gem keeps your database clean between tests and helps you avoid problems related to repeat data.</li>
<li>Both of these gems have well-written and maintained documentation. Read them both! (<a href="http://matchers.shoulda.io/docs/v2.8.0/">shoulda</a> docs and <a href="https://github.com/DatabaseCleaner/database_cleaner">database cleaner</a> docs)</li>
<li>If you&rsquo;re curious about the difference between transactions, truncations, and deletions, check out <a href="http://makandracards.com/makandra/13045-understanding-database-cleaning-strategies-in-tests">this post</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tackling Those Tests, Part 2: Getting Fun and Functional With FactoryGirl]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/04/21/tackling-those-tests-part-2-getting-fun-and-functional-with-factorygirl/"/>
    <updated>2015-04-21T08:34:19-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/04/21/tackling-those-tests-part-2-getting-fun-and-functional-with-factorygirl</id>
    <content type="html"><![CDATA[<p><img src="https://33.media.tumblr.com/0b9992ca5a259a54c16199c2de69c903/tumblr_mtjab8Yo0U1rlp47to1_500.gif" style="display: block; margin-left: auto; margin-right: auto;"></p>

<p><em>This blog post is part of a series on testing. Read Part 1 <a href="http://vaidehijoshi.github.io/blog/2015/04/14/tackling-those-tests-part-1-the-how-when-and-what-of-rspec-testing/">here</a>.</em></p>

<p>Good things always come in pairs, and that couldn&rsquo;t be more true when it comes to testing. Like milk and cookies or peanut butter and jelly, test suites and test data are at their best when they&rsquo;re put together. As we discovered last week, a thoughtful test suite is important when it comes to checking our assumptions. But even the most comprehensive test suite is nothing without the appropriate amount &ndash; and type &ndash; of test data to support it.</p>

<p>Every Rails application comes with a production, development, and test environment, and good test data is an indication of a well-constructed testing environment. But not all data is created equally. To take a cue from George Orwell, we could go so far as to claim that some forms of test data are more equal than others.</p>

<p>Enter <strong>FactoryGirl</strong>, a gem that I&rsquo;ve recently discovered to be the most efficient way and painless way of creating test data within a Rails application. Generating test data is often the culprit for not only a great deal of pain and sufferring, but also some annoying bugs that are hard to catch. In fact, one of the most excruciating bugs I&rsquo;ve ever dealt with came from a single line of code, meant to create some test data. So it seems fitting that this week we tackle the most dangerous (yet thrilling!) part of testing: generating test data.</p>

<!--more-->


<h2>Setting Up The Factory Floor</h2>

<p>Since we&rsquo;re implementing <code>FactoryGirl</code> on top of a Rails application, we&rsquo;ll work exclusively with the <code>factory_girl_rails</code> gem, which has been built specifically for this purpose.</p>

<p>Once we&rsquo;ve added <code>gem 'factory_girl_rails'</code> to our <code>Gemfile</code> and run a <code>bundle install</code> in the terminal, we&rsquo;re ready to start setting up our factories. We&rsquo;ll start by creating factories for our <code>ReadingList</code> model from last week&rsquo;s post.</p>

<ul>
<li><p>Within our <code>/spec</code> directory, we&rsquo;ll need to create a <code>factories</code> directory. This is where each of the factories for each model will live.</p></li>
<li><p>Inside of our <code>/spec/factories/</code> subdirectory, we&rsquo;ll create a file for our <code>ReadingList</code> factory. The convention for naming factories is to use the plural form of the model name in snake case, with the word &ldquo;factory&rdquo; appended to the end. In our case, that file would be named <code>reading_lists_factory.rb</code>.</p></li>
<li><p>In our newly-created <code>ReadingList</code> Factory, we&rsquo;ll add a block that defines what our <code>FactoryGirl</code> object will look like. Every single factory you make for any instance of test data will begin with a block exactly like this one:</p></li>
</ul>


<pre><code class="ruby">FactoryGirl.define do
end
</code></pre>

<ul>
<li>Next, we&rsquo;ll want to give this test object a name. For this very basic test suite, we only want to test one <code>ReadingList</code> object, so we&rsquo;ll stick with a simple name: <code>reading_list</code>. Keep in mind that whatever name we give this test object is what we&rsquo;ll be using to refer to it inside of our tests. Inside of our initial <code>FactoryGirl</code> block, we&rsquo;ll define this specific object like this:</li>
</ul>


<pre><code class="ruby">FactoryGirl.define do
  factory :reading_list,  do
  end
end
</code></pre>

<ul>
<li>Lastly, we need to define some attributes for our test object. For now, our <code>ReadingList</code> test object needs only three columns in the database: one for its <code>id</code>, one for its <code>title</code>, and a foreign key of the <code>User</code> it belongs to. Here&rsquo;s what our final test object definition looks like:</li>
</ul>


<pre><code class="ruby">FactoryGirl.define do
  factory :reading_list,  do
    user
    title "Books I Want To Read"
  end
end
</code></pre>

<p>Pretty cool, right? We don&rsquo;t have to give our test object an <code>id</code>, because <code>FactoryGirl</code> will generate one when we call on it to create a new test object. So what&rsquo;s that <code>user</code> line doing in there? Well, it&rsquo;s creating an association between two factories! When <code>FactoryGirl</code> sees <code>user</code>, it looks for a file with the path <code>/spec/factories/user_factory.rb</code>, and creates an instance of a <code>User</code> test object, which it then uses to build our <code>ReadingList</code> object.</p>

<p>But right now, our code will give us a big, nasty error. Can you guess the reason behind that? Why, we don&rsquo;t have a <code>User</code> factory, of course! I guess we better get on that.</p>

<iframe src="//giphy.com/embed/W6vq5qLStzYys" width="480" height="244" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>Form Follows Function</h2>

<p>Now that we know how to set up our factories pretty quickly, we can hop on making a <code>users_factory</code>. For now, our <code>User</code> objects have only a <code>first_name</code> and a <code>last_name</code> attribute, so we&rsquo;ll create a <code>User</code> test object that satisfies these requirements.</p>

<p>But, some <code>Users</code> can also be <code>admin</code>s, but this is an optional trait that not all <code>User</code>s will have. This is something we definitely want to test, but we also want to keep our code DRY. How do we handle this? By nesting factories!</p>

<pre><code class="ruby">FactoryGirl.define do
  factory :user do
    first_name "Vaidehi"
    last_name "Joshi"

    factory :admin do
      admin true
    end
  end
end
</code></pre>

<p>This tells FactoryGirl to define two different <code>user</code> instances: a <code>user</code> test object, and an <code>admin</code> test object, which inherits the traits of the <code>user</code> object &ndash; namely, its <code>first_name</code> and <code>last_name</code> attributes.</p>

<p>While we&rsquo;re at it, why don&rsquo;t we set up our <code>books_factory</code> as well? That might look something a little like this:</p>

<pre><code class="ruby">FactoryGirl.define do
  factory :book1, class: Book do
    title "A Game Of Thrones"
    reading_list
    read true
  end

  factory :book2, class: Book do
    title "A Storm Of Swords"
    reading_list
    read false
  end
end
</code></pre>

<p>Wait, what&rsquo;s up with the <code>class: Book</code> syntax? We haven&rsquo;t seen that yet! Well, not to worry &ndash; you only have to use it in a specific situation! What exactly <em>is</em> that situation, you might ask? Well, the only time you ever need to explicitly define a FactoryGirl object&rsquo;s class is if the name of the object &ndash; <code>book1</code> or <code>book2</code> in our case &ndash; is different from the object&rsquo;s class name. If we had only a single <code>book</code> test object, we wouldn&rsquo;t have to define the class name, since FactoryGirl will know to look for it in the <code>books_factory.rb</code> file.</p>

<p>Remember last week when we had to manually create two different <code>Book</code> objects every single time we wanted to create a new test object? Well, here we&rsquo;re defining two test objects in a singular, isolated place.</p>

<iframe src="//giphy.com/embed/Q6gPyUYrCk76g" width="480" height="550" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p></p>


<p>Awesome! Now it&rsquo;s time to bring it all together in our cleaned-up test suite!</p>

<h2>Bypassing Testing Bugs</h2>

<p>When we wrote out the first iteration of our test suite last week, we had a few different <code>let</code> blocks, inside of which we called <code>create!</code> and <code>build</code> on our different objects. Our <code>let</code> blocks definintely helped us tidy up our tests, since we built and created all of our test objects at once, at the very top of our <code>do</code> block.</p>

<p>But as is the case with most of programming, there&rsquo;s a better way to do that. Now that we&rsquo;ve implemented FactoryGirl, we can cut out some of those blocks, and only call them when we need them. And, we don&rsquo;t need to create an instance with the attributes explicitly defined in a block &ndash; instead, we just tell FactoryGirl to create it for us!</p>

<p>Here&rsquo;s a refactored version of last week&rsquo;s tests, now with the <code>factory_girl_rails</code> to help us out:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">rails_helper</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;Describe ReadingList do</span>
</span><span class='line'><span class="sr">  let(:reading_list) { create(:reading_list) }&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>  <span class="n">it</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">belongs</span> <span class="n">to</span> <span class="n">a</span> <span class="n">user</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">user</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span>
</span><span class='line'>    <span class="n">expect</span><span class="p">(</span><span class="n">reading_list</span><span class="o">.</span><span class="n">user</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="kp">include</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  it &amp;lsquo;has a title&amp;rsquo; do</span>
</span><span class='line'><span class="sr">    expect(reading_list.title).to eq(&amp;ldquo;Books I Want To Read&amp;rdquo;)</span>
</span><span class='line'><span class="sr">  end&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>  <span class="n">describe</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="c1">#percentage_read&amp;rdquo; do</span>
</span><span class='line'>    <span class="n">it</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">calculates</span> <span class="n">the</span> <span class="n">percentage</span> <span class="n">of</span> <span class="n">books</span> <span class="n">read</span> <span class="k">in</span> <span class="n">a</span> <span class="n">list</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">book1</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="ss">:book1</span><span class="p">)</span>
</span><span class='line'>      <span class="n">book2</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="ss">:book2</span><span class="p">)</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;  expect(reading_list.percentage_read).to eq(50.00)</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  end</span>
</span><span class='line'><span class="sr">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>You&rsquo;ll notice that I&rsquo;ve replaced <code>build</code> with <code>create</code> in this iteration of tests. I initially had used <code>build</code>, but when I started implementing FactoryGirl, I hit a wall. In fact, I spent an unmentionable number of hours trying to figure out what on earth I was doing wrong!</p>

<p>It turns out I was using the wrong tool for the job. The <code>build</code> method creates an instance, but <em>does not</em> save it. The <code>create</code> method, on the other hand, both creates <em>and</em> persists the object. This was one of the most important debugging lesson I learned while writing tests, and it was not a fun lesson to learn. I hope that at the very least, <em>you</em> won&rsquo;t have to struggle through that bug like I did!</p>

<p>The thing that I valued the most during this debugging process was learning how <code>FactoryGirl</code> actualy works. If those <code>build</code> and <code>create</code> methods seem an awful lot like ActiveRecord to you, that&rsquo;s because it IS ActiveRecord!</p>

<p>In fact, when we call <code>create(:book1)</code>, the magic of <code>FactoryGirl</code> actually does the following:</p>

<ol>
<li>Creates a new <code>ReadingList</code>.</li>
<li>Saves the <code>ReadingList</code>.</li>
<li>Creates a new <code>Book</code>.</li>
<li>Associates that <code>Book</code> with the <code>ReadingList</code>.</li>
<li>Saves the <code>Book</code>.</li>
</ol>


<p>Amazing, right? We get so much functionality, all in a single method call! Learning this made me appreciate what <code>FactoryGirl</code> does so much more than if I had just included it blindly in my <code>Gemfile</code> without giving it a second though.</p>

<p>Thoughtbot, the creators of the <code>factory_girl</code> gem, has a great post explaining how it <a href="https://github.com/thoughtbot/factory_girl/wiki/How-factory_girl-interacts-with-ActiveRecord">interacts with ActiveRecord</a>. I found their explaination super helpful when I was first learning about FactoryGirl:</p>

<blockquote><p>When you invoke a factory, factory_girl uses your definitions to compile a list of attributes that should be assigned to that instance, as well as any associated factories. It saves associations first so that foreign keys will be properly set on dependent models. To create an instance, it calls new without any arguments, assigns each attribute (including associations), and then calls save!. factory_girl doesn’t do anything special to create ActiveRecord instances. It doesn’t interact with the database or extend ActiveRecord or your models in any way.</p></blockquote>

<p>Sure, when it comes to the world of testing, the night may be dark and full of terrors. But with <code>FactoryGirl</code> on your side, you&rsquo;ll feel safer, as though you&rsquo;ve got an army of dragons to back you up. In my head, they&rsquo;re super cute ones kinda like these:</p>

<iframe src="//giphy.com/embed/WmqnGHr3oYGR2" width="480" height="259" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p></p>


<p>Tune in again next week, when I&rsquo;ll cap off this series by sharing two more gems we can add to our army of testing dragons: <code>shoulda-matchers</code> for writing quick and easy validations, and <code>database_cleaner</code>, the key to unlocking your dreams of a neat and tidy testing database. Until then, test on, my friends &ndash; test on!</p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>factory_girl_rails</code> gem is used to generate test data for a Rails application, and each factory defines the attributes and associations of a test object. All factory files should be created in the <code>./spec/factories</code> subdirectory.</li>
<li>This post only covers a couple of the tricks that <code>FactoryGirl</code> has up her sleeve. To read them all, check out the gem&rsquo;s <a href="http://www.rubydoc.info/gems/factory_girl/file/GETTING_STARTED.md">extensive documentation</a>.</li>
<li>This tutorial is super detailed and I referred to it frequently while writing this blog post. If you want to learn more about testing and implementing <code>FactoryGirl</code>, <a href="http://everydayrails.com/2012/03/19/testing-series-rspec-models-factory-girl.html">give it a read</a>.</li>
<li>Did you know that factories and fixtures are actually quite different? No? Well then, you should read <a href="https://semaphoreci.com/blog/2014/01/14/rails-testing-antipatterns-fixtures-and-factories.html">this post</a> and get all caught up.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tackling Those Tests, Part 1: The How, When, and What of Rspec Testing]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/04/14/tackling-those-tests-part-1-the-how-when-and-what-of-rspec-testing/"/>
    <updated>2015-04-14T08:17:03-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/04/14/tackling-those-tests-part-1-the-how-when-and-what-of-rspec-testing</id>
    <content type="html"><![CDATA[<p><img src="http://www.datamation.com/imagesvr_ce/306/philosophy-geeks.jpg" style="display: block; margin-left: auto; margin-right: auto; width: 50%; height: 50%;"></p>

<p>Up until two weeks ago, I had one great fear: <em>testing</em>. And, to be clear, when I say &ldquo;fear&rdquo;, what I actually mean is sheer terror.</p>

<p>My test-writing anxiety stems from the fact that I&rsquo;ve never really had to do it before. I mean, I&rsquo;ve had to make tons of tests <em>pass</em>, which means that I read other people&rsquo;s tests all the time. Yet I&rsquo;ve somehow made it thus far in my coding career without ever having to write relatively complex tests of my own. But that all changed a few weeks ago, when I was forced to finally confront my fear of testing.</p>

<p>The thing about conquering fears, however, is that usually involves doing the very thing that you&rsquo;re afraid of. So, I spent the better portion of a week learning how and when to write tests, all while encountering a couple painful bugs along the way. It was not a fun week, but the good news is that I can write a fully-functioning test suite now! And now that I know more about testing, I actually find it kind of fun &ndash; so fun, in fact, that I&rsquo;m going to share it with you!</p>

<!--more-->


<h2>Ain&rsquo;t No Spec Like Rspec</h2>

<p>Before we get into the how and when of testing, we first need to setup our Rails application with <code>rspec</code>, a behavior-driven development framework built specifically for testing in Ruby.</p>

<p>We&rsquo;ll first want to add <code>rspec-rails</code> to our the development and test group in our <code>Gemfile</code>:</p>

<pre><code class="ruby">group :development, :test do
  gem 'rspec-rails'
end
</code></pre>

<p>Next, we&rsquo;ll run a quick <code>bundle install</code>, and then generate a <code>/spec</code> folder by running <code>rails generate rspec:install</code>. We now have access to a <code>rails_helper.rb</code> and <code>spec_helper.rb</code> file inside of our <code>/spec</code> directory.</p>

<p>Finally, we&rsquo;ll want to add files for everything that we want to test. But let&rsquo;s start simple for now and just test our <code>ReadingList</code> model. The path to this spec file should be <code>/spec/models/reading_list_spec.rb</code>, so we&rsquo;ll need to add a <code>models</code> directory and a <code>reading_list_spec.rb</code> file.</p>

<p>Once we&rsquo;ve done that, we can check that everything is setup properly by running our <code>rspec</code> command:</p>

<pre><code>♥ rspec
No examples found.


Finished in 0.00023 seconds (files took 0.08619 seconds to load)
0 examples, 0 failures
</code></pre>

<p>You know what needs to happen next, right? It&rsquo;s time for us to write some tests.</p>

<iframe src="//giphy.com/embed/nhj799TYbxG80" width="480" height="235" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Okay, I feel your pain. But I promise, we&rsquo;re going to get through this together.</p>

<h2>Knowing What To Test</h2>

<p>I&rsquo;ve found that the best way to start writing tests is by picking one section to work on first. Otherwise, it can just be so overwhelming and might make you want to give up completely. Let&rsquo;s take a look at what our <code>ReadingList</code> model:</p>

<pre><code class="ruby">class ReadingList &lt; ActiveRecord::Base
  belongs_to :user
  has_many :books

  attr_accessor :read

  def books_read
    books.where(read: true).count
  end

  def books_unread
    books.where(read: false).count
  end

  def percentage_read
    read = books_read.to_f
    unread = books_unread.to_f

    calculate_percentage(read, unread)
  end

  def calculate_percentage(read, unread)
    ((read / unread) * 100).round(2)
  end
end
</code></pre>

<p>Whoa, this seems like a lot. But fear not! Programming is nothing more than breaking down big problems into smaller, bite-sized pieces. And that&rsquo;s exactly what we&rsquo;ll do when writing these tests.</p>

<p>Let&rsquo;s look at the <code>percentage_read</code> method to start. This is the instance method that we&rsquo;ll actually want to call somewhere in our view. It uses the number of books marked <code>read</code> (which will always be a boolean <code>true</code> or <code>false</code> value), and calculates the <code>User</code>&rsquo;s reading progress on the list, returning a percentage.</p>

<p>But even though this is the method we want to test, a deeper look reveals that it actually relies and calls upon three other methods: <code>books_read</code>, <code>books_unread</code>, and <code>calculate_percentage</code>. This should be a big red flag, because it means that we need to test these three methods individually, first. The flow of our code is actually directing us in our test-writing process: we can decide which tests to write and in which order by looking at our method&rsquo;s dependencies.</p>

<p>So, let&rsquo;s hop to it:</p>

<ul>
<li>We&rsquo;ll start by first requiring <code>rails_helper</code> in our <code>reading_list_spec.rb</code>, and stubbing out our tests with a block:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">rails_helper</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span><span class="o">&lt;</span><span class="sr">/li&gt;</span>
</span><span class='line'><span class="sr">&lt;/u</span><span class="n">l</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="no">RSpec</span><span class="o">.</span><span class="n">describe</span> <span class="no">ReadingList</span><span class="p">,</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:model</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">describe</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="c1">#percentage_read&amp;rdquo; do</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>We can use a <code>describe</code> block to break up our tests into different sections. They will come in handy as our tests start to grow, and will make our test suite easier to read &ndash; not just when we come back to look at them later, but also when another developer digs through our code. The <code>#</code> symbol before our method name denotes that <code>percentage_read</code> is an instance method, another important distinction to make as we go about adding more tests.</p>

<ul>
<li>Next, we&rsquo;ll describe what our method <em>should</em> do by using <code>it</code> blocks</li>
</ul>


<pre><code class="ruby">  describe "#percentage_read" do
    it "finds the number of read books in a list" do
    end

    it "finds the number of unread books in a list" do
    end

    it "calculates a percentage when given two values" do
    end

    it "calculates the percentage of books read in a list" do
    end
  end
</code></pre>

<ul>
<li>Now we need to add some data &ndash; but not too much! We only want enough data to test the functionality of our method. Let&rsquo;s create a list with two books, one marked read and the other not marked read. We&rsquo;ll add this before our <code>describe</code> and <code>it</code> blocks:</li>
</ul>


<pre><code class="ruby">  let(:list) { ReadingList.create!(title: "Vaidehi's List" }
  let(:book1) { list.books.build(title: "A Game Of Thrones", read: true) }
  let(:book2) { list.books.build(title: "A Storm Of Swords", read: false) }
</code></pre>

<p>Wait, what&rsquo;s that <code>let</code> doing in there? The answer is: something magical! It creates an instance of <code>ReadingList</code> and makes a reference to it called <code>list</code>, which is then accessible to us in each of our <code>it</code> blocks. The <code>let</code> syntax is <a href="http://www.reddit.com/r/ruby/comments/2bcz12/newbie_to_rspec_why_use_let_instead_of_a_local/">an alternative</a> to creating local variables inside <em>every single</em> one of our <code>it</code> blocks.</p>

<ul>
<li>Finally, we&rsquo;ll add some expectations for our model&rsquo;s behavior when each method is called. Our finished test suite now looks like this:</li>
</ul>


<pre><code class="ruby">RSpec.describe ReadingList, :type =&gt; :model do
  let(:list) { ReadingList.create!(title: "Vaidehi's List" }
  let(:book1) { list.books.build(title: "A Game Of Thrones", read: true) }
  let(:book2) { list.books.build(title: "A Storm Of Swords", read: false) }

  describe "#percentage_read" do
    it "finds the number of read books in a list" do
      expect(list.books_read).to eq(1)
    end

    it "finds the number of unread books in a list" do
      expect(list.books_unread).to eq(1)
    end

    it "calculates a percentage when given two values" do
      expect(list.calculate_percentage(3.0, 4.0)).to eq(75.00)
    end

    it "calculates the percentage of books read in a list" do
      expect(list.percentage_read).to eq(50.00)
    end
  end
end
</code></pre>

<p>Each one of our tests is just a single line, specifying our exact expectations! Pretty awesome, right? This makes for relatively DRY code, which is pretty easy to understand.</p>

<h2>Testing Your Assumptions</h2>

<p>Now that we know <em>how</em> to write tests, it&rsquo;s time to address the question of <em>when</em> and <em>what</em> to test. Here&rsquo;s a good rule of thumb that I adhere to: <strong>test your assumptions</strong>. Whenever we write code, we make a ton of assumptions. The problem with making assumptions, however, is that you forget or don&rsquo;t realize that you made them, and then they end up coming back to screw you.</p>

<p><img src="http://www.explainxkcd.com/wiki/images/e/e6/when_you_assume.png" style="display: block; margin-left: auto; margin-right: auto;"></p>

<p>In fact, even the tests we just wrote are based on a lot of assumptions. And there are a lot of things that we haven&rsquo;t considered. For example:</p>

<ol>
<li>Does the <code>read</code> attribute on a <code>ReadingList</code> object only accept a <code>boolean</code> value? What if someone tries to pass a non-boolean value as <code>read</code>?</li>
<li>What is the default value of the <code>read</code> attribute?</li>
<li>What if <code>read</code> is nil &ndash; what will break?</li>
<li>What if the return value of <code>books_unread</code> is <code>0</code>?</li>
</ol>


<p>Just FYI, I discovered the answer to number 4, which looks like this:</p>

<blockquote class="twitter-tweet tw-align-center" lang="en"><p>Uh oh&#8230;I did a bad thing: <a href="http://t.co/uFZEkyCPRl">pic.twitter.com/uFZEkyCPRl</a></p>&mdash; Vaidehi Joshi (@vaidehijoshi) <a href="https://twitter.com/vaidehijoshi/status/583994491570229249">April 3, 2015</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>This is all to say that we must write tests for behavior that <em>should</em> and <em>should not</em> occur. We&rsquo;d probably want to write validations to prevent <code>nil</code> values, and we&rsquo;d definitely want to raise an error whenever we try to divide by <code>0</code>. We aren&rsquo;t just testing for what we can see &ndash; we also need to test for things we can&rsquo;t see, and any edge cases that we can think of.</p>

<p>Learning the how, when, and what of testing is a process that comes with time and practice. The more tests you write, the better you&rsquo;ll get at testing. Of course, there are few tips and tricks of the testing trade that can very quickly and easily save you a lot of heartache.</p>

<p>Tune in again next Tuesday, when I&rsquo;ll delve into generating fixtures for test data using FactoryGirl &ndash; a trick that&rsquo;s going to make your testing life so much easier.</p>

<h2>tl;dr?</h2>

<ul>
<li>All <code>rspec</code> tests have an <code>it</code> block, which describes what behavior is expected. This block should never be too big, and contains an assertion of what expected value should be returned.</li>
<li>The <code>let</code> syntax allows for lazy evaluation and keeps you from having to create a new instance of an object inside of every single <code>it</code> block. Check out more on the <code>let</code> and <code>let!</code> helper methods over on <a href="http://stackoverflow.com/questions/17407733/trouble-differentiating-rspecs-let-vs-let">this Stack Overflow answer</a> or on <a href="https://www.relishapp.com/rspec/rspec-core/v/2-5/docs/helper-methods/let-and-let">this blog post</a>.</li>
<li>Use <code>describe</code> blocks to divide up your tests into sections, based on functionality and code cohesion. You can also use <code>context</code> blocks to assert different scenarios that could occur during one method call. Read about the <a href="http://lmws.net/describe-vs-context-in-rspec">difference between describe and context</a>.</li>
<li>Find out more about different rspec testing conventions at <a href="http://betterspecs.org/">Better Specs</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Querying at Warp Drive: Using ActiveRecord Includes]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/04/07/querying-at-warp-drive-using-activerecord-includes/"/>
    <updated>2015-04-07T08:36:54-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/04/07/querying-at-warp-drive-using-activerecord-includes</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/Wkym7gz6fu1Nu" width="480" height="271" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>There comes a time in the life of every developer when you stop thinking about whether your code works. Instead, you concern yourself with something else entirely: how <em>efficiently</em> your code works.</p>

<p>In fact, you can trace this back to Kent Beck&rsquo;s <a href="http://c2.com/cgi/wiki?MakeItWorkMakeItRightMakeItFast">philosophy</a> of &ldquo;Make it work, make it right, make it fast.&rdquo; Once you&rsquo;ve got your code doing what you want it to do, you need to make it better. But what do you do with your improved code once you&rsquo;ve set it right? Make sure that it&rsquo;s working as fast as it possibly can, of course!</p>

<p>Code efficiency is a bit of an advanced topic, and I&rsquo;m definitely no expert in it. But I recently learned a pretty awesome querying method that&rsquo;s neither difficult to understand nor too complex to implement. In fact, this method has always been right under your nose, hidden inside of the magic that is ActiveRecord. So what is this magical method, exactly? Well, it&rsquo;s called <strong>includes</strong>, and once you start using it, you&rsquo;ll never make database queries the same way again.</p>

<!--more-->


<h2>Inquiries on Querying</h2>

<p>The best way to know how to make your code run at warp drive is by first figuring out how fast it is to start with. But before we get into the issue of speed, let&rsquo;s check out what our code base looks like:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Order</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'>  <span class="n">belongs_to</span> <span class="ss">:user</span>
</span><span class='line'>  <span class="kp">attr_accessor</span> <span class="ss">:details</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;class User &amp;lt; ActiveRecord::Base</span>
</span><span class='line'><span class="sr">  has_many :orders&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>  <span class="k">class</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="nb">self</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">all_order_details</span>
</span><span class='line'>      <span class="no">User</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">each</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
</span><span class='line'>        <span class="n">user</span><span class="o">.</span><span class="n">orders</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">order</span><span class="o">|</span>
</span><span class='line'>          <span class="n">order</span><span class="o">.</span><span class="n">details</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Nothing <em>too</em> fancy happening here. We&rsquo;ve got a one-to-many relationship here, with a <code>User</code> object having many <code>Orders</code>, and each <code>Order</code> belonging to a <code>User</code>. There&rsquo;s also a class method called <code>all_order_details</code> in our <code>User</code> class. This method queries for all of the <code>User</code> objects in our database, and loops through each <code>User</code> instance, grabbing each order, and calling <code>details</code> on it. And if we take a look at our <code>Order</code> class, we&rsquo;ll see that <code>details</code> is just an attribute on <code>Order</code>. (Forget what that weird <code>class &lt;&lt; self</code> syntax means? Jog your memory with <a href="http://vaidehijoshi.github.io/blog/2015/02/24/class-inheritance-part-2-singletons-and-eigens-oh-my/">this post</a> from a few weeks ago.)</p>

<p>Our plan is to use this method in an admin panel or dashboard, which is probably the only place where someone would want to see all the order details of every single order placed by every single user in our system. But even though we&rsquo;re not going to be using this method within all of our views, it&rsquo;s still important that we take a look at what it&rsquo;s doing in order to understand whether we can refactor it and make it faster.</p>

<p>So, this code does pretty much exactly what we want it to do. But how fast does it do its job? The only way to find out is by checking out what happens in our server logs when we call our method:
<code>
2.2.0 :001 &gt; User.all_order_details
  User Load (1.1ms)  SELECT "users".* FROM "users"
  Order Load (0.6ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 1]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 2]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 3]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 4]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 5]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 6]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 7]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 8]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 9]]
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" = ?  [["user_id", 10]]
 =&gt; # returns an array of order details
</code></p>

<p>Whoa, whoa, whoa &ndash; hold up. We&rsquo;ve got a problem.</p>

<iframe src="//giphy.com/embed/iJxHzcuNcCJXi" width="480" height="360" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Sure, we got an array of <code>Order</code> details, which is great. But doesn&rsquo;t it seem kind of weird that we had to make so many queries? Are the red flags going off in your head, too? Time to investigate.</p>

<h2>The N + 1 Problem</h2>

<p>Okay, so maybe you didn&rsquo;t recoil in horror when you saw all those queries. But let me explain why you probably should. In our database, we currently have 10 <code>Users</code>, each of whom has one <code>Order</code>. If we look at the queries we&rsquo;re currently making, you&rsquo;ll notice that we&rsquo;re first loading all of our <code>User</code> objects:
<code>ruby
User Load (1.1ms)  SELECT "users".* FROM "users"
</code></p>

<p>Loading all of our <code>Users</code> takes 1.1 milliseconds. But what about our <code>Order</code> details? We need to go through our <code>Users</code> table in order to grab each <code>Order</code>&rsquo;s details. That&rsquo;s exactly what&rsquo;s happening in each one of the queries that looks like this:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Order</span> <span class="no">Load</span> <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">6</span><span class="n">ms</span><span class="p">)</span>  <span class="no">SELECT</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">orders</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">.</span><span class="n">&lt;em</span><span class="o">&gt;</span> <span class="no">FROM</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">orders</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span> <span class="no">WHERE</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">orders</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">.</span><span class="n">&amp;ldquo</span><span class="p">;</span><span class="n">user_id</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span> <span class="o">=</span> <span class="p">?</span>  <span class="o">[[&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">user_id</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="mi">1</span><span class="o">]]</span>
</span><span class='line'><span class="no">Order</span> <span class="no">Load</span> <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">1</span><span class="n">ms</span><span class="p">)</span>  <span class="no">SELECT</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">orders</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">.</span><span class="n">&lt;</span><span class="sr">/em&gt; FROM &amp;ldquo;orders&amp;rdquo; WHERE &amp;ldquo;orders&amp;rdquo;.&amp;ldquo;user_id&amp;rdquo; = ?  [[&amp;ldquo;user_id&amp;rdquo;, 2]]&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">more</span> <span class="n">queries</span> <span class="k">for</span> <span class="n">each</span> <span class="n">user</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span><span class="n">s</span> <span class="n">orders</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;</span>
</span><span class='line'><span class="sr">We&#39;re first loading all the `Orders` when we look for a `User` with an `id` of `1`, which takes us 0.6 milliseconds. And as we continue querying through the remaining 9 `Users` in our database, each query takes us 0.1 milliseconds.</span>
</span><span class='line'>
</span><span class='line'><span class="sr">Right now, this might not seem like that big of a deal. But we have to keep in mind that we only have ten users so far! Hopefully, we&#39;ll have a *lot* more as our user base grows. And that&#39;s where our problem comes in. Actually, our problem is quite common, and it&#39;s even got a name: **the n + 1 problem**.</span>
</span><span class='line'>
</span><span class='line'><span class="sr">The crux of the n + 1 problem is essentially this: the number of queries you make will directly correspond to the number of objects (n) that you have in your database. This means that we&#39;ll have 1 query to get all of our `User` objects, and n number of *additional* queries for each `User` object we want to get order details from.</span>
</span><span class='line'>
</span><span class='line'><span class="sr">With only 10 users, we&#39;ll make 11 queries in total: 1 query for our users, and 10 for each user we query to load the user&#39;s order details. But what if we have 10,000 users? Or if we&#39;re being optimistic, 100,000 user? ...Or even a million? Making over a hundred thousand queries is just way too slow and simply not acceptable.</span>
</span><span class='line'>
</span><span class='line'><span class="sr">Thankfully, this problem is so common that Rails has a fantastic solution, tailor-made to handle it.</span>
</span><span class='line'>
</span><span class='line'><span class="sr">## Smarter Querying</span>
</span><span class='line'>
</span><span class='line'><span class="sr">Rails is a pretty smart cookie -- it allows you to load a bunch of stuff at once ahead of time if you know exactly what you want to query. This is referred to as **eager loading**, and a really easy way to eager load your associations is by using the ActiveRecord method `includes`.</span>
</span><span class='line'>
</span><span class='line'><span class="sr">You can call `includes` on an object an pass it a parameter of the table you want to load as a symbol name. We can implement this directly on our `all_order_details` method:</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;def all_order_details</span>
</span><span class='line'><span class="sr">  User.all.includes(:orders).each |user|</span>
</span><span class='line'><span class="sr">    user.orders.each do |order|</span>
</span><span class='line'><span class="sr">      order.details</span>
</span><span class='line'><span class="sr">    end</span>
</span><span class='line'><span class="sr">  end</span>
</span><span class='line'><span class="sr">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>This may look pretty similar to our original code at first, but when we look at our server logs, we can see a world of difference:
<code>ruby
2.2.0 :002 &gt; User.all_order_details
  User Load (0.2ms)  SELECT "users".* FROM "users"
  Order Load (0.3ms)  SELECT "orders".* FROM "orders" WHERE "orders"."user_id" IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
 =&gt; # returns an array of order details
</code></p>

<p>Nice. We have something really cool happening here. Instead of making &ldquo;n + 1&rdquo; number of queries, we&rsquo;re only making two queries. We spend 0.2 milliseconds getting our users, and 0.3 milliseconds loading our orders. We&rsquo;re only spending 0.5 milliseconds compared to the 2.6 milliseconds we were spending before.</p>

<p>How does this work, exactly? Eager loading allows you to specify exactly which tables you want to load into memory. Just by loading them, we&rsquo;re reducing the number of queries we&rsquo;re making. It&rsquo;s like telling ActiveRecord, <em>Hey, I already know I want all the Users and I know I want to do something with their associated Orders. So instead of querying the table one instance at a time, why don&rsquo;t you just be super efficient and grab &lsquo;em all for me in one shot?</em> And that&rsquo;s pretty much exactly what Rails will do.</p>

<p>I also like the way that <a href="http://www.theodinproject.com/ruby-on-rails/active-record-queries">the Odin Project</a> explains how <code>includes</code> works:</p>

<blockquote><p>&ldquo;Includes basically takes the name of one or more associations that you&rsquo;d like to load at the same time as your original object and brings them into memory. You can chain it onto other methods like where or order clauses.&rdquo;</p></blockquote>

<p>Other helpful methods that do similar things to solve the n + 1 problem are <code>joins</code>, used for joining multiple tables together, and <code>pluck</code>, which grabs a specific column and returns it in an array format.</p>

<h2>Big O Puts the O In &ldquo;Uh Oh&rdquo;</h2>

<iframe src="//giphy.com/embed/fcpJebgkQ14UE" width="480" height="192" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Dealing with issues of efficiency and speed is a pretty advanced topic, mostly because it gets into the deep depths of computer science and the dreaded concept of <strong>Big O Notation</strong>. Big O deals with the space time complexity of different algorithms.</p>

<p>The n + 1 problem is actually nothing more than a Big O problem, because it has to do with how well your algorithm runs. The Big O complexity of an n + 1 problem is <strong>O(n)</strong>, pronounced &ldquo;Oh of n&rdquo;. An O(n) algorithm is one whose performance will grow linearly, and will be directly proportional to the size of input data (the more <code>Users</code> we have, the larger our query of each user&rsquo;s order details).</p>

<p>Big O should always be <a href="http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/">taken into consideration</a> while building an app. But that being said, it should never be the first thing that you think about &ndash; particularly if you are a reatively junior developer. The space time complexity of your algorithm is something you can think about while refactoring your code, or rethinking how you&rsquo;re approaching or solving a problem.</p>

<p>Being able to evaluate an algorithm&rsquo;s efficiency is definitely something to work towards, but it&rsquo;s also something that takes practice. Implementing ActiveRecord&rsquo;s <code>includes</code> method is a good way to start playing around with speed and efficiency &ndash; plus, you&rsquo;ll make some kickass queries in the process, and that always feels pretty awesome. (I mean, obviously it&rsquo;s not as awesome as going warp speed on the Enterprise, but hey, it&rsquo;s an acceptable alternative.)</p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>includes</code> method can be chained on to any ActiveRecord model, and takes parameters of an association/table name, passed in as a symbol. Read more about it in the <a href="http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations">Rails docs</a>.</li>
<li>If you&rsquo;re still curious about the n + 1 problem, check out another good example of it <a href="http://www.sitepoint.com/silver-bullet-n1-problem/">over here</a>.</li>
<li>Big O Notation got you down? Check out <a href="http://nathanmlong.com/2015/03/understanding-big-o-notation/">this awesome resource</a>, which has graphs to go along with each code snippet example of different types of notation.</li>
</ul>

]]></content>
  </entry>
  
</feed>
