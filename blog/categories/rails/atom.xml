<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-07-27T21:33:17-04:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clipping Images for Rails: Using Paperclip]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/07/28/clipping-images-for-rails-using-paperclip/"/>
    <updated>2015-07-28T08:42:36-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/07/28/clipping-images-for-rails-using-paperclip</id>
    <content type="html"><![CDATA[<p><img src="http://www.officemuseum.com/1894_Gem_Paper_Clip_adv_discovered_by_The_Early_Office_Museum.JPG" style="display: block; margin-left: auto; margin-right: auto;"/></p>

<p>They say that a picture is worth a thousand words. How they came up with a such a nice, conveniently specific number number I&rsquo;ll never know. But what I do know is that everything on the web is just data floating around in cyberspace. And when I say everything, I really do mean <em>everything</em> &ndash; including pictures!</p>

<p>I&rsquo;ve worked on a few different projects that have required building out an interface to allow a user or an admin to upload images. The first time that I had to do this, I knew that there were a few different Rails gems out there to help make this magic happen. But I didn&rsquo;t really understand what was going on when I implemented these gems the first time around. To be quite honest, the first time I had to implement file uploading, I just followed the setup steps rather blindly. Now that I&rsquo;ve had to solve the same problem multiple times, however, I feel a bit more comfortable with the process.</p>

<p>There are a few different gems out there for handing file attachment in Rails, but my favorite one to use so far has been <strong>paperclip</strong>. Created by the super cool developers over at <a href="https://github.com/thoughtbot/paperclip">ThoughtBot</a>, the paperclip gem is fairly simple and straightforward to use. The reason that I like this gem in particular is that it fits seamlessly into the Rails framework. Files and attachments are treated just like an attribute on an ActiveRecord object, which makes the setup process both easy and intuitive. However, that doesn&rsquo;t mean that it&rsquo;s not intimidating at first! Luckily, we&rsquo;re going to walk through using the paperclip gem together.</p>

<!--more-->


<h2>How To Start Clipping</h2>

<iframe src="//giphy.com/embed/xXG9gNuwQcN1u" width="480" height="425" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Since <code>paperclip</code> is a gem, the first thing we&rsquo;ll have to do before we really get started on clipping anything is add it to our <code>Gemfile</code>:</p>

<p><code>gem "paperclip", "~&gt; 4.3"</code></p>

<p>and then <code>bundle install</code>, because it&rsquo;s what all the cool kids do. This is also a good time to make sure that we have <code>ImageMagick</code>, which is one of <code>paperclip</code>&rsquo;s dependencies. (We can always run <code>brew install imagemagick</code> to install it if we don&rsquo;t have it already.)</p>

<p>Now it&rsquo;s time to get clipping! And take a look at our schema, obvs. For our Bookstore app, we want each of our authors to have a headshot image uploaded and associated with their work. This is going to be super important from a user experience point of view, and it will be something that will be displayed on the show page of any given author.</p>

<p>There are two ways to go about actually adding an attachment to our model; one of them is is a bit easier because it generates a migration for you. But we&rsquo;ll go ahead and write our own migration to start.</p>

<p>We already have an <code>Author</code> model and migration. What we need to do is add an <code>attachment</code> column that&rsquo;ll handle everything from file uploading to associating a file with a specific <code>Author</code> object. So, we can just write a migration (<code>rails g migration AddProfileMediaToAuthors</code>) that will add an <code>attachment</code> column to our <code>Authors</code> table:</p>

<pre><code class="ruby">class AddProfileMediaToAuthors &lt; ActiveRecord::Migration
  def self.up
    add_attachment :authors, :profile_media
  end

  def self.down
    remove_attachment :authors, :profile_media
  end
end
</code></pre>

<p>We&rsquo;ll call our attachment columns <code>profile_media</code> to preemptively namespace the different types of attachments that we might have on a single <code>Author</code>&rsquo;s page. And just in case you needed a little refresher on the difference between the <code>up</code> and <code>down</code> methods, head <a href="http://vaidehijoshi.github.io/blog/2015/05/19/the-secret-life-of-your-database-part-1-migrations/">over here</a>.</p>

<p>Okay, now we&rsquo;ll run <code>rake db:migrate</code>, and take a look at our <code>schema.rb</code> file. Let&rsquo;s see what happened:</p>

<pre><code class="ruby">create_table "authors", force: :cascade do |t|
    t.string   "firstname"
    t.string   "lastname"
    t.datetime "created_at",         null: false
    t.datetime "updated_at",         null: false
    t.string   "profile_media_file_name"
    t.string   "profile_media_content_type"
    t.integer  "profile_media_file_size"
    t.datetime "profile_media_updated_at"
end
</code></pre>

<p>Interesting! So our <code>add_attachment</code> method actually did a lot of things for us, didn&rsquo;t it? That&rsquo;s because it&rsquo;s actually a helper method does a lot of important things that <code>paperclip</code> relies on:</p>

<ol>
<li>It adds a <code>file_name</code> for our attachment.</li>
<li>It adds a <code>content_type</code> for our attachments, which will be the <em>mime type</em> of our images.</li>
<li>It adds the <code>file_size</code> of our attachments.</li>
<li>It creates a <code>updated_at</code> column, which is particularly useful since we can order and sort our attachments/images by <code>datetime</code> format.</li>
</ol>


<p>Now we need to hook up our database migration with the corresponding model!</p>

<h2>Objects With Attached Files</h2>

<p><img src="http://2.bp.blogspot.com/_khdFP9RCQSw/TSPePSmnscI/AAAAAAAAAK4/My8FyIo8Xuo/s1600/a-jpeg-is-worth-approximately-a-thousand-words.gif" style="display: block; margin-left: auto; margin-right: auto;"/></p>

<p>Inside of our <code>Author</code> class, we need want to add one very important line to our model: <code>has_attached_file</code>. The important thing about this method is that it needs to correspond to whatever we named our attachment in our migrations from earlier. In our case, we called our attachments <code>profile_media</code>, so that&rsquo;s exactly what we&rsquo;ll use inside of our model as well:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
  has_attached_file :profile_media, 
    styles: { 
        large: "500x500", 
        medium: "300x300", 
        thumb: "100x100" 
    }, 
    default_url: "/images/:style/missing_profile_media.png"
end
</code></pre>

<p>This line sets up a few defaults for us and gives us the option of having a few different sizes for our <code>profile_media</code>. The <code>default_url</code> can be helpful if we ever want to give our attachment url a default and avoid an instance of <code>nil</code>. The sizes that we specify here are what we&rsquo;ll use inside of our views:</p>

<pre><code class="ruby">= link_to image_tag(author.profile_media.url(:thumb)), author.profile.url
</code></pre>

<p>But the most important part of making all of this work is, of course, permitting our media to be seen! (I&rsquo;m looking at you, strong params!). All we need to do is add our attachment name (<code>profile_media</code>) to our permitted parameters, which is already being used by our controller actions:</p>

<pre><code class="ruby">class AuthorsController &lt; ApplicationController
    def create
        author = Author.create(author_params)
    end

    private
      def author_params
        params.require(:author).permit(:firstname, :lastname, :profile_media)
      end
end
</code></pre>

<p>Pretty simple, right? But these are just the bare bones of <code>paperclip</code>. We can spice things up a bit, too!</p>

<h2>Validating And Customizing Our Clippings</h2>

<p>Once we have the gem up and working, it&rsquo;s super easy to add some bells and whistles and write it to fit our application&rsquo;s specific standards. The developers at ThoughtBot actually have several different validators that we can implement, including <code>AttachmentContentTypeValidator</code>, <code>AttachmentPresenceValidator</code>, and <code>AttachmentSizeValidator</code>. Personally, however, I prefer the old school helper methods, which function in exactly the same way.</p>

<p>Let&rsquo;s add a <code>validates_attachment_content_type</code> to our <code>Author</code> class, and validate that the content being uploaded is actually an <code>image</code>. We can do that with a nice regular expression:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
    has_attached_file :profile_media, 
        styles: { 
            large: "500x500", 
            medium: "300x300", 
            thumb: "100x100" 
        }, 
        default_url: "/images/:style/missing_profile_media.png"

    validates_attachment_content_type :profile_media, content_type: /\Aimage\/.*\Z/
end
</code></pre>

<p>We can also validate the size and presence of our attachment as well:</p>

<pre><code class="ruby">validates :profile_image, attachment_presence: :true

validates_attachment_size :profile_media, size: { in: 0..100.kilobytes }
</code></pre>

<p>And what about deleting attachments? Well, because <code>paperclip</code> is designed to work so well with ActiveRecord, any attachment we create is treated just like an attribute. As the documentation explains,</p>

<blockquote><p>The intent behind <code>paperclip</code> was to keep setup as easy as possible and to treat files as much like other attributes as possible. This means they aren&rsquo;t saved to their final locations on disk, nor are they deleted if set to nil, until ActiveRecord::Base#save is called. It manages validations based on size and presence, if required.</p></blockquote>

<p>Since the only way to delete an attachment is by setting the attribute to <code>nil</code>, there are a few different ways to actually go about deleting attachments. One implementation that I like to use is writing a custom method that checks whether an <code>Author</code> object has it&rsquo;s <code>profile_media</code> attribute equal to <code>nil</code> before saving it:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
    before_save :delete_profile_media, 
        if: -&gt; { remove_profile_media == '1' &amp;&amp; !profile_media_updated_at_changed? }

    attr_accessor :remove_profile_media

    private
        def delete_profile_media
            self.profile_media = nil
        end
end
</code></pre>

<p>In this structure, I also create an attribute on my <code>Author</code> object called <code>remove_profile_media</code>, which will either be <code>0</code> or <code>1</code>, based on whether a box on a form has been checked or not. If the button is checked, <code>remove_profile_media</code> will be set to <code>1</code>, and I&rsquo;ll call the <code>delete_profile_media</code> method in my <code>before_save</code> hook.</p>

<p>If deleting data is something that scares you (or if you&rsquo;re a fan of the <code>acts_as_paranoid</code> gem) there&rsquo;s also another option. You can just preserve your files along with your &ldquo;soft deleted&rdquo; models:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
    has_attached_file :profile_media, {
        preserve_files: "true",
    }
end
</code></pre>

<p>This extra line prevents any data in our <code>profile_media</code> columns from being completely erased when the model is soft deleted. The good news here is that when the object is restored later on, our images will be too! And that is just as good of a reason as any to celebrate!</p>

<iframe src="//giphy.com/embed/osMIREQbo3s2c" width="480" height="255" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>paperclip</code> gem really needs only two things to function properly: a <code>has_attached_file :attachment</code> in the model and an <code>attachment_file_name</code> column in the database. The <code>attachment_content_type</code> is only required if you&rsquo;re going to use content type validation.</li>
<li>If you want to see some <code>paperclip</code> in action, check out this <a href="http://railscasts.com/episodes/134-paperclip">RailsCast</a> that covers all the basics.</li>
<li>Want to dive into the <code>paperclip</code> source code? Go for it! Perhaps you can start by checking out their well-documented <a href="http://www.rubydoc.info/gems/paperclip/Paperclip/ClassMethods">class methods</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[All the Columns Fit to Index: Unique + Compound Indexing]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/07/21/all-the-columns-fit-to-index-unique-plus-compound-indexing/"/>
    <updated>2015-07-21T08:02:04-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/07/21/all-the-columns-fit-to-index-unique-plus-compound-indexing</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/MMEfo9QQgKInK" width="480" height="269" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Database indexing: the last frontier. Well, okay, not the <em>last</em> frontier perse&hellip;more like the frontier that I&rsquo;ve been reading about a lot recently. While learning about writing about <a href="http://vaidehijoshi.github.io/blog/2015/07/14/writing-smart-migrations-references-reversible-and-indexes/">smart and efficient</a> migrations, I stumbled upon a rabbit hole that I had to restrain myself from going down: the rabbit hole of <strong>database indexing</strong>. But this week, I allowed myself to explore and learn some more about how indexes work.</p>

<p>As the cat gif above might already suggest, an index in a database is much like an index in a book: a place where you can quickly look up the exact information that you need. We already know that indexing can be super helpful when it comes to application performance. Using indexes forces our database to use integers to look up rows &ndash; which are just representations of items or objects &ndash; in our database. The reason that they&rsquo;re so efficient is because looking up something in a database is both fast <em>and</em> cheap if we use an integer to do it (using a string on the other hand, is much, much slower and more expensive). By implementing a simple index, we can speed up a single query by seconds!</p>

<p>But it turns out that even a single index can be complicated. And that&rsquo;s because there are so many kinds of indexes available for us to use. In fact, there&rsquo;s a whole <em>world</em> of different types of database indexes out there. Of course, knowing the options available to us when it comes to database indexing is just half the battle; the other half is knowing when it&rsquo;s the right time to use all these different types of indexes. The best way to learn is by playing around with some indexing ourselves &ndash; so let&rsquo;s dive in!</p>

<!--more-->


<h2>Indexes All Around Us</h2>

<p>The most common index type that we have dealt with so far are <strong>single-column</strong> indexes. They work pretty much exactly as their name would suggest: they create an index on a specific column of a database. So far, almost all of the indexes we&rsquo;ve generated have been indexed on a specific single column of a table.</p>

<iframe src="//giphy.com/embed/bjDq7WCjstuPS" width="480" height="329" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>Let&rsquo;s think for a second: when we use a PostgreSQL to run a migration, the one column that always gets generated is an <code>id</code> column, which is unique for every row in that database, even if the object is deleted. If we think about it, that&rsquo;s an example of an index. In fact, PostgreSQL automatically generates an index for the primary key of any table, and always generates a new, unique key for each new row in the database.</p>

<p>One of the very first migrations we ran for our Bookstore application looked like this:</p>

<pre><code class="ruby">class CreateBooks &lt; ActiveRecord::Migration
  def change
    create_table :books do |t|
      t.string :title
    end 
  end
end
</code></pre>

<p>and generated a tiny little table, which didn&rsquo;t have all that much &ndash; but it did have an index as its <code>id</code> primary key column, which we can confirm by looking at our <code>structure.sql</code> file:</p>

<pre><code class="sql">CREATE TABLE books (
    id integer NOT NULL,
    title character varying(255)
)
</code></pre>

<p>The advantage of having an <code>id integer</code> column here is that our database can very easily look up a specific row in our <code>books</code> table by using the index. We can also see that there&rsquo;s automatically a <code>NOT NULL</code> validation that prevents any row in the database from being created <em>without</em> an <code>id</code>. This isn&rsquo;t something that we wrote &ndash; this is something that Postgres does automatically! And although it might seem pretty obvious and a bit simple right now, it&rsquo;s important to note &ndash; especially since indexes can get rather complicated, rather fast.</p>

<p>Another form of indexing that we&rsquo;ve played around with is adding our own indexes to <code>has_many</code> and <code>belongs_to</code> associations, often by using <code>references</code> to alias those relationships:</p>

<pre><code class="ruby">class AddGenreToBooks &lt; ActiveRecord::Migration
  def change
    add_reference :books, :genre, index: true
  end
end
</code></pre>

<p>And if we already have a relationship set up, we can just write a quick migration to manually add an index to our <code>books</code> table:</p>

<pre><code class="ruby">class AddGenreIndexToBooks &lt; ActiveRecord::Migration
  def change
    add_index :books, :genre
  end
end
</code></pre>

<p>This migration adds an index on <code>genre_id</code> column within our <code>books</code> table, which makes it very quick and easy to look up a book by it&rsquo;s corresponding genre. This is still only a single-column, or <strong>independent index</strong>, because it is only dealing with a single column within a database table. But if there are single indexes, that must mean that the idea of &ldquo;multiple&rdquo; indexes is also must be a real thing, right?</p>

<h2>Two Indexes Are (Sometimes) Better Than One</h2>

<p>Indexes are easy to add; what&rsquo;s harder is knowing what <em>kind</em> of index to add. Sometimes, a single-column index does the trick. But it&rsquo;s also possible that it&rsquo;s quite the right tool for the job.</p>

<p>Let&rsquo;s say that we are doing an overhaul on our Bookstore application and scaling for size. We&rsquo;ve decided that in addition to selling our own curated selection of books, we&rsquo;re also going to allow new, lesser-known bookstores to sign up for our service and sell their own books. Our vendors will have their own admin panel (think vendor portal), and the bookstore staff will have a separate admin panel from which to monitor all the sales across all the vendors who are signed up for our service.</p>

<p>All of our admins (staff and vendors) have an <code>user_id</code>. But, our staff and our vendors aren&rsquo;t just simple users of our application &ndash; they have special roles, and need access to specific pages, depending on their roles. Our admins also have an <code>admin_id</code> in addition to their base <code>user_ids</code>, while our vendors have a <code>vendor_id</code>, based on their roles as smaller-scale booksellers who will be using our software to sell their products.</p>

<p>Within our staff admin panel, we want our admins to be able to quickly view all sales across our signed up vendors, in addition to one specific vendors sales reports. If an admin logs into the admin panel and clicks on a specific bookseller, the panel should immediately load all the information pertinent to that specific vendor.</p>

<p>The first thing we might think to do is what we already know &ndash; namely, add an index on the columns we know we want to look up:</p>

<pre><code class="ruby">class AddIndexesToUsers &lt; ActiveRecord::Migration
    def change
        add_index :users
        add_index :users, :vendor_id
    end
end
</code></pre>

<p>However, these indexes don&rsquo;t actually do what we think they&rsquo;ll do. This adds an index to the primary key column on our <code>users</code> table, which will allow us to quickly look up a single <code>User</code>. It also adds an index to our <code>vendor_id</code> column, and allows us to look up a <code>User</code> instance based on its <code>vendor_id</code>, if it has one.</p>

<p>But here&rsquo;s the rub: we&rsquo;re only adding a single index in this migration. That is to say, we&rsquo;re adding an index on our <code>user_ids</code>, and we&rsquo;re adding an index on our <code>vendor_ids</code>. What we <em>really</em> need is an index that first sorts our data by <code>user_id</code>, and then filters down to the users that match our <code>vendor_id</code>.</p>

<iframe src="//giphy.com/embed/PUBxelwT57jsQ" width="480" height="332" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>Don&rsquo;t worry, this is totally doable! We just need to index <em>two</em> columns, instead of one. Actually, there&rsquo;s a perfect name &ndash; or set of names &ndash; for what we need: a <strong>compound index</strong> (aka a concatenated, multi-column, composite or combined index).</p>

<p>Ultimately, we want our database to execute a query that looks something like this:</p>

<pre><code class="sql">SELECT * FROM users WHERE user_id = ? AND vendor_id = ?;
</code></pre>

<p>so that we can avoid writing a SQL statement in our <code>UsersController</code> like we have now (ew, let&rsquo;s not do that):</p>

<pre><code>class UsersController &lt; ApplicationController
    def sign_in
        @user = User.where("user_id = ? AND vendor_id = ?", params[:user_id], params[:vendor_id])
        # authenticate and sign in the vendor
    end
end
</code></pre>

<p>So how are we going to manage all of this, you might ask? Well, pretty easily. Writing a compound index is almost as easy as writing a single-column index:</p>

<pre><code class="ruby">class AddIndexesToUsers &lt; ActiveRecord::Migration
    def change
        add_index :users, [:id, vendor_id]
    end
end
</code></pre>

<p>And that&rsquo;s it! But what&rsquo;s happening, exactly? Well, we&rsquo;re still creating a single index, but we&rsquo;re doing it across multiple columns. The first column (<code>user_id</code>) is the primary &ldquo;sort criterion&rdquo;, and the second column (<code>vendor_id</code>) is the secondary &ldquo;sort criterion&rdquo;. The important thing to remember here is that <em>order matters</em>. We&rsquo;ll only ever look up a vendor by <code>user_id</code> first, and then by <code>vendor_id</code>. This makes sense if you think about it, since we&rsquo;ll first want to authenticate by the user currently logged in (in other words, using the current session).</p>

<p>I really liked the way that Markus Winand describes two-column indexing on <a href="http://use-the-index-luke.com/sql/where-clause/the-equals-operator/concatenated-keys">his blog</a>:</p>

<blockquote><p>The ordering of a two-column index is therefore like the ordering of a telephone directory: it is first sorted by surname, then by first name. That means that a two-column index does not support searching on the second column alone; that would be like searching a telephone directory by first name.</p></blockquote>

<p>Compound indexes are super cool because they let you quickly look up the first field/column in a database, and then quickly look up <em>another</em> field/column in a database &ndash; but only within the records that were returned by the first index. At the end of the query, you&rsquo;ll only have rows that satisfy parts of that <code>AND</code> SQL query we wrote earlier!</p>

<h2>Indexes Like None Other</h2>

<p>I think we can all agree that indexing can help us narrow down a lot of rows in a database and is probably the coolest filtration system ever invented by and for developers. But that&rsquo;s not all that indexes can do! They can also prevent some pretty sticky situations that we often overlook.</p>

<p>By now, something that we&rsquo;re all familiar with is validations. One of the most common kinds of validations that we see in our Rails models all of the time is <code>uniqueness:true</code>, or <code>validates_uniqueness_of</code>. However, here&rsquo;s something we don&rsquo;t always think about (or perhaps never even realized): these validations only occur at the the ActiveRecord level. And this fact can pose some problems.</p>

<p>Imagine two vendors are signing up to use our Bookstore app. They both want to name their store the same thing, but we definitely don&rsquo;t want that to happen. So we add this line to our <code>Users</code> table:</p>

<pre><code class="ruby">module User
    class Vendor &lt; ActiveRecord::Base
      validates :store_name, presence: true, uniqueness: true
    end
end
</code></pre>

<p>Cool, so this is fine then, right? Wrong! Because we just sent out an email blast telling all these potential vendors that they could sign up for a free 60-day trial. Now, all of a sudden, tons of vendors are signing up! And it just so happens, that two of them signed up at almost the exact same second, and wanted to use the same name: <code>Super Cool Books</code> (I know, I know, what are the chances, right?!)</p>

<p>Here&rsquo;s the problem: the moment that both of these potential vendors signed up for our service, no row in our polymorphic <code>vendors</code> database existed with a <code>store_name</code> that corresponded to the string, <code>Super Cool Books</code>. So what did ActiveRecord do? It created a new row! Actually&hellip;it created <em>two</em> new rows. At almost the exact same time. With the <em>exact same store name</em>. Uh oh.</p>

<p>So how can we fix this? We need to take our <code>uniqueness</code> validation down another level. In fact, we need to make our <em>database</em> responsible for validating uniqueness. And we can do this by adding a <strong>unique index</strong>.</p>

<p>Again, this is pretty easy. We just need to add a <code>unique: true</code> constraint on the column that we want to be able to index:</p>

<pre><code class="ruby">class AddStoreNameIndexToVendors
  def change
    add_index :vendors, :store_name, unique: true
  end
end
</code></pre>

<p>Now, when two vendors try to sign up to be called <code>Super Cool Books</code>, only one will actually be able to have that name. As soon as an unique index is created on the <code>store_name</code> column of our <code>vendors</code> database, any other record that tries to be created with that index will raise a <code>ActiveRecord::RecordNotUnique</code> error. This is going to be super helpful to us in avoiding inconsistant data, particularly when we know that a lot of data is going to be created at once.</p>

<p>The world of indexes is mostly uncharted territory. It&rsquo;s also important to keep in mind that you never want to create <em>too</em> many indexes, and only ones that we actually need, since they will <a href="http://www.rubyonrails365.com/low-hanging-fruits-for-better-sql-performance-in-rails/">slow down</a> the &ldquo;write&rdquo; time to the database (whenever we use SQL commands like <code>UPDATE</code> or <code>CREATE</code>, for example). But that doesn&rsquo;t mean we can&rsquo;t learn about the different kinds of indexes that exist and be completely wowed at how amazing databases are. See, this cat is completely floored &ndash; and quite frankly, I am too:</p>

<iframe src="//giphy.com/embed/vSSdLSLbGIXio" width="480" height="453" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>There are three main types of indexing: <em>single-column</em>, <em>compound</em>, and <em>unique</em> indexes. Compound indexes create an index on two ore more columns in a database, while unique indexes create a restraint on a single column index.</li>
<li>This <a href="http://stackoverflow.com/a/1049392">StackOverflow answer</a> is the best explanation of how compound indexes actually work in terms of running a query. If you&rsquo;re still confused, give it a read!</li>
<li>Uniqueness validations are super cool! Read more about them over <a href="https://robots.thoughtbot.com/the-perils-of-uniqueness-validations">here</a>, and check out some real-life examples of how to use them <a href="http://nyonura.com/blog/2014/Partial-Indexes-with-PostgreSQL-and-Rails/">here</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing Smart Migrations: References, Reversible, and Indexes]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/07/14/writing-smart-migrations-references-reversible-and-indexes/"/>
    <updated>2015-07-14T08:47:19-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/07/14/writing-smart-migrations-references-reversible-and-indexes</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/SUtPZfyDenHoY" width="480" height="270" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>All it takes is a single feature to make you realize how well &ndash; or perhaps not so well &ndash; you&rsquo;ve written your application. Depending on if you&rsquo;ve done a good job of separating concerns, abstracting and encapsulating bits of functionality into cohesive code, and just generally not repeating yourself&hellip;well, you&rsquo;ll probably be way more enthusiastic about adding a huge new feature to an already massive application. But if you haven&rsquo;t done any of those things&hellip;well, you might find yourself doing a massive rewrite of your codebase just to implement a single feature.</p>

<p>Luckily, the application I started adding a feature to last week is pretty well-built, which makes it flexible enough to add new functionality relatively easily. Yet even the most well-thought-out applications need to be teased apart and glued back together during the course of their lives. Often times, a big part of building out a new feature is restructuring the architecture of your application. When you&rsquo;re working with larger code bases (legacy code in particular), that can be the most daunting task. But a lot of the intimidation of that begins to dissipate once you know how to go about restructuring a schema which already exists without breaking all the the things.</p>

<p>The first step in this process is writing migrations to change how the objects in your application and database relate to one another. Of course, knowing how to write the proper migration to suit your needs is just half the battle; the other half is writing a migration that makes object lookup in your database efficient and super fast. Even though I&rsquo;ve <a href="http://vaidehijoshi.github.io/blog/2015/05/19/the-secret-life-of-your-database-part-1-migrations/">written about migrations</a> before, I&rsquo;m learning that there&rsquo;s always so much more to know. So, let&rsquo;s get learning!</p>

<!--more-->


<h2>Referencing Your References</h2>

<p>A really quick way to clean up our code is by changing the way that we create associations between objects from within our migrations. One feature we&rsquo;ll want to add is to have our <code>Book</code>s belong to a <code>Genre</code>. So far, we&rsquo;ve categorized our <code>Author</code>s by genre, but we&rsquo;ll want to be able to sort and organize our <code>Book</code> objects in a similar way.</p>

<p>We often use <code>belongs_to</code> and <code>has_many</code> inside of our migrations, which is totally valid. But in this case, it probably makes more sense to use something called <code>references</code>. According to the Rails <a href="https://github.com/rails/rails/blob/88aa2efd692619e87eee88dfc48d608bea9bcdb4/activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb#L421">source code</a>, <code>references</code> is just an alias of <code>belongs_to</code>. But, a <code>Book</code> doesn&rsquo;t really &ldquo;belong to&rdquo; a <code>Genre</code>, it&rsquo;s more that it should be able to &ldquo;reference&rdquo; the genre that it&rsquo;s associated with. We can add a reference fairly easily just like this:</p>

<pre><code class="ruby">class AddGenreToBooks &lt; ActiveRecord::Migration
  def change
    add_reference :books, :genre
  end
end
</code></pre>

<p>This will create a <code>genre_id</code> column inside of our <code>Books</code> table. We could also have done this initially inside of a <code>change</code> method, and written something like <code>t.references(:genre)</code> inside of our migration method. We also have the option to add a <code>type</code>, and specify whether the reference is a <code>polymorphic</code> association or not, as explained by the <a href="http://apidock.com/rails/ActiveRecord/ConnectionAdapters/Table/references">Rails API</a>:</p>

<blockquote><p><code>references</code>: Adds a reference. Optionally adds a type column, if :polymorphic option is provided. The reference column will be an integer by default, the :type option can be used to specify a different type. A foreign key will be created if a foreign_key option is passed.</p></blockquote>

<p>Using <code>references</code> instead of a typical <code>has_many</code> and <code>belongs_to</code> gives us a bit more flexibility moving forward, especially if we know that we&rsquo;ll be adding different types of associations in the long run.</p>

<h2>Reverse, reverse!</h2>

<p>One big feature we want to add to our Bookstore app is giving our <code>Books</code> a rating. There&rsquo;ll be some slightly complicated logic on the backend for this feature to actually work, since we&rsquo;ll need to update a <code>Book</code>&rsquo;s rating every single time a <code>User</code> rates it. But, let&rsquo;s not worry too much about how that logic will be implemented just yet. Instead, it&rsquo;ll be more helpful to break down this larger problem into a few smaller, bite-sized pieces.</p>

<p>First things first: do what we know. And we know that we&rsquo;ll need to give every <code>Book</code> a <code>rating</code> attribute. We&rsquo;ll want this to use Ruby BigDecimal, so we&rsquo;ll specify that in our migration. This migration will start out pretty simple, since all we want to do is just give our <code>Book</code>s a new attribute:</p>

<pre><code class="ruby">class AddRatingColumnToBooks &lt; ActiveRecord::Migration
  def change
    add_column :books, :rating, :decimal
  end
end
</code></pre>

<p>If we run <code>rake db:migrate</code>, and then open up our console, we can very quickly check that this added a column, just as we expected:</p>

<pre><code>♥ rails c
&gt; Book.all.pluck(:rating)
# =&gt; [nil, nil, nil, nil, nil, nil]
</code></pre>

<p>Uh oh, that&rsquo;s not so great. We really don&rsquo;t want all of the <code>Book</code>s that are <em>already</em> inside of our database to have <code>nil</code> values for their <code>rating</code>. Honestly, a more accurate representation of their <code>rating</code> would just be <code>0</code>, since none of our <code>User</code>s have actually given these products a rating yet.</p>

<p>What would be really nice is if we could do <em>two</em> things within this single migration: give our <code>Books</code> a <code>rating</code> column (done!), and set all of our pre-existing <code>Books</code> to have a <code>rating</code> of <code>0</code>. How can we do that? Well, by using <code>reversible</code>, of course!</p>

<p>We already know that we can use the <code>up</code> and <code>down</code> methods to migrate &ldquo;up&rdquo; and &ldquo;down&rdquo; the history or &ldquo;life&rdquo; of our database. But there&rsquo;s also another handy method that can help us out here, called <code>reversible</code>. Here&rsquo;s what the <a href="http://edgeguides.rubyonrails.org/active_record_migrations.html">Rails Guides</a> say about <code>reversible</code>:</p>

<blockquote><p>Complex migrations may require processing that Active Record doesn&rsquo;t know how to reverse. You can use <code>reversible</code> to specify what to do when running a migration and what else to do when reverting it. Using <code>reversible</code> will ensure that the instructions are executed in the right order too.</p></blockquote>

<iframe src="//giphy.com/embed/11EAsNbNMMcO3u" width="480" height="148" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>So how can we implement <code>reversible</code> here? Well, to start, we need a reversible block, which takes a direction. If you&rsquo;re thinking that the direction should be <code>up</code> or <code>down</code>, you&rsquo;d be right! Since we&rsquo;re only adding a column in this migration, we don&rsquo;t need to worry about a <code>down</code> method, since migrating down will automatically just drop the <code>rating</code> column that we&rsquo;re adding. What we do need to do is make sure that when we migrate <em>up</em>, we&rsquo;re also updating our current <code>Book</code> records. We can do that by specifying the <code>up</code> method on our direction, and then pass a block to <code>reversible</code> telling it what to do:</p>

<pre><code class="ruby">class AddRatingColumnToBooks &lt; ActiveRecord::Migration
  def change
    add_column :books, :rating, :decimal

    reversible do |direction|
      direction.up { Book.update_all(rating: 0.0) }
    end
  end
end
</code></pre>

<p>Cool, this migration seems great. Now, we&rsquo;re not only adding a <code>rating</code> column to our <code>Books</code> table, but we&rsquo;re also updating all of our pre-existing <code>Book</code> objects so that they have some default value for their <code>rating</code>. Nothing about this should break ever, right?</p>

<p>Wrong! Why? Because we can rename anything we want at any time&hellip;and then forget to change all of our files. When we decide to start selling music or movies and go full-on Amazon in our application, we&rsquo;ll probably want to rename our <code>Books</code> table to something like <code>Product</code> or <code>Item</code>. We&rsquo;ll create a new migration to rename our table, change our model names, and everything will be fine. Except for one teeny, tiny little problem: when we decide to deploy to Heroku and try to run <code>rake db:migrate</code>, everything will explode. And why might that happen? Well, because we renamed our table, and now we&rsquo;re trying to run a migration on a <code>Books</code> table for a <code>Book</code> model, which, at this moment in time, <em>doesn&rsquo;t even exist</em>.</p>

<p>So, how can we fix this? Well, we can actually define a <code>Book</code> model inside of this very migration file. And, we can do it all in a single line:</p>

<pre><code class="ruby">class AddRatingColumnToBooks &lt; ActiveRecord::Migration
  class Book &lt; ActiveRecord::Base; end

  def change
    add_column :books, :rating, :decimal

    reversible do |direction|
      direction.up { Book.update_all(rating: 0.0) }
    end
  end
end
</code></pre>

<p>Nice! Now, even if we forget to rename our old migrations, we can be sure that ActiveRecord won&rsquo;t complain if it can&rsquo;t find a <code>Book</code> model when this migration tries to run. In fact, it will <em>always</em> find a model no matter what we might rename our model or table to in the future because we&rsquo;ve defined an empty <code>Book</code> class inside of this migration file. We can be sure that this is the case because Ruby will first look for a class declaration inside of a file before searching anywhere else!</p>

<h2>Index All The Things</h2>

<p>Okay, time to get efficient. Let&rsquo;s look back at our first migration, where we were adding <code>Genre</code>s to <code>Book</code>s:</p>

<pre><code class="ruby">class AddGenreToBooks &lt; ActiveRecord::Migration
  def change
    add_reference :books, :genre
  end
end
</code></pre>

<p>This is fine, but there&rsquo;s one slight problem here: what if we only have a few <code>Genre</code>s, but a ton of <code>Book</code>s? When we want to run a method like <code>where</code> or <code>sort_by</code>, how will our application handle this? Well, without even testing out our query, we know it&rsquo;s not going to go so well. And why not? Because, as it stands, our application will have to sort through <em>every single one</em> of our books to find the ones that match our query. And after a couple hundred or thousands of books, this is going to massively slow down our application.</p>

<p>But, we&rsquo;re smart enough to foresee that problem! We&rsquo;ll outsmart our application from the get-go, and just write a smart migration to begin with:</p>

<pre><code class="ruby">class AddGenreToBooks &lt; ActiveRecord::Migration
  def change
    add_reference :books, :genre, index: true
  end
end
</code></pre>

<p>If we open up our <code>db/structure.sql</code>, we&rsquo;ll see this:</p>

<pre><code class="sql">CREATE TABLE books (
  rating numeric(10,2),
  genre_id integer
);

CREATE INDEX index_books_on_genre_id ON books USING btree (genre_id);
</code></pre>

<p>This created an <code>index</code> on our <code>Books</code> table, which is referenced to <code>Genre</code>. This is pretty amazing, because it means that our table will now use integers (not strings or any other data type) to look up an item on our table. Integer lookup is the cheapest and fastest way to look up an item in a database, which means that it&rsquo;s going to speed up our database like crazy!</p>

<p>We also could have just written a completely new migraiton for this as well, which would implement the <code>add_index</code> method:</p>

<pre><code class="ruby">class AddGenreIndexToBooks &lt; ActiveRecord::Migration
  def change
    add_index(:books, :genre)
  end
end
</code></pre>

<p>We could also use the <code>add_index</code> method to create unique indexes, or named indexes, as highlighted in the <a href="http://apidock.com/rails/ActiveRecord/ConnectionAdapters/SchemaStatements/add_index">documentation</a>. Sometimes, it&rsquo;s actually <a href="http://makandracards.com/makandra/32353-psa-index-true-in-rails-migrations-does-not-work-as-you-d-expect">safer</a> to use the <code>add_index</code> method rather than <code>index: true</code>.</p>

<p>Now our migrations are not just clear and concise, but they&rsquo;re also helping our application run smoother and quicker in the process. Writing smart migrations can not only save us a lot of time down the road, but they make feature-writing a lot more fun! Not as fun as running wildly through the safari, but hey &ndash; it&rsquo;s a close second:</p>

<iframe src="//giphy.com/embed/cyrx5VQ8PiWoE" width="480" height="270" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>Using <code>references</code> in a migration is the same as <code>belongs_to</code>, but can make your code more clear. The <code>reversible</code> method is great for specifying how your migration should handle a reverse migration. Indexes are an easy way of adding an iteger column to speed up database queries.</li>
<li>Need to see another example of manipulating data from within a migraiton? This <a href="http://railsguides.net/change-data-in-migrations-like-a-boss/">blog post</a> walks through some great examples using the <code>up</code> and <code>down</code> methods.</li>
<li>Check out this great <a href="https://www.reinteractive.net/posts/178-reversible-migrations-with-active-record">post</a> on how to implement <code>reversible</code> in different situations!</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Taskmanaging Your App, Part 2: Service Objects]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/07/07/taskmanaging-your-app-part-2-service-objects/"/>
    <updated>2015-07-07T08:28:40-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/07/07/taskmanaging-your-app-part-2-service-objects</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/xTiTnqpyEF0HbAosfe" width="480" height="480" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Everything seems to perform a service these days. We&rsquo;ve got infrastructure as a service, platforms as a service, and even software as a service. But the servicing doesn&rsquo;t end there: even our software applications often need specific services provided to them. But how, exactly?</p>

<p>Well, if you&rsquo;ve ever opened up a Rails application and peeked inside of the main directories, you can get a good understanding of what exactly the application is doing. Pry into the models directory, and you&rsquo;ll see the kinds of objects the app transforms and manipulates. Open the controllers directory, and you&rsquo;ll see the different <em>CRUD</em> (<em>create, read, update, delete</em>) operations that are permitted by the application, and the various ways of handling requests and responses by the server.</p>

<p>Seems pretty straightforward, right? Except until your application starts to swell in size, and then you&rsquo;re packing a ton of functionality into these two directories. We at least <em>try</em> and keep our models fat, and our controllers skinny. It would be great if just our trying to do that was successful all the time. Yet that&rsquo;s not usually what happens. Instead, things start to get messy, code starts to leak out all over the place, and we all just want to give up and go home. But we don&rsquo;t have to give up just yet! There&rsquo;s one trick that we haven&rsquo;t tried yet, and it&rsquo;s guaranteed to make our lives easier: utilizing <strong>service objects</strong>. Or, in other words, servicing parts of our application and separating our code out into more appropriate places.</p>

<!--more-->


<h2>Separating All Dem Concerns</h2>

<p>Last week, we started off by learning about <a href="http://vaidehijoshi.github.io/blog/2015/06/30/taskmanaging-your-app-part-1-using-rake/">rake tasks</a>, which turned out be an awesome way of encapsulating a specific type of functionality into a single file. But when we started writing a <code>rake data:stage</code> task (which stages our database with some sample <code>Book</code> objects), we noticed that we were making a single rake task responsible for multiple things.</p>

<p>We&rsquo;ve got a similar dilemma on our hands again this week. We have a <code>WishLists Controller</code>, which should be responsible for rendering all of the <code>Wish Lists</code> associated with a <code>User</code>. But here&rsquo;s the kicker: it should work with the Goodreads API to pull in the books that the User wants to read, and add that to their <code>Wish List</code>. Here&rsquo;s our current, clean and beautiful controller:</p>

<pre><code class="ruby">class WishListsController &lt; ApplicationController
    def index
        if user_signed_in?
            render json: current_user.wish_lists
        else
            render json: { wish_lists: [] }
        end
    end
end
</code></pre>

<p>It really pains me to ruin this controller with all the logic we&rsquo;re about to throw in there. Let&rsquo;s start writing it and see how it might look&hellip;</p>

<pre><code class="ruby">class WishListsController &lt; ApplicationController
    def index
        if user_signed_in?
            client = Goodreads::Client.new(api_key: 'OUR_API_KEY', 
            api_secret: 'OUR_SECRET_TOKEN')
            shelf = client.shelf(current_user.id, 'to-read')
            books = shelf.books.each do |book|
                # Creates an ActiveRecord instance
                # for all the books on the shelf 
                # and returns a JSON object.
            end

            render json: books
        else
            render json: { wish_lists: [] }
        end
    end
end
</code></pre>

<p>NOPE. Nope nope nope. This is already way too much for a single controller action. And all the requests between our application and the Goodreads API really shouldn&rsquo;t be up publicly available &ndash; they need to be private methods. And what if something goes wrong during those requests? We aren&rsquo;t handling those errors at all! And honestly, it really shouldn&rsquo;t be the <code>index</code> action&rsquo;s job to send a request, handle the response, create and persist book objects, and then, on top of <em>all</em> of that, render the <code>books</code> of the <code>Wish List</code>! This is not the right path.</p>

<iframe src="//giphy.com/embed/srATnRQXsTfDG" width="480" height="269" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>What we really need to do is <strong>separate our concerns</strong>. Or, in other words, we need to divide and conquer our code. We know that the <code>index</code> action of our <code>WishLists Controller</code> shouldn&rsquo;t be responsible for all this work. So, let&rsquo;s delegate that task to someone else. In fact, let&rsquo;s create an object who&rsquo;s sole concern and single responsibility is going to be dealing importing books from the Goodreads API, persisting them to the database, and then returning an array of books to read in the form of a wish list.</p>

<p>This object doesn&rsquo;t need to do anything more than that. It&rsquo;s existence is purely to help us &ndash; and help the rest of our application &ndash; out. This object is just going to provide a service. In fact, we might even go so far as to call it a <em>service object</em> (see what I did there?).</p>

<h2>Servicing Our Application</h2>

<p>So, if this service object doesn&rsquo;t have any other responsibilities except for getting, creating, and persisting <code>books</code> to a <code>wish_list</code>, we have to ask ourselves: do we really need this object to stay around? Well, not really, no. All we really want is for this object to show up when we need it to, do it&rsquo;s job, and then conveniently disappear. This means that we don&rsquo;t need to make it an ActiveRecord object; instead, let&rsquo;s make it a Plain Old Ruby Object (remember those?).</p>

<p>We can start by either creating a <code>/services</code> directory on the top level and saving our <code>goodreads_importer.rb</code> service in there, or we can namespace it inside of our <code>/models</code> directory as <code>/goodreads/importer.rb</code>. Once we&rsquo;ve made our file, we can pretty much use the same code we started writing before, and abstract it out into this service object:</p>

<pre><code class="ruby">class GoodreadsImporter
    def initialize(options = {})
        @options = options
    end

    private 
    def client
        @client ||= Goodreads::Client.new(api_key: 
        'OUR_API_KEY', api_secret: 'OUR_SECRET_TOKEN')
    end

    def shelf(id, shelf_name)
        @shelf ||= client.shelf(current_user.id, shelf_name)
    end

    def books
        @books ||= shelf.books.each do |book|
            # Creates an ActiveRecord instance
            # for all the books on the shelf 
            # and returns a JSON object.
        end
    end
end
</code></pre>

<p>So far, we&rsquo;re just initializing our <code>Importer</code> with some options. Notice that we&rsquo;re <em>not</em> inheriting from <code>ActiveRecord::Base</code>! This is just a plain Ruby class, like the ones we used to make when we were first learning about things like <a href="http://vaidehijoshi.github.io/blog/2014/10/16/class-inheritance-part-1/">inheritance</a>.</p>

<p>We&rsquo;ve also abstracted out those API calls (<code>Client.new</code>) and the methods provided to us by the Goodreads API (<code>client.shelf</code>, <code>shelf.books</code>) into private methods that are only going to be accessible by this service object. Not only is this important because we don&rsquo;t want any other person or part of this application to be able to <em>access</em> these endpoints, but this is also going to be super helpful to us down the road. Now, if something goes wrong, we can narrow down exactly <em>where</em> in the process our application broke. And, we can write tests for specific parts of this service object, just to double and triple check that everything is working exactly as we expect it to.</p>

<p>Next, we&rsquo;ll want to actually have some point of entry for this object. In other words, we need a way to actually use this object &ndash; some way to access all those private methods that we wrote just above. A pretty cool convention for a service object&rsquo;s point of entry is a <code>call</code> method. The idea here is that you &ldquo;call&rdquo; upon the service object to show up, perform its job, and then don&rsquo;t worry about it after it&rsquo;s done.</p>

<p>This is what ours might look like:</p>

<pre><code class="ruby">class GoodreadsImporter
    def initialize(options = {})
        @options = options
    end

    def call
        books.each do |b|
            book = Book.where(id: b[:id]).first_or_initialize
            book.update(b)
      end
    end

    private 
    def client
        @client ||= Goodreads::Client.new(api_key: 
        'OUR_API_KEY', api_secret: 'OUR_SECRET_TOKEN')
    end

    def shelf(id, shelf_name)
        @shelf ||= client.shelf(current_user.id, shelf_name)
    end

    def books
        @books ||= shelf.books.each do |book|
            # Creates an ActiveRecord instance
            # for all the books on the shelf 
            # and returns a JSON object.
        end
    end
end
</code></pre>

<p>Pretty simple, right? Okay, so now we have this fantastic little service object. But it doesn&rsquo;t actually exist in our application yet. At no point are we &ldquo;calling&rdquo; upon our service! Time to fix that.</p>

<h2>Objects To Make Our Lives Easier</h2>

<p>Now that we have a service that we can rely upon, all we need to do is plug it into our application. We could do this inside of our <code>WishLists Controller</code>, just as we originally planned:</p>

<pre><code class="ruby">class WishListsController &lt; ApplicationController
    def index
        if user_signed_in?
            render json: current_user.wish_lists 
            if GoodreadsImporter.new.call(current_user.id, 'to-read')
        else
            render json: { wish_lists: [] }
        end
    end
end
</code></pre>

<p>Or we could also stick it into the rake task we were writing last week:</p>

<pre><code class="ruby">namespace :data do
    desc "Stages the environment with data from Goodreads."
    task "goodreads:import" =&gt; "environment" do
      options = {}
      GoodreadsImporter.new(options).call
    end
end
</code></pre>

<p>And now in development, we can just run <code>rake data:goodreads:import</code> to call upon our service object. Writing tests for this would be super easy as well, since we&rsquo;d literally only have to test this one Ruby class to make sure that the service object wasn&rsquo;t broken.</p>

<p>The coolest thing about service objects is that they exist on their own. They don&rsquo;t really need to know about what&rsquo;s going on around them (or even that they exist in the context of a giant framework called Rails!) You can just rely on pure Ruby code to make them work, and they&rsquo;ll do whatever they&rsquo;re supposed to do, whenever you need them to do it. I really liked <a href="http://blog.arkency.com/2013/09/services-what-they-are-and-why-we-need-them/">this blog post&rsquo;s</a> explanation of how they should work:</p>

<blockquote><p>Rails has multiple entry points. Every controller action in Rails is the entry point! Additionally, it handles a lot of responsibilities (parsing user input, routing logic [like redirects], logging, rendering… ouch!). That’s where service objects comes to play. Service objects encapsulates single process of our business. They take all collaborators (database, logging, external adapters like Facebook, user parameters) and performs a given process. Services belongs to our domain - They shouldn’t know they’re within Rails or web app!</p></blockquote>

<p>Even though it might seem like a lot of extra work in the moment, service objects can save you so much time and pain in the long run. And if you think about it, just like we need software as a service, our own code sometimes needs a service to do things for it. Cut your code some slack and help it out by creating a service object. You&rsquo;ll probably thank yourself down the road.</p>

<p><img src="https://imgs.xkcd.com/comics/the_general_problem.png" style="display: block; margin-left: auto; margin-right: auto;"></p>

<h2>tl;dr?</h2>

<ul>
<li>Service objects are POROs that you can use to encapsulate a specific piece of functionality, and can help you separate concerns in your application.</li>
<li>Still curious about the theory behind service objects in Rails applications? Check out <a href="https://blog.engineyard.com/2014/keeping-your-rails-controllers-dry-with-services">this tutorial</a> and this super helpful <a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">post</a>, which unpacks service objects in the context of refactoring.</li>
<li>Where else can you use a service object? Well, a lot of places! This <a href="http://brewhouse.io/blog/2014/04/30/gourmet-service-objects.html">blog post</a> has a ton of examples of how to use them throughout your application.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Taskmanaging Your App, Part 1: Using Rake]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/06/30/taskmanaging-your-app-part-1-using-rake/"/>
    <updated>2015-06-30T08:49:58-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/06/30/taskmanaging-your-app-part-1-using-rake</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/uRziFAtdD6H60" width="480" height="362" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Rake tasks: we&rsquo;ve all used &lsquo;em. From migrating our database to seeding it, we run commands using <code>rake</code> all of the time! But what actually happens when you run a rake task? And where is all this stuff defined, exactly? And how do you write a customized rake task of your very own?</p>

<p>These were the questions I was asking myself last week, when I had to write a rake task to stage some data for an application I was working on. I knew exactly what my rake task was supposed to accomplish, and I had a general idea of the code that had to live inside of it. I didn&rsquo;t quite know how to write my rake task, however. And I definitely didn&rsquo;t know what was going on inside of the Ruby interpreter when it would read my yet-to-exist task.</p>

<p>So, I set out to answer some of those questions, and learned a bit about how rake works in the process. It was an interesting rabbit hole to dive down, particularly since I had never before questioned what was happening when I ran a rake command in my command line. When you&rsquo;re first starting out with code, it&rsquo;s okay to accept some of the obfuscation that is inherently a part of the abstraction of larger applications. But you should never go too long without questioning why and how a certain thing works the way that it does. And that&rsquo;s exactly what we&rsquo;ll do with our beloved rake commands.</p>

<!--more-->


<h2>Form And Function</h2>

<p>We use the <code>rake</code> command so often that it might be easy to forget that it&rsquo;s <em>actually</em> part of a gem! Most everything we use &ndash; including that little gem called <code>rails</code> &ndash; relies on the <code>rake</code> gem as a dependency. And everything we could ever want to know about <code>rake</code>&rsquo;s form and function can be found in a single place: the <code>Rakefile</code>, a top-level file that exists in any application that uses this gem to manage and run tasks of all kinds.</p>

<p>So what&rsquo;s inside of our <code>Rakefile</code> after we generate a brand new Rails application? Something that looks like this:</p>

<pre><code class="ruby"># Add your own tasks in files placed in lib/tasks ending in .rake,
# for example lib/tasks/capistrano.rake, and they will automatically be available to Rake.

require File.expand_path('../config/application', __FILE__)

Rails.application.load_tasks
</code></pre>

<p>Pretty empty, right? Except that there&rsquo;s a pretty important line in there at the end which invokes a <code>load_tasks</code> method on our application object, which is what allows rake to load tasks into our application itself. But how do we fill up this Rakefile with some awesome rake tasks? Well, if we read carefully, it seems like <code>rake</code> is telling us exactly what we need to do.</p>

<p>Let&rsquo;s start by creating a data staging task that will load some initial data into our application so that we have something to work with while in development. We&rsquo;ll create a <code>stage_data.rake</code> file nested inside of our <code>lib/tasks</code> directories. But that&rsquo;s empty too! You know what that means, don&rsquo;t you? Time to write some tasks.</p>

<h2>Managing Our Task Management</h2>

<iframe src="//giphy.com/embed/gw3woz6oWXK48iE8" width="480" height="432" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Since we&rsquo;re working within the context of a mid-size Rails application, the first thing we probably want to do is namespace our rake tasks. We can do that a namespace block:</p>

<pre><code class="ruby">namespace :data do
end
</code></pre>

<p>This is how we can break up all the tasks that are concerned with managing data. But for now, let&rsquo;s just work on writing a single task, which will stage our development environment with some sample data to help us while we&rsquo;re building out the front end later on.</p>

<p>In order to write our rake task, we really just need two things: a description and then a <code>task</code> block. We know what we want our task to do, so that&rsquo;s what we&rsquo;ll put in our description. What we write here will be mostly to help us later on, when we want to know what tasks are available to us, and what exactly they do.</p>

<p>We&rsquo;ll also want to specify any dependencies that this task might have.</p>

<p>After the <code>desc</code> term, we&rsquo;re describing what our task will do, and then setting the command that we&rsquo;ll use to run the task itself. We&rsquo;re also specifying any dependencies that this task might have. In our case, the only thing that this task <em>depends upon</em> is the application itself. So, we want to make sure that our entire Rails application is loaded before running this task:</p>

<pre><code class="ruby">namespace :data do
    desc "Stage environment with sample data."
    task stage: :environment do
    end
end
</code></pre>

<p>Interestingly, all that&rsquo;s happening here is that a method called <code>task</code> is being invoked, and the key-value pair that we provided it (<code>stage: :environment</code>) is telling <code>task</code> exactly which other methods to execute before running the subsequent task we have defined inside of the block. I like how <a href="http://tutorials.jumpstartlab.com/topics/systems/automation.html">this tutorial</a> explains what&rsquo;s going on behind the scenes:</p>

<blockquote><p>It starts with the task method which takes a hash parameter. The key will be the name of the task. The value stored under that key, here <code>:environment</code>, indicates which other Rake tasks should be run before this task is run. Think of them like dependencies. When your task depends on <code>:environment</code>, it will load your entire Rails application. If your task doesn’t actually need Rails, don’t depend on :environment and you can greatly increase startup time and decrease memory usage.</p></blockquote>

<p>Another cool thing to keep in mind is the description. We know that our task description (after the <code>desc</code>) will show up again at some point. But when, exactly? Well, it comes into play when we run the <code>rake -T</code> command, which lists out all the tasks available to our specific application:</p>

<pre><code class="ruby">♥ rake -T
rake data:stage          # Stage environment with sample data.
</code></pre>

<p>Cool! Whatever we write in our description is exactly what will be output if and when this command is run in the future. Now, how do we get this task to create some sample data every time it&rsquo;s run? Well, we&rsquo;ll want to use ActiveRecord in order to actually persist some objects to our database. There&rsquo;s a handy block method on <code>ActiveRecord::Base</code> that does exactly this:</p>

<pre><code class="ruby">namespace :data do
    desc "Stage environment with sample data."
    task stage: :environment do
        ActiveRecord::Base.transaction do
            poetry = Genre.create!(name: 'Poetry')

            POETRY_SUBGENRES = ['lyric', 'drama', 'epic']

            POETRY_SUBGENRES.each do |genre|
                SubGenre.create!(sub_genre: genre, parent_genre: poetry)
            end
        end
    end
end
</code></pre>

<p>Nice! We&rsquo;re creating a genre and some sub genres, and associating them together. We could also add in authors and books to make this task a bit more robust. And to get really fancy, we could import a csv of all this information if it lived somewhere else!</p>

<h2>Extending Our Tasks Further</h2>

<p>Now that we know how to structure our rake tasks, we can add more tasks into the very same file. In fact, we can take advantage of the namespacing that we set up early on right now! Let&rsquo;s create a <code>rake data:reset</code> task that will work almost the same as the task we wrote above. The only difference being that this task will destroy any data that was staged (or any that might be hanging around, for some strange reason).</p>

<p>We can write that task inside of our same file, inside of our namespace:</p>

<pre><code class="ruby">namespace :data do
    desc "Stage environment with sample data."
    task stage: :environment do
        # the task we just wrote lives here!
    end

    desc "Resets and clears all the sample data."
    task reset: :environment do
      ActiveRecord::Base.transaction do
        Genre.destroy_all
        SubGenre.destroy_all
      end
    end
end
</code></pre>

<p>All we&rsquo;re doing is using the handy methods that ActiveRecord gives us for free inside of the blocks we&rsquo;ve defined in our task. And now when we run <code>rake -T</code>, we&rsquo;ll see this:</p>

<pre><code class="ruby">♥ rake -T
rake data:stage          # Stage environment with sample data.
rake data:reset          # Resets and clears all the sample data.
</code></pre>

<p>Look at us! We&rsquo;re rake task writing masters! We could get even fancier and make one task <em>depend upon</em> the other. Remember how the block syntax with the <code>task</code> method works? We can use the form of that syntax to make our task function the way we want to:</p>

<pre><code class="ruby">namespace :data do
    desc "Resets and stages the environment with sample data."
    task stage: [:environment, :reset] do
        # the task we wrote lives here!
    end
end
</code></pre>

<p>Now, we&rsquo;re specifying that not only should the <code>task</code> method load the environment, but it should also run the <code>rake data:reset</code> task before running the <code>rake data:stage</code> task! This could be super useful in development, when you don&rsquo;t want to have your database filled with duplicate data.</p>

<p>Another fun thing we could do is pass in parameters to our rake task:</p>

<pre><code class="ruby">namespace :data do
  desc "Stages the environment with specific amount of sample book data."
  task create_books: [:books_to_create] :environment do
    number_of_books = args[:books_to_create]
    # Uses the books_to_create variable to
    # create the number of books we want.
  end
end
</code></pre>

<p>Now, when we call the <code>rake data:create_books[100]</code> method, we could have our rake task generate 100 books for us based on the input argument we provided it.</p>

<p>This is pretty fun, right? We could put a ton of tasks that do all sorts of application management for us, and it would be no problem. Except that it would be, and here&rsquo;s why: we never want too much logic in one single part of our application. In other words, we want to separate out what different sections of application are concerned with. We probably could abstract out a lot of what these tasks into something else (another object?), which would help keep our rake tasks nice and lean.</p>

<p>It turns out that this is a pretty common situation to run into, and not just with rake tasks! There&rsquo;s a really cool pattern that implements a special kind of object that performs a service for you so that your code can stay simple, without too much logic in it. These objects are called <em>service objects</em>, and until I saw them in some production-level code, I had never really thought about their purpose. Tune in again next week, when I&rsquo;ll dive into service objects and how they help us serparate concerns in our code. Until then, here&rsquo;s a rake-themed gif to tide you over:</p>

<iframe src="//giphy.com/embed/5xtDarAX9eDPODdPMoo" width="480" height="480" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>Rake tasks are just Ruby code written inside of a either a <code>.rake</code> file in the <code>/app/tasks</code> directory, or sometimes within a <code>Rakefile</code> itself.</li>
<li>A rake task needs a description and a <code>task</code> block. The description is what will be seen when you run <code>rake -T</code>, and the <code>task</code> block is where you&rsquo;ll write what the task actually has to do, and specify any dependencies.</li>
<li>Need to see another example of how to make a rake task? Check out this awesome <a href="http://jasonseifer.com/2010/04/06/rake-tutorial">tutorial on rake</a>, or watch <a href="http://railscasts.com/episodes/66-custom-rake-tasks">this RailsCast</a>.</li>
</ul>

]]></content>
  </entry>
  
</feed>
