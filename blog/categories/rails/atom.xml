<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-12-15T08:49:57-05:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[You've Got a Friend in Friendly_Id]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/12/15/youve-got-a-friend-in-friendly-id/"/>
    <updated>2015-12-15T08:11:15-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/12/15/youve-got-a-friend-in-friendly-id</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/13pT5ZMDTKiKJO" width="480" height="241" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>One of my favorite aspects of programming is the fact that there&rsquo;s always more than one way to do something. In fact, I think this is probably why I consider the very act of writing and building software to be a far more intutive task, rather than a merely structured, logical, and rigid pursuit. The very notion of no &ldquo;one single solution&rdquo; to solving a problem is what makes programming both a critical thinking skill, but also a creative one.</p>

<p>Let me give you an example: a few months ago, I wrote about <a href="http://vaidehijoshi.github.io/blog/2015/10/20/solutions-for-slugs-of-all-sizes-acts-as-url-plus-to-param/">using slugs</a> and the <code>acts_as_url</code> gem to create human-readable urls for an application I was working on. Rails has a handy <code>to_param</code> method that can be used in conjunction with this gem to generate a hyphen-separated string that can be used in the <code>show</code> route of a resource in place of the object&rsquo;s numeric <code>id</code>, which is both unreadable and usually doesn&rsquo;t provide any point of reference for the user. So, here we are, using slugs.</p>

<p>However, just because we did something one way initially doesn&rsquo;t mean that our way is the <em>only</em> way to do it. Actually, I am certain that there are other solutions &mdash; and some of them might actually be more flexible than our approach! This was what I realized very quickly when I recently learned about another gem that solves the same problem of slugs in a different, and rather interesting way! In fact it took what I already knew about using and generating slugs in an url structure to another level by using <strong>text-based identifiers in place of ids</strong>. Basically, it allows us to query for objects by finding them using their slugs, rather than their <code>id</code>s. Doesn&rsquo;t this make you super excited? Time to find out more about this approach and become friends with the <code>friendly_id</code> gem!</p>

<!--more-->


<h2>Making Friends With Friendly_Id</h2>

<iframe src="//giphy.com/embed/Wsk723nT8tXpe" width="480" height="223" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>The <code>friendly_id</code> gem, created and maintained by <a href="https://github.com/norman">Norman Clarke</a>, describes itself as &ldquo;the Swiss Army bulldozer of slugging and permalink plugins for ActiveRecord&rdquo;. And that&rsquo;s probably a pretty accurate name for all the things that this one single gem is capable of doing!</p>

<p>Before we can really explore all of its neat features, we need to do some initial setup. We&rsquo;ll start by adding <code>friendly_id</code> to our <code>Gemfile</code>, and then running <code>bundle</code>:</p>

<p><code>gem 'friendly_id', '~&gt; 5.1.0'</code></p>

<p>It&rsquo;s worth mentioning here that if we&rsquo;re running on Rails 4.0 or higher, we must use <code>friendly_id</code> <code>5.0.0</code> or greater.</p>

<p>Next, we know we&rsquo;ll need to add a <code>slug</code> column to the table in our database that we want to implement <code>friendly_id</code> on. We&rsquo;ll add a <code>publishers</code> table to our bookstore application, and assure that they always have a <code>name</code> and a <code>slug</code> column when they are committed to the database. We&rsquo;ll also add a unique index to the <code>slug</code> column, since we&rsquo;ll be using the slug in our urls, which means that no two <code>publisher</code> instances should have the same slug &mdash; and also because we&rsquo;ll want to be able to look up publishers by their slug rather than by their <code>id</code>:</p>

<pre><code class="ruby">class CreatePublishers &lt; ActiveRecord::Migration
    def self.up
        create_table :publishers do |t|
          t.string :name, null: false
          t.string :slug, null: false
        end

        add_index :publishers, :slug, unique: true
    end

    def self.down
        drop_table :publishers
    end
end
</code></pre>

<p>It&rsquo;s worth nothing that if we were adding <code>friendly_id</code> to rows that already existed in our database, we would need to generate slugs for these preexisting objects. We have a few options on where to put this command &mdash; in a rake task or from the console, for example &mdash; but we&rsquo;d have to find each of our objects and call <code>save</code> on them to generate their slugs. For example, if we were implementing <code>friendly_id</code> on our preexisting <code>Author</code> class, we would run this line:</p>

<p><code>Author.find_each(&amp;:save)</code></p>

<p>Now, time to extend or include the <code>FriendlyId</code> module in our model; that&rsquo;s right, it doesn&rsquo;t matter which one you do, just as long as the model has access to the methods defined in the module:</p>

<pre><code class="ruby">class Publisher &lt; ActiveRecord::Base
    extend FriendlyId

    validates :name, :slug, presence: true
end
</code></pre>

<p>Now comes the actual implementation! We need to use one method in particular in order to configure the way that the <code>FriendlyId</code> module will behave inside the context of the model. This method is aptly named as: <code>friendly_id</code>, which is essentially just the &ldquo;base&rdquo; method of the <code>FriendlyId</code> module:</p>

<pre><code class="ruby">class Publisher &lt; ActiveRecord::Base
    extend FriendlyId
    friendly_id :name, use: :slugged

    validates :name, :slug, presence: true
end
</code></pre>

<p>This method sets the default configurations of what method (yes, a method and <em>not</em> a column in the database!) it should use when trying to find an object. It also allows you to pass an <code>options</code> hash, which is what we&rsquo;re doing when we pass it <code>use: :slugged</code>. We&rsquo;re effectively telling the <code>friendly_id</code> method to use the <a href="http://norman.github.io/friendly_id/FriendlyId/Slugged.html">slugged addon</a>.</p>

<p>So now that we&rsquo;ve got the most basic implementation set up, what does this allow us to do, exactly? Well, given our current model, we can now find instance of our <code>Publisher</code> class by their name:</p>

<pre><code class="ruby">Publisher.friendly.find('random-house')
#=&gt; finds and returns an instance of the Publisher class
with a slug 'random-house'
</code></pre>

<p>Cool! We&rsquo;re doing almost what Rails&#8217; <code>ActiveRecord</code> <code>find</code> method would do, but we&rsquo;re now no longer finding by a numerical <code>id</code>, but a string identifer that actually <em>means</em> something to both us as programmers, and our users!</p>

<p>But what if we didn&rsquo;t want to litter our codebase with <code>friendly.find</code> everywhere? There&rsquo;s a solution for that, too. We just need to use another addon, which isn&rsquo;t implemented by default, called <code>finders</code>:</p>

<pre><code class="ruby">class Publisher &lt; ActiveRecord::Base
    extend FriendlyId
    friendly_id :name, use: [:slugged, :finders]
    validates :name, :slug, presence: true
end
</code></pre>

<p>This allows us to invoke <code>find</code> directly &mdash; but we have to be careful with this because it could conflict with other places where we are using <code>ActiveRecord</code>&rsquo;s <code>find(id)</code> method. Now we can do something like this very easily:</p>

<pre><code class="ruby">Publisher.find('random-house')
#=&gt; finds and returns an instance of the Publisher class
with a slug 'random-house'
</code></pre>

<p>As we continue to implement <code>friendly_id</code> on other models in our application, we&rsquo;ll need to keep in mind that any classes that participate in single-table inheritence must extend <code>FriendlyId</code> in both the parent classes, and all its children classes as well.</p>

<p>But what else can this gem do? It&rsquo;s time to finally start playing around with all of its functionality!</p>

<h2>Where You Lead, Friendly_Id Will Follow</h2>

<iframe src="//giphy.com/embed/nVXzt7FSJlX7W" width="480" height="239" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>When the documentation called this gem the &ldquo;Swiss Army bulldozer&rdquo; of slug url generation, it wasn&rsquo;t kidding! There really is a <em>ton</em> that we can do with the various modules and addons provided to us by <code>friendly_id</code>. We&rsquo;ll explore just a handful of things that we can modify for different use cases.</p>

<h3>Should Generate New Friendly Id?</h3>

<p>One question we should answer off the bat is how exactly this gem actually decides to generate a slug. It turns out that the <code>friendly_id</code> gem has a <code>should_generate_new_friendly_id?</code> method, which determines <a href="http://norman.github.io/friendly_id/FriendlyId/Slugged.html#should_generate_new_friendly_id%3F-instance_method">when and whether</a> to generate a new slug. A peek into the source code of this gem reveals that this method just checks whether there is a slug column defined, and the <code>base</code> method on the FriendlyId module configurations has been called or not:</p>

<pre><code class="ruby">def should_generate_new_friendly_id?
    send(friendly_id_config.slug_column).nil? &amp;&amp; 
        !send(friendly_id_config.base).nil?
end
</code></pre>

<p>The documentation points out that it is totally fine to override this method in our models &mdash; for example, if we only wanted our slugs to be generated once upon creation, and never updated.</p>

<h3>Duplicate Ids</h3>

<p>By default, <code>friendly_id</code> expects the slug values that we told it to use in our model to be unique. It also helps that we assured that this is the case by creating a unique index on our <code>slug</code> column. But, what happens if an admin (or even a user) tries to create an object that would create a duplicate <code>friendly_id</code>? Well, the gem handles this case in a pretty cool way: it just appends a UUID to the generated slug to ensure that it will be a unique value:</p>

<pre><code class="ruby">publisher_a = Publisher.create(name: "Harper Collins")
publisher_b = Publisher.create(name: "Harper Collins")

publisher_a.friendly_id #=&gt; "harper-collins"
publisher_b.friendly_id #=&gt; "harper-collins-102-c9f6749b-daez-4586-a21x-waz87ak16oe2"
</code></pre>

<p>Pretty awesome, right? It really does seem like this gem is a developer&rsquo;s best friend!</p>

<h3>Slug Candidates</h3>

<p>As nice as it is that we have the functionality to append an UUID sequence to prevent non-unique slugs, it would also be nice if we had some control over how to modify a potential clash in <code>friendly_id</code> identifiers. Well, our wish is this gem&rsquo;s command! We can use a lovely &ldquo;candidates&rdquo; feature (new in version <code>5.0</code> of this gem!) to set up a list of alternate slugs that we can use to distinguish records in place of sequence.</p>

<p>We&rsquo;ll first add two required columns to our <code>publishers</code> database, <code>city</code> and <code>country</code>:</p>

<pre><code class="ruby">class AddCityAndCountryToPublishers &lt; ActiveRecord::Migration
    def change
        add_column :publishers, :city, :string, null: false
        add_column :publishers, :country, :string, null: false
    end
end
</code></pre>

<p>After we run <code>rake db:migrate</code>, and make sure that these values are all populate in our pre-existing records, we&rsquo;ll tell the <code>friendly_id</code> base method to use the <code>slug_candidates</code> method, which is going to be a set of instructions on how to construct the <code>slug</code> for any given instance of our <code>Publisher</code> class:</p>

<pre><code class="ruby">class Publisher &lt; ActiveRecord::Base
    extend FriendlyId
    friendly_id :slug_candidates, use: :slugged

    validates :name, :slug, :city, :country, presence: true

    def slug_candidates
        [
            :name,
            [:name, :city],
            [:name, :city, :country]
        ]
    end
end
</code></pre>

<p>You&rsquo;ll remember that I mentioned that <code>friendly_id</code> uses a method, and not a column in the database to generate a slug &mdash; well, this is exactly why it does that: so that we can override a method very easily! Now the <code>friendly_id</code> base method will use first the <code>name</code> attribute, then the <code>name</code> and <code>city</code> attributes, followed by the <code>name</code>, <code>city</code>, and <code>country</code> attributes.</p>

<pre><code class="ruby">publisher_a = Publisher.create(name: "Harper Collins", city: 'New York City')
publisher_b = Publisher.create(name: "Harper Collins", city: 'San Francisco')

publisher_a.friendly_id #=&gt; "harper-collins-new-york-city"
publisher_b.friendly_id #=&gt; "harper-collins-san-francisco"
</code></pre>

<p>It&rsquo;s worth noting that our method doesn&rsquo;t have to be named <code>slug_candidates</code> in the context of our class: this is just the <strong>base method</strong> of our <code>FriendlyId</code> module, which means that we can mame it anything we want, so long as we pass it to our <code>friendly_id</code> method when we tell it what we want to use to generate our <code>id</code>s for finding our objects. The nice thing about using an array of symbols (as opposed to string literals or procs and lambdas), is that the <code>FriendlyId</code> module will invoke a method of the same exact name on our <code>Publisher</code> model, which can be helpful if we have a <code>city</code> and <code>country</code> attribute on each of our <code>publisher</code> instances, which maps to a column in our database.</p>

<p>Of course, if we do happen to have an edge case where two instances of a <code>Publisher</code> have the exact same <code>name</code>, <code>city</code>, and <code>country</code>, the <code>friendly_id</code> gem can handle this situation as well! What will it do, exactly? Here&rsquo;s what the documentation says:</p>

<blockquote><p>&ldquo;If none of the [slug] candidates can generate a unique slug, then FriendlyId will append a UUID to the first candidate as a last resort.&rdquo;</p></blockquote>

<p>Nice! So we can always depend on our slugs being unique in some way or another &mdash; in the worst case (which probably won&rsquo;t even happen that often!), it&rsquo;ll just add a UUID at the end of the slug that matches another one, making it unique.</p>

<h2>Saving Old Friends</h2>

<p>We&rsquo;ve been working mostly with the <code>slugged</code> addon, but there are also quite a few other addons available to us. One of the most interesting ones is the <code>history</code> addon, which allows us to save <a href="http://norman.github.io/friendly_id/FriendlyId/History.html">different versions</a> of an instance&rsquo;s <code>slug</code> attributes!</p>

<p>For example, if we had <code>Article</code> instances that might allow for their <code>title</code>s to be updated by admins, we wouldn&rsquo;t want all of our urls to be broken when an admin changed a title on an article, right? Well, this addon helps us prevent that.</p>

<p>In order for us to implement this module, we need add a table to your database to store the slug records. Luckily, <code>friendly_id</code> has a generator for this:</p>

<pre><code class="ruby">rails generate friendly_id
rake db:migrate
</code></pre>

<p>Now we just need to specify that our base method needs to use the <code>history</code> addon:</p>

<pre><code class="ruby">class Article &lt; ActiveRecord::Base
    extend FriendlyId
    friendly_id :name, use: :history
end
</code></pre>

<p>And now in our controller we can do something like this!</p>

<pre><code class="ruby">class ArticlesController &lt; ApplicationController
    before_filter :find_article

    def find_article
        @article = Article.find params[:id]

        # If an old id is used to find the record,
        # we can handle a can redirect accordingly!
    end
end
</code></pre>

<p>There are so many interesting use cases for this gem, and it turns out that it does a lot of the stuff we already know about under the hood. One quick example: it uses Rails&#8217; <code>ActiveSupport</code> <a href="http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html#method-i-parameterize">parameterize method</a>, which is actually used by <code>to_param</code> &mdash; and which we have already explored on our own!</p>

<p>So, there&rsquo;s never just one way to do anything. As long as we&rsquo;re willing to learn the fundamentals of how to solve a problem in one way, we can explore all the different solutions that people have already come up with. And when it comes to generating urls and handling strange situations with slugs, we&rsquo;ve got it covered with our new best friend, the <code>friendly_id</code> gem.</p>

<iframe src="//giphy.com/embed/LnaPDokBEmONG" width="480" height="240" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>friendly_id</code> gem is a way to find objects and generate urls using strings instead of numerical ids. The <a href="http://norman.github.io/friendly_id/">documentation</a> for this gem is fantastic, check it out!</li>
<li>Here&rsquo;s a very simple <a href="http://railscasts.com/episodes/314-pretty-urls-with-friendlyid">railscast</a> that implements <code>friendly_id</code> in its most basic capacity.</li>
<li>Curious about how that <code>friendly_id</code> base method works? Check out the <a href="https://github.com/norman/friendly_id/blob/8069fc9959215e5f4872927928b3b7a95e9beacd/lib/friendly_id/base.rb#L191">source code</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Breaking the News: Wisper + Pub-Sub]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/12/08/breaking-the-news-wisper-plus-pub-sub/"/>
    <updated>2015-12-08T08:50:17-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/12/08/breaking-the-news-wisper-plus-pub-sub</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/3oEduPlMkw4LZE7624" width="480" height="300" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>I&rsquo;ve been rather reflective this past week. This is mostly because the end of this year of technical Tuesdays is now very much in sight, with only a handful more posts left to write. Also, I&rsquo;ve been going back over old posts and correcting a few spelling and code snippet mistakes that have been brought to my attention (shoutout to all of you who have been proofreading for me!). All of this is to say that I never realized until recently that I&rsquo;ve covered quite the spread of different topics over the past year!</p>

<p>But here&rsquo;s the rub: I&rsquo;m not even <em>close</em> to being done with my list of things I still want to learn more about. And even though that list keeps growing, I&rsquo;ve noticed that the complexity behind the concepts I&rsquo;m learning and writing about has begun to slowly change. While I started off focusing on syntax and DSL-specific topics, now those topics have become more theoretical in nature. While I used to write about things like the Rails <a href="http://vaidehijoshi.github.io/blog/2015/06/09/refactoring-to-reveal-rails-group-by/">group_by</a> method and the <a href="http://vaidehijoshi.github.io/blog/2015/06/02/code-smells-and-ruby-shorthand-unpacking-ampersand-plus-to-proc/">ampersand</a> operator, now I&rsquo;m diving into more complex concepts like <a href="http://vaidehijoshi.github.io/blog/2015/12/01/functions-to-call-upon-activerecord-association-callbacks/">association callbacks</a> and <a href="http://vaidehijoshi.github.io/blog/2015/07/07/taskmanaging-your-app-part-2-service-objects/">service objects</a>.</p>

<p>This week took complex concepts to a whole new level. I&rsquo;m talking about higher-level CS theory that I didn&rsquo;t even know existed. It all started when I heard someone use the term <strong>&ldquo;pub-sub&rdquo;</strong> (yeah, that&rsquo;s a thing!). And it stands for <strong>publish-subscribe</strong>, which is a messaging pattern used in software architecture. If you&rsquo;ve never heard about this before, don&rsquo;t worry &mdash; I hadn&rsquo;t either! It&rsquo;s apparently not all that common in Rails development, but <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">JavaScript promises</a> are a loose example for how they are constructed. But let&rsquo;s not get carried away with semicolons and such nonesense. How does the publish-subscribe pattern work in Ruby? It&rsquo;s time to learn all about it!</p>

<!--more-->


<h2>Extra extra! Read all about pub-sub</h2>

<iframe src="//giphy.com/embed/13gOSoNUzh55g4" width="480" height="288" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>In the context of building out systems of software, the publish-subscribe pattern is a way of handling how messages are sent between objects. We are probably already familiar with the concept of the &ldquo;single responsiblity principle&rdquo;, or the idea that no method should be responsible for more than one thing. This same concept extends to other parts of our application as well. As we&rsquo;ve learned through the process of refactoring, our controllers shouldn&rsquo;t be responsible for the logic that really belongs in model. Similarly, a model shouldn&rsquo;t be responsible for calling on a third-party service or performing some task or piece of logic that doesn&rsquo;t really relate to its own state.</p>

<p>The way that we solve this in Ruby is by abstracting out logic into smaller components. We have service objects, which are responsible for carrying out tasks and therefore are easily-testable, and encapuslate a very specific piece of functionality that the rest of the application doesn&rsquo;t really need to know about.</p>

<p>In Ruby, when we have two objects that are connected in some way &mdash; for example, a <code>Dog</code> <code>belongs_to</code> its <code>Human</code> &mdash; and the state of the <code>Human</code> changes, we probably want to notify the instance of the <code>Dog</code> that the object is associated with. We could say that the <code>Human</code> sends out a &ldquo;message&rdquo; to the objects that are &ldquo;listening&rdquo; to it. The real terms that we are trying to use here are <strong>publish</strong> and <strong>subscribe</strong>. An instance of a <code>Human</code> object &ldquo;publishes&rdquo; events (i.e., the human <code>wakes_up</code>, <code>is_ready_to_play</code>, etc.), and the <code>Dog</code> object listens and &ldquo;subscribes&rdquo; to these events (and probably behaves accordingly, aka it would <code>jump_excitedly</code> when the human <code>is_ready_to_play</code>).</p>

<p>Usually, for smaller applications, it&rsquo;s fine to just rely on one object telling another to behave a certain way explicitly. But, things get kind of messy as you have more objects &ldquo;listening&rdquo; to the events of other objects. This is where our knowledge of service objects can come in handy. We can pretty easily abstract out units of work into service classes. But, this still means that we need to notify our service classes whenever they need to change; in other words, we have to tell our services <em>Hey, you need to behave in a certain way because something about the object you&rsquo;re associated with has changed!</em></p>

<p>The <strong>publish-subscribe pattern</strong> uses the exact same concept of sending messages between objects when something about one of the objects changes &mdash; however, it does this by using an intermediary object, sometimes called a <strong>message broker</strong> or an <strong>event bus</strong>. The important thing here is that the object that does the &ldquo;publishing&rdquo; or &ldquo;broadcasting&rdquo; of an event has no idea who is listening to its events. It just sends out a signal of sorts. The intermediary message broker object then is responsible for knowing who is &ldquo;subscribed&rdquo; to this event, and who needs to know about it. The message broker then makes sure that the correct object gets this message. In the simple example from above, a <code>Human</code> might publish an event, and another object, such as a <code>DogNotifer</code>, would be responsible for telling the <code>Dog</code> instance that it needs to do something.</p>

<p>I really like the way that Ahmed Abdel Razzak explains this in his <a href="http://www.toptal.com/ruby-on-rails/the-publish-subscribe-pattern-on-rails">blog post</a>:</p>

<blockquote><p>&ldquo;The publish-subscribe pattern is a Ruby on Rails messaging pattern where senders of messages (publishers), do not program the messages to be sent directly to specific receivers (subscribers). Instead, the programmer “publishes” messages (events), without any knowledge of any subscribers there may be. The pub-sub is a pattern used to communicate messages between different system components without these components knowing anything about each other’s identity.&rdquo;</p></blockquote>

<p>This concept can be a little tricky to understand in Ruby until you see all the classes in action. So let&rsquo;s start publishing and subscribing!</p>

<h2>Hush, don&rsquo;t shout</h2>

<iframe src="//giphy.com/embed/dYHtDUl1VZ0ly" width="480" height="257" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>There are a few different pub-sub gems out there, but the one that I&rsquo;ve found the easiest to use is a gem called <a href="https://github.com/krisleech/wisper/tree/v1"><code>wisper</code></a>.</p>

<p>We&rsquo;ll start the same way that we always do: by adding <code>gem 'wisper'</code> to our <code>Gemfile</code>, and then running the <code>bundle</code> command.</p>

<p>Now, let&rsquo;s take a look at one of our Ruby classes that we can implement the pub-sub pattern on. Here we have a <code>PressReview</code> class, that is a representation of a book review that might generate a lot of press for an <code>Author</code> in our bookstore app. These press reviews are pretty important (think the New York Times Bestseller List, etc.), so we want to notify the author of the book when the press review goes live. We also want to generate a tiny news snippet that will just have a few lines about the article once it has been created:</p>

<pre><code class="ruby">class PressReview &lt; ActiveRecord::Base
    after_commit :alert_author, on: :create
    after_commit :generate_news_item, on: :create

    private
    def alert_author
        AuthorMailer.send_alert_email(self).deliver_later
    end

    def generate_news_item
        NewsItem.create(self)
    end
end
</code></pre>

<p>The first thing that we&rsquo;ll want to do to add the <code>wisper</code> gem is to include the <code>Wisper::Publisher</code> module into the class that is going to be broadcasting events. In this case, we want to broadcast an event when our <code>PressReview</code> class has been successfully created and has gone &ldquo;live&rdquo;. Let&rsquo;s create a message broker class called <code>CreatePressReview</code> that will handle the broadcasting of this event. We will either need to include <code>Wisper::Publisher</code> or alternatively, <code>Wisper.publisher</code>:</p>

<pre><code class="ruby">class CreatePressReview
    include Wisper::Publisher
end
</code></pre>

<p>Next, we&rsquo;ll need to add the method that is going to be doing the &ldquo;broadcasting&rdquo; of the event. It&rsquo;s pretty typical to use a <code>call</code> method to do this. Inside of this broadcasting method, we&rsquo;ll want to handle two different situations (think JavaScript promises): if our <code>press_review</code> is created succesfully, or if it fails to be created:</p>

<pre><code class="ruby">class CreatePressReview
    include Wisper::Publisher

    def call(press_review_id)
        press_review = PressReview.find(press_review_id)

        # Some logic here to make sure that 
        # the press_review we just found is live and 
        # visible to the public, based on its state

        if press_review.live?
            broadcast(:press_review_created_success, press_review)
        else
            broadcast(:press_review_created_failed, press_review)
        end
    end
end
</code></pre>

<p>We&rsquo;ll notice that this class takes a <code>press_review_id</code>, and then contains the logic to set and check whether the <code>press_review</code> we just found is <code>live</code> or not. If it is live and we&rsquo;re ready to notify our author and generate our news item, we&rsquo;re calling the <code>broadcast</code> method, and passing it the name of the function we want to execute, along with the <code>press_review</code> instance. And if the <code>press_review</code> <em>isn&rsquo;t</em> live, we&rsquo;re calling a different method isntead.</p>

<p>It&rsquo;s worth noting that the <code>broadcast</code> method is also aliased to <code>publish</code> and <code>announce</code>, so either of these lines would have also worked:</p>

<pre><code class="ruby">publish(:press_review_created_success, press_review)
announce(:press_review_created_success, press_review)
</code></pre>

<p>Before we add any listener objects that will subscribe to these events, let&rsquo;s first abstract out those <code>alert_author</code> and <code>generate_news_item</code> private methods from our <code>PressReview</code> class into services objects. Our <code>alert_author</code> method can now be rewritten as a <code>AuthorAlerter</code> Plain Old Ruby Class, which calls upon an <code>AuthorMailer</code>:</p>

<pre><code class="ruby">class AuthorAlerter
    def alert_author(press_review_id)
        press_review = PressReview.find(press_review_id)

        AuthorMailer.send_alert_email(press_review).deliver_later
    end
end
</code></pre>

<pre><code class="ruby">class AuthorMailer &lt; ApplicationMailer
    def send_alert_email(press_review)
        # Sends an email to the author
        # alerting them of a new press review
    end
end
</code></pre>

<p>And our <code>generate_news_item</code> method can be refactored into a <code>NewsItemGenerator</code> service class, that creates a new instance of a <code>NewsItem</code>:</p>

<pre><code class="ruby">class NewsItemGenerator
    def generate_news_item(press_review_id)
        press_review = PressReview.find(press_review_id)

        NewsItem.create(press_review_id: press_review_id, published_at: press_review.live_date)
    end
end
</code></pre>

<pre><code class="ruby">class NewsItem
    belongs_to :press_review

    validates :published_at, presence: true
end
</code></pre>

<p>Now that we have our publishers in place, we need to make our service objects actually &ldquo;listen&rdquo; to these events.</p>

<h2>How And Why To Wisper</h2>

<p>Our event listeners will subscribe at runtime to their publishers, which means that they won&rsquo;t be executed until the broadcast events are actually invoked.</p>

<p>We can make any object a listener that subscribes to broadcast events by calling the <code>subscribe</code> method. So, inside of our controller, we could do something like this:</p>

<pre><code class="ruby">class CreatePressReviewController &lt; ApplicationController
    def create
        # The ActiveRecord logic to actually 
        # create a press review would go here

        create_press_review = CreatePressReview.new

        create_press_review.subscribe(AuthorAlerter.new)
        create_press_review.subscribe(NewsItemGenerator.new)

        create_press_review.call(press_review_id)
    end
end
</code></pre>

<p>We&rsquo;ll remember that it&rsquo;s the <code>CreatePressReview</code> intermediary event bus class that&rsquo;s actually responsible for broadcasting our events now, not the callbacks in the <code>PressReview</code> class like we had before! We&rsquo;re making sure that our <code>AuthorAlerter</code> and <code>NewsItemGenerator</code> services are subscribed to the &ldquo;sucess&rdquo; and &ldquo;failure&rdquo; events of the <code>call</code> method that is defined in our <code>CreatePressReview</code> intermediary class. And it&rsquo;s only when we invoke the <code>call</code> method (in the last of this controller action) that we&rsquo;re &ldquo;broadcasting&rdquo; our event. We&rsquo;ve hooked up everything in such a way that the event bus class and the service objects will run the correct code if our <code>press_review</code> instance actually goes live.</p>

<p>But we&rsquo;re not limited to doing all of this inside of a controller action! If we wanted to do this directly from our Rails model itself, we could write some similar logic by specificing the methods we want to invoke if the <code>PressReview</code> was created successfully:</p>

<pre><code class="ruby">class PressReview &lt; ActiveRecord::Base
    include Wisper::Publisher

    belongs_to :author

    after_commit :publish_creation_successful, on: :create

    private
    def publish_creation_successful
        broadcast(:press_review_created_success, self)
    end

    def publish_creation_failed
        broadcast(:press_review_created_failed, self) if errors.any?
    end
end
</code></pre>

<p>This rewrite has helped us divide our code into smaller, discrete classes that are easily-testable. In fact, we could use the <a href="https://github.com/krisleech/wisper-rspec"><code>wisper-rspec</code> gem</a> to help us in stubbing out some tests!</p>

<p>The pub-sub pattern might not be for everyone, but it&rsquo;s certainly interesting to read and learn about. Even you decide to never use it, at least you can say that you saw a really cute penguin do some serious subscribing at the end of this post:</p>

<iframe src="//giphy.com/embed/dPWFfe3tykssE" width="480" height="307" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The publish-subscribe <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">pattern</a> is a way to abstract out the conveying of messages between objects. The <code>wisper</code> gem is useful for implementing pub-sub in Ruby.</li>
<li>Want to read more about the pub-sub pattern in Rails? Check out this great <a href="http://www.toptal.com/ruby-on-rails/the-publish-subscribe-pattern-on-rails">blog post</a>.</li>
<li>The <code>wisper</code> gem has changed a bit over time, so there are a few good write-ups on how to implement it. Check one out <a href="ttp://www.sitepoint.com/using-wisper-to-decompose-applications/">here</a> and <a href="https://niallburkley.com/blog/ruby-publish-subscribe/">here</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functions to Call Upon: ActiveRecord Association Callbacks]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/12/01/functions-to-call-upon-activerecord-association-callbacks/"/>
    <updated>2015-12-01T08:53:17-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/12/01/functions-to-call-upon-activerecord-association-callbacks</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/ajgpGefucxTH2" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>No developer knows <em>everything</em> &mdash; even if they do know a whole lot more than you do. I was reminded of this fact recently while pairing with a more experienced programmer on a large Ember-Rails project that&rsquo;s now coming to a close. We were right in the middle of adding some methods to a Rails model when we realized that we actually needed to change something about how one of our model&rsquo;s <code>ActiveRecord</code> associations worked.</p>

<p>What we wanted to do was rely upon a callback function executing every time an association was created or destroyed. But, we hit a little bit of a wall, since we quickly realized that this wasn&rsquo;t as simple as we initially thought. The complication came with the fact that we were dealing with a <code>has_many</code> relationship, which meant that we weren&rsquo;t dealing with a single object, but rather a <em>collection</em> of objects. The developer I was pairing with explained that he knew that there were some methods that <code>ActiveRecord</code> has to achieve what we wanted to do, but he wasn&rsquo;t sure how they worked exactly, just that he had seen them before elsewhere.</p>

<p>After doing a little research on what resources <code>ActiveRecord</code> provides when it comes to solving this problem in an elegant way, we eventually decided to go another route and use a different callback function. But in the process of pairing, we learned that there <em>are</em> some methods that exist in <code>ActiveRecord</code> that can come in handy in this situation. If we hadn&rsquo;t been on a tight deadline for the specific feature that we were building, we probably could have devoted more time to learning about these callbacks. So, I decided to come back to these callback functions and dig a little deeper. Interestingly, there really isn&rsquo;t that much documentation on <code>ActiveRecord</code>&rsquo;s association callback methods, and nearly no blog posts. This is uncharted territory, my friends! Are you ready? I hope so.</p>

<!--more-->


<h2>Hello, it&rsquo;s me, a callback function</h2>

<iframe src="//giphy.com/embed/fOvKNgHUIChPi" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Callback functions are everywhere, particularly when we&rsquo;re inside the context of most Rails&#8217; models. Our average <code>ActiveRecord</code> callback will hook into the object life cycle of our <code>ActiveRecord</code> instances, which allows us to work with our object at any given point during its lifespan. The most common use case for implementing a callback is executing logic before or after the alteration of an object&rsquo;s state.</p>

<p>Here&rsquo;s my personal list of my top callbacks (yes, I have a list):</p>

<ol>
<li><code>after_commit</code></li>
<li><code>after_update</code></li>
<li><code>after_destroy</code></li>
<li><code>before_validation</code></li>
<li><code>before_save</code></li>
</ol>


<p>They pretty much do exactly what you think they would do: they hook into the object at the point in it&rsquo;s create, update, validate, save, or destroy &ldquo;state&rdquo;, and allow you to execute whatever functionality you might need. This is just the tip of the iceberg though: check out <a href="http://guides.rubyonrails.org/active_record_callbacks.html#available-callbacks">the whole list</a> of <code>ActiveRecord</code> callbacks that are free to use.</p>

<p>But let&rsquo;s get back to <strong>association callbacks</strong>. What makes them <em>different</em> from that bunch of functions we just listed above? Well, there&rsquo;s really one big difference in particular: association callbacks are similar to normal callbacks, but rather than hooking into the life cycle of a single object, they are triggered by the life cycle of a <em>collection of objects</em>. Unlike &ldquo;single object&rdquo; callbacks however, there are a limited number of a methods available for us to use. Actually, there&rsquo;s exactly four association callbacks, to get specific:</p>

<ol>
<li><code>before_add</code></li>
<li><code>after_add</code></li>
<li><code>before_remove</code></li>
<li><code>after_remove</code></li>
</ol>


<p>There are two important things to note about how and when these callbacks are run:</p>

<p>First, callbacks like <code>before_remove</code> and <code>after_remove</code> will run before and after the <code>delete</code> methods. In other words, when we call <code>objects.delete</code>, the <code>delete</code> method will invoke the <code>before_remove</code> and <code>after_remove</code> callbacks by default. Similarly, the <code>destroy</code> method will destroy a collection of records and remove them from an association while calling the <code>before_remove</code> and <code>after_remove</code> functions.</p>

<p>Second, if any of the <code>before_add</code> callbacks throws an exception and cannot create the association with a record in the collection, the object simply won&rsquo;t be added to the collection. Similarly, if any of the objects passed to the <code>before_remove</code> callback throws an exception, the object won&rsquo;t be removed from the collection. This is pretty important to keep in mind for two reasons: if we want to make sure that objects are only added or removed from an association collection successfully, and want to throw an error of some sort if for some reason this is <em>unsuccessful</em>, this is a really good thing. But, if we want to be able to assume that an object can always be added or removed from a collection without fail, this is bad thing, because we can&rsquo;t always be sure that this will happen.</p>

<p>With all these points in mind, there&rsquo;s only one question left to ask: how do we implement these callbacks, exactly? Time to find out.</p>

<h2>Calling Upon Callbacks</h2>

<iframe src="//giphy.com/embed/ixCowrTgEUeSKw1Zq8" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Implementing our association callback isn&rsquo;t too complicated of a task. Since these four association callbacks can only be invoked on a <code>has_many</code> or <code>has_many, through:</code> collection association, our callbacks can be added onto the same line where this association is defined in our model. For example, let&rsquo;s say that our <code>Order</code> objects can have many <code>Discount</code>s (apparently we&rsquo;re feeling particularly generous this holiday season, and we&rsquo;re going to allow many discounts rather than just one!). We can start off with a model that looks like this:</p>

<pre><code class="ruby">class Order
    has_many :discounts, after_add: :recalculate_total
end
</code></pre>

<p>Whenever a <code>discount</code> is added to an <code>order</code> instance, we want to recalculate the total for our order, with the discount applied. We&rsquo;ve  added the callback to our association, and are passing our callback the name of the function (in this case, we&rsquo;ve called it <code>recalculate_total</code>) we want to be executed every single time a <code>discount</code> is added to our &ldquo;collection&rdquo; of discounts on an <code>order</code>.</p>

<p>Now, all we need to do is actually write the <code>recalculate_total</code> method. Since we don&rsquo;t want this method to be called in any context aside from this association callback, we&rsquo;ll make it a <code>private</code> method:</p>

<pre><code class="ruby">class Order
    has_many :discounts, after_add: :recalculate_total

    private

    def recalculate_total(discount)
        subtotal = items.map(&amp;:amount).inject(:+)

        update!(total: (subtotal - discount))
    end
end
</code></pre>

<p>We can really pass as many methods to our callbacks as we want, in the form of symbols in an array. We can also pass a proc directly into this array as well, as explained by the <a href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">Rails docs</a>.</p>

<pre><code class="ruby">class Order
    has_many :discounts, after_add: [:recalculate_total, 
    :touch_discount_applied_at]

    private

    def recalculate_total(discount)
        subtotal = items.map(&amp;:amount).inject(:+)

        update!(total: (subtotal - discount))
    end

    def touch_discount_applied_at
        touch(:discount_applied_at)
    end
end
</code></pre>

<p>Pretty interesting, right? Who knew that this even existed?! (Spoiler alert: me. I had no clue this was even a thing.) But how does this even happen? Where is this defined, and how does it work? Let&rsquo;s dig one level deeper and dive into my favorite place: the Rails source code.</p>

<h2>All About The Association Builder</h2>

<p>I think one of the reasons that association callbacks aren&rsquo;t as well-known or written about is because they live in an odd place. In fact, they are defined inside of <code>ActiveRecord</code>&rsquo;s <code>Associations::Builder::CollectionAssociation</code> (wow, what a mouthful!) class, which doesn&rsquo;t actually have any documentation at all! No wonder this is Rails best-kept secret! This class is actually inherited by the <code>has_many</code> and <code>has_many_belongs_to_many</code> association classes, while the <code>CollectionAssociation</code> class itself inherits from the <code>Association</code> class.</p>

<p>I&rsquo;m still not <em>completely</em> sure what&rsquo;s going on behind the scenes here, but from the source code it appears as though the association callbacks (namely <code>before_add</code>, <code>after_add</code>, <code>before_remove</code>, and <code>after_remove</code> to be exact) are all defined as <a href="https://github.com/rails/rails/blob/718468e1c9666ee8d58ae2a446e865a1e1e1fc4e/activerecord/lib/active_record/associations/builder/collection_association.rb#L8">an array of symbols</a>, which is set to a <code>CALLBACKS</code> constant, which is used throughout the class:</p>

<pre><code class="ruby">require 'active_record/associations'

module ActiveRecord::Associations::Builder
    class CollectionAssociation &lt; Association

        CALLBACKS = [:before_add, :after_add, 
        :before_remove, :after_remove]

        def self.define_callbacks(model, reflection)
            # Truncated for brevity!

            CALLBACKS.each { |callback_name|
                define_callback(model, callback_name, name, options)
            }
        end
    end
end
</code></pre>

<p>So, if this is where our association callbacks are <em>defined</em>, where are they being invoked? I&rsquo;m glad you asked. It turns out, they&rsquo;re used most often inside of <code>ActiveRecord</code>&rsquo;s <code>Associations::CollectionAssociation</code> module, which contains methods that we use all the time on our <code>ActiveRecord</code> objects &mdash; perhaps without even realizing it! Our association callbacks are passed as arguments and then implemented by the <a href="https://github.com/rails/rails/blob/3f16a098452ee5d447142bd9a6f6045cb1fc83b4/activerecord/lib/active_record/associations/collection_association.rb#L583">callback method</a> in <code>CollectionAssociation</code> module.</p>

<p>We can actually see our callbacks in action inside of a <code>private</code> method called <code>remove_records</code>, which is <a href="https://github.com/rails/rails/blob/3f16a098452ee5d447142bd9a6f6045cb1fc83b4/activerecord/lib/active_record/associations/collection_association.rb#L535">defined within</a> this very same module. Here&rsquo;s what that method looks like:</p>

<pre><code class="ruby">def remove_records(existing_records, records, method)
    records.each { |record| callback(:before_remove, record) }

    delete_records(existing_records, method) if existing_records.any?
    records.each { |record| target.delete(record) }

    records.each { |record| callback(:after_remove, record) }
end
</code></pre>

<p>Nice! There&rsquo;s our <code>after_remove</code> callback, being called on each of our <code>records</code> that&rsquo;s being passed into it. We might not even realize it, but the <code>remove_records</code> method is called upon by the <code>delete_or_destroy</code> method (another <code>private</code> method in this module), which is invoked by both of <code>ActiveRecord</code>&rsquo;s commonly-used <code>delete</code> and <code>destroy</code> methods! This is exactly how we can confirm what we learned earlier about our <code>before_remove</code> and <code>after_remove</code> callbacks. It&rsquo;s not magic &mdash; it&rsquo;s just code that&rsquo;s hiding from us! Except now we know how to call upon our callbacks, so we can say that we are strangers no more.</p>

<iframe src="//giphy.com/embed/qWf8HTOti0mxG" width="480" height="249" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>Association callbacks are similar to <code>ActiveRecord</code>&rsquo;s normal callbacks, except that they hook into the life cycle of a collection of objects (<code>has_many)</code>, rather than just a single object (<code>has_one</code>).</li>
<li>Need to brush up on <code>ActiveRecord</code> associations? Head over to the <a href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">module documentation</a> for associations.</li>
<li>Want to know exactly what&rsquo;s going on inside of the <code>destroy</code> and <code>delete</code> methods? Dive into the source code! Check out the <a href="https://github.com/rails/rails/blob/3f16a098452ee5d447142bd9a6f6045cb1fc83b4/activerecord/lib/active_record/associations/collection_association.rb#L267">delete</a> and <a href="https://github.com/rails/rails/blob/3f16a098452ee5d447142bd9a6f6045cb1fc83b4/activerecord/lib/active_record/associations/collection_association.rb#L281">destroy</a> method signatures.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Peeking Under the Hood of ActionController Parameters, Part 2]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/11/24/peeking-under-the-hood-of-actioncontroller-parameters-part-2/"/>
    <updated>2015-11-24T08:56:47-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/11/24/peeking-under-the-hood-of-actioncontroller-parameters-part-2</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/Hhu5dqPScjXRm" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p><em>This blog post is part of a series on strong parameters. Read Part 1 <a href="http://vaidehijoshi.github.io/blog/2015/11/17/peeking-under-the-hood-of-actioncontroller-parameters-part-1/">here</a>.</em></p>

<p>Rails often feels like a black box, with all of the complex logic abstracted away and hidden from view. This leaves behind a clean, convention-abiding framework where form follows function. But another, perhaps less-intentional side effect of all the &ldquo;metaprogramming away&rdquo; of this framework&rsquo;s complexities is a frequent lack on clarity of what&rsquo;s going on behind the scenes.</p>

<p>In my year of working with Rails, I&rsquo;ve come to appreciate and respect so many things about it. In fact, I think that there&rsquo;s something incredibly approachable about Ruby as one&rsquo;s first programming language, with Rails as its corresponding framework. And of course, there&rsquo;s something truly unique and welcoming about the Ruby and Rails programming community. All of these factors combined make it so easy for beginners of such different backgrounds to start building applications very quickly.</p>

<p>However, once you get past the intial stage of building applications with the basic CRUD operations, or if you&rsquo;re trying to build something a bit more complex  with added functionality, or trying to integrate with another framework, you eventually hit a wall where you realize that that you&rsquo;re not completely sure how something works. This can be a hard wall to climb over, especially given the fact that you can start building things very quickly with Rails. Some people have heavily critiqued this aspect of the framework, arguing that it&rsquo;s detrimential to abstract away so much of what&rsquo;s <em>actually</em> going on, which makes it difficult for people to understand what their code is truly doing under the hood. I&rsquo;ve peronally encountered this &ldquo;wall of abstraction&rdquo; a few different times, but each time I found some piece of logic that worked differently than I thought it would, it only lead me to learn something new about the framework. Most recently, that lead me down a wild goose chase into the source code for <code>ActionController::Parameters</code> &mdash; a class that I didn&rsquo;t even know existed!</p>

<!--more-->


<h2>Quack Like A Hash</h2>

<p><img src="http://geekandpoke.typepad.com/.a/6a00d8341d3df553ef01053719d13a970b-pi" style="display: block; margin-left: auto; margin-right: auto;"/></p>

<p>There&rsquo;s a well-known saying that Rubyists often attribute to duck typing: <em>if it looks like a duck, and quacks like a duck, it probably is a duck.</em> In other words, if an object behaves like another object, it doesn&rsquo;t matter that it&rsquo;s of a certain class or &ldquo;type&rdquo; (or species!) of another object, just so long as it can respond to the correct method calls to implement the behavior of that object.</p>

<p>This saying actually comes from a concept referred to as the &ldquo;duck test&rdquo;, which is a form of abductive reasoning, which is based on the idea that one can identify an unknown object by observing its habitual characteristics. However, this can be a little bit tricky because <em>sometimes</em>, just because something quacks like a duck and waddles like a duck doesn&rsquo;t mean that we should stop questioning what it actually is and just assume that it&rsquo;s a duck!</p>

<p>Let me explain with an example. Whenever we send or receive data from the server, it appears that everything is being sent as a <code>Hash</code>. If we look at our <code>GET</code> requests or <code>POST</code> and <code>PUT</code> requests using HTTP protocol, our data usually looks like some variation on a theme of something like the following:</p>

<pre><code class="ruby">{ order: 
    { 
        total: 100.00, 
        number: 'ABC123' 
    } 
}
</code></pre>

<p>If it acts like a hash, and quacks like a hash, it must be a hash, right? Well, not exactly. Last week we learned that <code>params</code> in our controllers are actually instances of <code>ActionController::Parameters</code>. But this data that we&rsquo;re sending back and forth still looks like its a plain old Ruby <code>Hash</code>. It also seems to behave like a hash, right? We can do something like this</p>

<pre><code class="ruby">if params[:order].present?
    @order.create(order_params)
end
</code></pre>

<p>and access a key in this so-called &ldquo;hash&rdquo; the same way we would with any other <code>Hash</code> data structure. So, what&rsquo;s different about <code>ActionController::Parameters</code>?</p>

<p>Well, let&rsquo;s find out. We&rsquo;ll start by opening up <a href="https://github.com/rails/rails/blob/9ab2d030209d9608a6c866d83210f5b3b7d2319e/actionpack/lib/action_controller/metal/strong_parameters.rb#L108">the source code</a> for this class, which lives inside of the <code>ActionController</code> module. The first thing we&rsquo;ll notice is this:</p>

<pre><code class="ruby">module ActionController
    class Parameters &lt; ActiveSupport::HashWithIndifferentAccess
    end
end
</code></pre>

<p>Interesting! The <code>Parameters</code> class subclasses from <code>ActiveSupport::HashWithIndifferentAccess</code>. If we were really curious about what type of object <em>this</em> class inherits from, we could trace that back to see that <code>HashWithIndifferentAccess</code> simply <a href="https://github.com/rails/rails/blob/df6048407faefdc6774a8b5a02344fd4b1a734b1/activesupport/lib/active_support/hash_with_indifferent_access.rb#L43">inherits from</a> the class <code>Hash</code>. So, what makes <code>HashWithIndifferentAccess</code> different from plain old Ruby hashes?</p>

<p>Well, the <a href="http://api.rubyonrails.org/classes/ActiveSupport/HashWithIndifferentAccess.html
">Rails guides</a> answers this question pretty well:</p>

<blockquote><p><code>HashWithIndifferentAccess</code> implements a hash where keys <code>:foo</code> and <code>"foo"</code> are considered to be the same. Internally symbols are mapped to strings when used as keys in the entire writing interface. You are  guaranteed that the key is returned as a string. This class is intended for use cases where strings or symbols are the expected keys and it is convenient to understand both as the same. For example the <code>params</code> hash in Ruby on Rails.</p></blockquote>

<p>Awesome, this answers our question and more! This subclass gives us the flexibility to access the keys in a <code>params</code> &ldquo;hash&rdquo; by either a string or a symbol. The <code>HashWithIndifferentAccess</code> class still responds to the majority of the same methods that a Ruby <code>Hash</code> instance does, but with some added functionality, which can be especially handy if we&rsquo;re dealing with JSON responses.</p>

<p><em>Protip:</em> we can easily create <code>HashWithIndifferentAccess</code> instances by creating a Ruby <code>Hash</code> instance and calling <code>with_indifferent_access</code> on it. This method is available to us since core extensions has the <code>with_indifferent_access</code> method defined on the <code>Hash</code> class by default:</p>

<pre><code class="ruby">♥ rails c
Loading development environment (Rails 4.1.4)
irb(main):001:0&gt; h = {a: 'hi', b: 'hello'}
.with_indifferent_access
=&gt; {"a"=&gt;"hi", "b"=&gt;"hello"}
irb(main):002:0&gt; h.class
=&gt; ActiveSupport::HashWithIndifferentAccess
</code></pre>

<p>So, parameters aren&rsquo;t quite a hash, but they quack pretty much exactly like how a hash would quack. But there must be a good reason why they are different classes, right? Let&rsquo;s investigate further.</p>

<h2>Waddle Like A Param</h2>

<iframe src="//giphy.com/embed/jgIDKTrvTssDK" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>On a very basic level, <code>ActionController::Parameters</code> could be simplified to hashes with some serious restrictions and permissions. Because <code>ActionController::Parameters</code> inherits from <code>ActiveSupport::HashWithIndifferentAccess</code>, we can fetch values from our params &ldquo;hash&rdquo; using a symbol <code>:key</code> or a string <code>"key"</code>. But there are a few things that we can&rsquo;t do so easily, and that&rsquo;s where the functionality of <code>ActionController::Parameters</code> really starts to come into play and begins to make a lot more sense.</p>

<p>We can easily create a new instance of <code>ActionController::Parameters</code>. In fact, we do it within the context of our controllers all the time!</p>

<pre><code class="ruby">permitted_params = params.require(:order).permit(:total)

permitted_params
# =&gt; {"total"=&gt;"100.00"}

permitted_params.class
# =&gt; ActionController::Parameters
</code></pre>

<p>Except usually we wrap it in a <code>_params</code> suffixed method like this:</p>

<pre><code class="ruby">def order_params
    params.require(:order).permit(:total)
end
</code></pre>

<p>Here is one example of the added functionality of this class. When we create a new instance of a <code>ActionController::Parameters</code> class, it is by default, not permitted.</p>

<pre><code class="ruby">params = ActionController::Parameters.new

params.permitted? 
# =&gt; false
</code></pre>

<p>The <code>permitted?</code> method actually doesn&rsquo;t do anything more than return an attribute on an instance of a <code>ActionController::Parameters</code> object, called <code>@permitted</code>:</p>

<pre><code class="ruby">def permitted?
    @permitted
end
</code></pre>

<p>So the question is, where does this attribute get set? Well, there are two places that can set this attribute to <code>true</code>. The first place is a method that we&rsquo;re already familiar with: the <code>permit</code> method! As we learned last week, this method calls <code>params.permit!</code> as its last line, after it filters out any paramters that aren&rsquo;t permitted scalar values (think <code>Symbol</code>, <code>String</code>, or <code>Hash</code>). However, we can also just call <code>permit!</code> on an instance of <code>ActionController::Parameters</code> ourselves.</p>

<pre><code class="ruby">params = ActionController::Parameters.new
params.permitted?
# =&gt; false

params.permit!
params.permitted?
# =&gt; true
</code></pre>

<p>The <code>permit!</code> method sets the <code>@permitted</code> attribute to <code>true</code>, and returns <code>self</code>, which in this case is just the instance of the params class. This method <a href="https://github.com/rails/rails/blob/9ab2d030209d9608a6c866d83210f5b3b7d2319e/actionpack/lib/action_controller/metal/strong_parameters.rb#L223">is quite useful</a> for mass assignment, since it effectively removes the need to list all the permitted values. It can be handy in a controller that is used only by admins that should have control over &mdash; and can be trusted with &mdash; updating all attributes of an object:</p>

<pre><code class="ruby"># def blog_params
    # params.require(:blog).permit(:title, 
        # :author, :published_at, :tags, 
        # :excerpt, :image, :image_caption, :external_url)
# end

def blog_params
    params.require(:blog).permit!
end
</code></pre>

<p>However, this doesn&rsquo;t really make sense to use unless you are <em>sure</em> that you want to allow all the values to the params hash to be whitelisted. Proceed with caution!</p>

<h2>Heavy Metal Controllers</h2>

<p>Now that we know a little bit more about <code>ActionController::Parameters</code> and what kinds of ducks &mdash; oops, I mean <em>objects</em> &mdash; they really are, there&rsquo;s one question that we probably still have floating around in our heads: where on earth does our params come from during the request-response cycle&hellip;and <em>how</em> does it get set on a controller?</p>

<p>To answer this question, we must trace back how a parameter comes in from a request, and then how it is set on a controller. It isn&rsquo;t magic (even though it seems like that&rsquo;s the case!). In reality, it&rsquo;s actually happening in a cool place called <code>ActionController::Metal</code>. Yes, that&rsquo;s a thing, and it happens to be the very class that <code>ActionController::Base</code> <a href="https://github.com/rails/rails/blob/7978ec722172b45e72ee78baefc23ab907a91131/actionpack/lib/action_controller/base.rb#L164">inherits</a> from. By default, we should always inherit from <code>ActionController::Base</code>, because it gives us a ton of functionality and modules that help speed things up.</p>

<p>But even <code>ActionController::Base</code> has to come from <em>somewhere</em>, right? And that somewhere happens to be <code>ActionController::Metal</code>, which is the simplest possible controller that we can create in Rails, which provides little more than a Rack interface. Here&rsquo;s a very, <em>very</em> simplified version of what that class looks like in the Rails source code:</p>

<pre><code class="ruby">class Metal &lt; AbstractController::Base
    # Very truncated from the Rails source code!

    attr_internal :headers, :response, :request

    def initialize
        @_headers = {"Content-Type" =&gt; "text/html"}
        @_status = 200
        @_request = nil
        @_response = nil
        @_routes = nil
        super
    end
end
</code></pre>

<p>As a request goes out or a response comes in, these values are set as instances on the controller itself! So if there was any doubt in your mind, everything in Ruby is an object &mdash; even controllers are just objects with instance variables and attr_readers and attr_accessors.</p>

<p>So, where do our parameters get set? Well, they also live in an instance attribute called <code>@_params</code>, which is set by a <a href="https://github.com/rails/rails/blob/2910956fc9006d3c26f56992dab630fa97b7f7bc/actionpack/lib/action_controller/metal.rb#L140">params method</a>. The parameters come in from a request, and are beautifully memoized in a method that looks like this:</p>

<pre><code class="ruby">def params
    @_params ||= request.parameters
end
</code></pre>

<p>Pretty amazing, right? That black box of <code>ActionController</code> and strong parameters doesn&rsquo;t seem so intimiating any more, does it?
It&rsquo;s a little strange that we always talk about and use <code>params.require</code> and the <code>permit</code> method so often in Rails, particularly when we are first starting out, but we don&rsquo;t necessarily question where it comes from! Or how it is set or being used, for that matter! But now we know. And we&rsquo;ll never mistake our strong params for a simple Ruby hash again.</p>

<p>Or a duck, for that matter.</p>

<iframe src="//giphy.com/embed/NTSMCNXQQ1xiE" width="480" height="346" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>Rails 5 Update</h2>

<p>I recently learned that there&rsquo;s a significant change coming to <code>ActionController::Parameters</code> with the soon-to-be-released Rails 5! Namely, another Rubyist brought this to my attention over the interwebz:</p>

<blockquote class="twitter-tweet" data-conversation="none" lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/ThePracticalDev">@ThePracticalDev</a> Nice post! Just a friendly change advisory, AC::Parameters composes an object and no longer inherits from HWIA in Rails 5.</p>&mdash; Jon Atack (@jonatack) <a href="https://twitter.com/jonatack/status/671804828562169856">December 1, 2015</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>It turns out that <code>ActionController::Parameters</code> will soon return an object, rather than a <code>Hash</code> instance, which also means that it will no longer Hash will no longer inherit from <code>ActiveSupport::HashWithIndifferentAccess</code> as this post explains. Check out this great <a href="http://eileencodes.com/posts/actioncontroller-parameters-now-returns-an-object-instead-of-a-hash/">blog post</a> by Eileen Uchitelle, a developer at Basecamp, to learn more about how <code>ActionController::Parameters</code> will be changing with the next release of Rails.</p>

<h2>tl;dr?</h2>

<ul>
<li>An instance of <code>ActionController::Parameters</code> behaves a lot like a hash that can be accessed with either symbol or string keys. This class has some added methods like <code>permitted?</code> and <code>permit!</code> which check and set the <code>@permitted</code> instance attribute on a params object.</li>
<li>Curious to learn more about how strong params handles nested attributes? Check out this great <a href="http://patshaughnessy.net/2014/6/16/a-rule-of-thumb-for-strong-parameters">blog post</a> by Pat Shaughnessy.</li>
<li>New to <code>ActionController::Metal</code>? Head over to the Rails docs <a href="http://api.rubyonrails.org/classes/ActionController/Metal.html">to learn more</a> and read this helpful <a href="http://stackoverflow.com/a/18189580">StackOverflow post</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Peeking Under the Hood of ActionController Parameters, Part 1]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/11/17/peeking-under-the-hood-of-actioncontroller-parameters-part-1/"/>
    <updated>2015-11-17T08:39:52-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/11/17/peeking-under-the-hood-of-actioncontroller-parameters-part-1</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/iKufnbkSIcliM" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>When you write code every day for a living, it&rsquo;s easy to get hyper-focused on building out new features and getting things done quickly. What&rsquo;s much harder is to take a step back and figure out exactly how something is working. Of course, sometimes this happens inherently and without any effort on your part &mdash; say for example, when you&rsquo;re fixing a bug or need to integrate with a third-party service and are forced to understand what&rsquo;s happening on a more granular level. But generally speaking, that is less common when you&rsquo;re working a within a framework that you&rsquo;re already comfortable with and use daily, without giving it a second thought.</p>

<p>I had one of those &ldquo;take a step back and question everything&rdquo; kind of moments recently. I was writing a controller for the admin interface of a Rails application, and hit a roadblock. To be clear, there wasn&rsquo;t anything super complex about the controller I was writing; it had the basic CRUD actions that any controller does, and I had written controllers like it plenty of times before. Yet somehow, when I got to writing the <code>params</code> private method for this controller, I couldn&rsquo;t remember what methods I needed to use. I was super tempted to open up another controller and just copy and paste the strong parameters from one file into another. But I realized that this wasn&rsquo;t really going to help me at all. What I <em>really</em> needed to do was grasp how strong parameters worked on a more conceptual level. If I could understand why we use the methods that we use, and to what end, I would never need to even look up the documentation for whitelisting parameters ever again!</p>

<p>So that&rsquo;s exactly what I did. I decided to peek under the hood of Rails&#8217; <code>ActionController</code>, and set my mind to learning everything there was the know about strong parameters. <em>Spoiler alert:</em> I didn&rsquo;t completely succeed, and I definitely don&rsquo;t know everything about whitelisting parameters. But what I <em>did</em> finally come to understand was why we use the methods that we do (think <code>require</code> and <code>permit</code>), and why we invoke them in that order. And hopefully I&rsquo;ll be able to explain how some that black box magic in Rails <em>actually</em> works!</p>

<!--more-->


<h2>Strong(est) Params</h2>

<iframe src="//giphy.com/embed/oB6nlaw4QJ8TS" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>When we&rsquo;re first introduced to the Rails framework, there are some fairly basic components that we learn about, including the MVC structure, which stands for Model, View, Controller. Personally, I found models and views to be far easier to grasp than controllers. Controllers were a whole other beast entirely. In fact, one of the very first concepts that <a href="http://vaidehijoshi.github.io/blog/2014/10/30/have-you-met-your-controller-yet/">I struggled with</a> was the very basics of writing a controller action! I eventually got a better at that, and now for our bookstore application, I have a more sophisticated controller (in this case, for our <code>Order</code> objects), which looks like this:</p>

<pre><code class="ruby">class OrdersController &lt; ApplicationController
    def create
        @order = Order.create(order_params)

        render json: order
    end

    def show
        render json: order
    end

    def update
    if order.update(order_params)
        render json: order
    else
        render json: {}, status: :unprocessable_entity
    end
    end

    def destroy
        order.destroy

        render json: {}
    end

    private
    def order
        @order ||= Order.find(params[:id])
    end

    def order_params
        # OH GOD WHY?!
    end
end
</code></pre>

<p>Nice! We&rsquo;re using our new <a href="http://vaidehijoshi.github.io/blog/2015/11/10/methods-to-remember-things-by-ruby-memoization/">memoization</a> technique, and we&rsquo;re rendering json responses to make it much easier to integrate with a JavaScript frontend; of course, we could have also just rendered our <code>@order</code> instance if this were a simple Rails application with no frontend framework. But&hellip;there&rsquo;s one thing that we&rsquo;re still missing, and clearly put off because I was dreading it: our strong parameters!</p>

<p>The <code>ActionController</code> <a href="http://edgeapi.rubyonrails.org/classes/ActionController/StrongParameters.html">strong parameters</a> module was introduced back in 2012 with the release of Rails 4. The idea behind strong params was to abstract out the creation of models via mass assignment into the controller, rather than in the context of a model. Prior to this feature, we used to need to whitelist attributes in our models using <code>attr_accessible</code></p>

<pre><code class="ruby">class Order &lt; ActiveRecord::Base
    attr_accessible :total, :number
end
</code></pre>

<p>in order to use mass assignment to instantiate an object from our controller actions:</p>

<pre><code class="ruby">class OrdersController &lt; ApplicationController
    def create
        @order = Order.create(params[:order])
    end
end
</code></pre>

<p>Not the best solution, right? Enter our knight in shining armor: <code>strong_parameters</code>, a <a href="https://github.com/rails/strong_parameters">gem</a> that the Rails core team released to fix this problem, which was eventually merged into Rails. Okay, let me rephrase that: our rather <em>misunderstood</em> knight in shining armor.</p>

<p>In order to comprehend how strong params permits attributes, there are two essential methods we are required to understand.</p>

<h2>Requirements</h2>

<iframe src="//giphy.com/embed/NTzW6P8cpt90Q" width="480" height="298" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>The main reason for even <em>needing</em> strong parameters of any sort is to ensure that we&rsquo;re only passing safe, protected data from our user-accesible interface. We don&rsquo;t really expect most users to try to pass in malicious data, but it&rsquo;s always a possibility. Moreover, there are various situations (dealing with money, for example, or people&rsquo;s personal information) when delicate information must be passed around securely across the web.</p>

<p>So, how can we ensure that only the correct data is being passed through, and that too in a <em>safe</em> way? The Rails solution to this problem is to <strong>whitelist</strong> a set of attributes that should be allowed to be modified and passed through by a user (regardless of whether the role of the user is that of a guest, admin, etc.).</p>

<p>The first step to whitelisting any set of attributes is making sure that the parameter we are looking to &ldquo;whitelist&rdquo; is actually present. If we think about it, this is pretty logical: how can we pass in the correct attributes to create or update an object if don&rsquo;t first check that we have the parameter that contains the attributes we need? Only once we ensure that a parameter exists can we begin to strip away the &ldquo;blacklisted&rdquo; attributes.</p>

<p>In fact, that&rsquo;s exactly what this method does under the hood. If we peek into the <a href="https://github.com/rails/rails/blob/9ab2d030209d9608a6c866d83210f5b3b7d2319e/actionpack/lib/action_controller/metal/strong_parameters.rb#L246">source code</a> for this method, this is what we&rsquo;ll find:</p>

<pre><code class="ruby">def require(key)
    value = self[key]
    if value.present? || value == false
        value
    else
        raise ParameterMissing.new(key)
    end
end
</code></pre>

<p>At this point, we should be wondering what <code>self</code> is in the context of this method. In other words, what object responds to this <code>require</code> method? And what is this <code>ParameterMissing</code> error, exactly? Let&rsquo;s take a look at the <code>require</code> <a href="http://api.rubyonrails.org/classes/ActionController/Parameters.html#method-i-require">method documentation</a> to find out:</p>

<blockquote><p><code>require</code> ensures that a parameter is present. If it&rsquo;s present, returns the parameter at the given key, otherwise raises an ActionController::ParameterMissing error.</p></blockquote>

<p>Okay, so now we know that the error being raised in the conditional is actually an <code>ActionController::ParameterMissing</code> error. One question answered. But what does <code>require</code> get invoked on? Well, it turns out that the answer to that is a new instance of an <code>ActionController::Parameters</code> object!</p>

<p>There&rsquo;s a <a href="http://stackoverflow.com/a/18426829">great StackOverflow answer</a> that points this fact pretty explicitly. The <code>params</code> object that we refer to in the context of our controllers gets treated as though it&rsquo;s just an instance of a Ruby <code>Hash</code>. But in actuality, it&rsquo;s an instance of something called <code>ActionController::Parameters</code>, which is the object that responds to the <code>require</code> method. But more on that a little bit later.</p>

<p>For now, all that matters is that the <code>require</code> method returns a new instance of an <code>ActionController::Parameters</code> object for the key that is passed into it. If that key doesn&rsquo;t exist in the object, it throws an error. What does this mean, exactly? Well, when we write our <code>order_params</code> method in our <code>OrdersController</code>, it will begin like this:</p>

<pre><code class="ruby">def order_params
    params.require(:order)
end
</code></pre>

<p>We&rsquo;re actually returning the <em>value</em> of the parameter at the key that we&rsquo;re requiring (in our case, <code>order</code>):</p>

<pre><code class="ruby">params = ActionController::Parameters.new(order: { total: 100.00, number: 'ABC123' })

params.require(:order)
# =&gt; { total: 100.00, number: 'ABC123' }
</code></pre>

<p>And what&rsquo;s more: we&rsquo;re creating a new instance of an <code>ActionController::Parameters</code> object whenever we invoke <code>params</code> in our controller! Okay, so that&rsquo;s the first step: making sure our parameter exists. The second requires a bit more&hellip;<em>permission</em> on our part.</p>

<h2>Permissions</h2>

<p>Now that we&rsquo;re sure that our parameter exists, we need to actually <em>permit</em> the correct attributes on our objects. Since our users can add more books to their cart while they&rsquo;re shopping, they should be able to update the <code>total</code> of their <code>Order</code>. However, the <code>number</code> on their order is unique (and probably has an index on it), and is generated on the backend when it&rsquo;s created. We definitely <em>don&rsquo;t</em> want them to be able to update or modify that value at any point!</p>

<p>So, we need to <code>permit</code> a single attribute on our required parameter key. That means that our whitelisted params now look like this:</p>

<pre><code class="ruby">def order_params
    params.require(:order).permit(:total)
end
</code></pre>

<p>So what&rsquo;s happening here? Well, the <code>permit</code> method also is defined on the <code>ActionController::Parameters</code> class. It returns a new <code>ActionController::Parameters</code> instance, which includes only the given filters &mdash; the arguments that we&rsquo;re passing in here as symbols &mdash; and sets <a href="https://github.com/rails/rails/blob/9ab2d030209d9608a6c866d83210f5b3b7d2319e/actionpack/lib/action_controller/metal/strong_parameters.rb#L444">an attribute</a> using a <strong>protected instance method</strong> called <code>@permitted</code> on the newly-created <code>ActionController::Parameters</code> to be <code>true</code>.</p>

<p>This means that if we invoke <code>permit</code> on our required parameters, we&rsquo;ll return the actual hash, not the value for the parameter</p>

<pre><code class="ruby">params = ActionController::Parameters.new(order: { total: 100.00, number: 'ABC123' })

params.permit(:order)
# =&gt; { order { total: 100.00, number: 'ABC123' } }
</code></pre>

<p>Wait, but how does this happen? Well, if we look at the source code, we&rsquo;ll see that the permit method takes an array of arguments named <code>filters</code>, and then iterates through them to check what type of object they are:</p>

<pre><code class="ruby">def permit(*filters)
  params = self.class.new

  filters.flatten.each do |filter|
    case filter
    when Symbol, String
      permitted_scalar_filter(params, filter)
    when Hash then
      hash_filter(params, filter)
    end
  end

  unpermitted_parameters!(params) if self.class.action_on_unpermitted_parameters

  params.permit!
end
</code></pre>

<p>The reason for the <code>case</code> statement here is to handle nested attributes, which might look like this:</p>

<pre><code class="ruby">params.require(:order).permit(
    :total,
    :books: { 
        { # book_object_1 }, 
        { # book_object_2 }, 
        { # book_object_3 } 
    }
)
</code></pre>

<p>So if we really only need these two methods to require a parameter key and then permit the correct key and value pairs inside of it, what&rsquo;s the need for having a seperate method? Why do we need to encapsulate this logic? We could very well just do something like this, right? And it would work:</p>

<pre><code class="ruby">class OrdersController &lt; ApplicationController
    def create
        @order = Order.create(params.require(:order).permit(:total))
    end
end
</code></pre>

<p>It turns out that abstracting our strong params out into a private <code>order_params</code> method is just a good practice that was established by the Rails core team. The Rails guides <a href="http://edgeapi.rubyonrails.org/classes/ActionController/StrongParameters.html">explain this</a> pretty well:</p>

<blockquote><p>Using a private method to encapsulate the permissible parameters is just a good pattern since you&rsquo;ll be able to reuse the same permit list between create and update. Also, you can specialize this method with per-user checking of permissible attributes.</p></blockquote>

<p>Another reason for having a separate method is because things can get kind of tricky once you need to permit nested attributes. At that point, it&rsquo;s especially important to understand how these methods work.</p>

<p>Tune in next week, when I&rsquo;ll continue this deep dive by exploring the <code>ActionController::Parameters</code> class and answer the super confusing question of <em>where params get instantiated</em> (no really&hellip;where?), and what makes a parameter different from a hash (no really, I promise that they&rsquo;re different!). Until then, keep peeking into that source code and stay afloat like this guy:</p>

<iframe src="//giphy.com/embed/lpLWBoCnX1IkM" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>require</code> method ensures that a parameter key is present, and throws an error of it doesn&rsquo;t exist. The <code>permit</code> method filters out the keys that we want to whitelist based on the filters (which we pass in as symbols) that are passed into it.</li>
<li>Check out the documentation on <code>ActionController::Parameters</code> in the <a href="http://api.rubyonrails.org/classes/ActionController/Parameters.html">Rails guides</a>.</li>
<li>This blog post does a great job of explaining <a href="http://blog.trackets.com/2013/08/17/strong-parameters-by-example.html">permit and require</a> by example.</li>
</ul>

]]></content>
  </entry>
  
</feed>
