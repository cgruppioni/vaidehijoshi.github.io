<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: #technicaltuesdays | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/number-technicaltuesdays/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-11-01T10:15:53-05:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Digging Into the Finder Object Pattern]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/10/27/digging-into-the-finder-object-pattern/"/>
    <updated>2015-10-27T08:58:31-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/10/27/digging-into-the-finder-object-pattern</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/y5A0PlFbGIk4o" width="480" height="280" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Most developers aren&rsquo;t ever <em>completely</em> happy with their code. I&rsquo;m no exception to this stereotype &mdash; I almost always know that I could probably write a cleaner, more concise method, controller, or class. Usually, it&rsquo;s a matter of not know the best tool to reach for to refactor my code; eventually, I learn a new pattern or form of encapuslating logic that I later use to make my old code a lot better.</p>

<p>But a few weeks ago, I wrote 100 lines of beautiful code. I&rsquo;m talking about a goregous, straightforward, no-nonsense class that did a lot in a relatively few lines of Ruby. I still feel pretty proud of it (can you tell?), and part of the reason for this is because I also learned a new pattern while writing this class. I was actually pairing with another developer, and we wanted to try using a rather common Rails pattern to solve a problem we were running into again and again: messy queries in our controllers and models.</p>

<p>We both were familiar with the concept of &ldquo;skinny controllers&rdquo; and &ldquo;fat models&rdquo;, or the idea that your controllers shouldn&rsquo;t be responsible for containing the logic specific to a model. However, we also didn&rsquo;t want our models to get out of control in size, which is exactly what was starting to happen. So, we searched for a workaround, and found our answer in one of the most elegant patterns I&rsquo;ve seen in awhile: <strong>finder objects</strong>. Finder objects are simple Ruby classes that encapuslate the logic behind querying the database, and they are hands down, my new favorite kind of Ruby object.</p>

<!--more-->


<h2>Scopin&#8217; Down The Problem of Scopes</h2>

<iframe src="//giphy.com/embed/Y6eQqv3jdV4RO" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>In our bookstore application, we have <code>Order</code> objects, which represent the orders that a user places in our system. However, these are books that we&rsquo;re dealing with, and eventually we need to address the whole fulfillment process, which will need to be represented by a whole other set of models. For now, we&rsquo;ll try to keep it as simple as possible. Let&rsquo;s say that an <code>Order</code> has many <code>Shipments</code>, and each shipment represents a batch of <code>Book</code> objects (read: products) that need to be shipped out together.</p>

<p>Right off the bat, we know that our <code>Shipment</code> model will have some kind of state machine that will need to track the different stages of the shipment phase. Again, to keep it simple, let&rsquo;s say that there are five different stages or <code>state</code>s of a shipment:</p>

<ol>
<li>A shipment starts off as <code>processing</code> once an order has been placed.</li>
<li>Once it has been processed, it needs a label with the shipping address information, so it transitions to the <code>needs_label</code> state.</li>
<li>After it has a label generated, it&rsquo;ll need a tracking number, so transitions to the <code>needs_tracking</code> state.</li>
<li>Once it has a tracking number, it transitions to being <code>ready</code> for shipment.</li>
<li>Finally, when the shipment is actually sent out of the warehouse and to our shipping service, it should be marked as <code>shipped</code>.</li>
</ol>


<p>To be clear, this is a <em>super</em> simplified version of what would happen in a real-life application! Now, in our admin panel, let&rsquo;s say that we have a page that will render all of our shipments, which should always ordered by when they were created, so that our admins know which shipments to process, and in which order.</p>

<p>We can take it a step further and say that our main admin panel page &mdash; which will correspond to the <code>index</code> action in our controller, should show our admins the most urgent shipments that need their attention as soon as they log in; in other words, these would be the shipments that were created more than a week ago, but still haven&rsquo;t been processed.</p>

<p>I think we can all agree that basic Rails best practices should steer us away from doing something like this:</p>

<pre><code class="ruby">class ShipmentsController &lt; ApplicationController
  def index
    @shipments = Shipment.where(state: :ready)
            .where('created_at &lt;= ?', Time.zone.now + 7.days)
               .order(created_at: :desc)
  end
end
</code></pre>

<p>We <em>definitely</em> know that the controller really shouldn&rsquo;t be responsible for querying for the correct <code>Shipment</code> objects. All our controller should have to do is just render the correct ones, and not go digging for them in the database!</p>

<p>Okay, so we&rsquo;ll create some scopes for these queries instead. These scopes should live in our model, not in the controller, right? Let&rsquo;s see what our model might look like if we take that approach:</p>

<pre><code class="ruby">class Shipment &lt; ActiveRecord::Base
    belongs_to :order

    default_scope -&gt; { order(created_at: :desc) }
    scope :shipped, -&gt; { where(state: 'shipped') }
    scope :urgent, -&gt; {
        where('created_at &lt;= ?', Time.zone.now + 7.days)
    }
end
</code></pre>

<p>This cleans things up a decent bit! Scopes are actually part of the Active Record Query Interface, and they allow us to specify commonly-used queries which we can then actually reference and use in the form of method calls on our models themselves. They are really nothing more than defining class methods on a model:</p>

<pre><code class="ruby">class Shipment &lt; ActiveRecord::Base
    def self.shipped
        where(state: 'shipped')
    end
end
</code></pre>

<p>However, they&rsquo;re pretty wonderful because you can just chain them as method calls (<code>Shipment.urgent.shipped</code>), but all they do is execute the correct query for you:</p>

<pre><code class="ruby">Shipment.shipped
=&gt; SELECT "shipments".* FROM "shipments" WHERE "shipments"."state" = "shipped"
</code></pre>

<p>But the good news about scopes is also the bad <a href="news:">news:</a> you can just keep adding them and adding them, and chaining them onto everything. Our <code>Shipment</code> class has only three scopes at the moment, one of them being the <code>default</code> scope. But, we&rsquo;ll probably have a page that should only render only the shipments that are in the <code>needs_label</code> state, or a page that maps to a controller action which should only return shipments that are in the <code>needs_tracking</code> state. We <em>could</em> keep adding scopes and then have our controller actions call the scopes on the class to return the appropriate shipments from our database.</p>

<p>Or, we could try something a little different.</p>

<h2>Finder Objects</h2>

<iframe src="//giphy.com/embed/12bpEjD05ac2IM" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Our scopes don&rsquo;t actually add any new behavior to our model. As we saw earlier, they are nothing more than macros for querying for the correct rows from our <code>shipments</code> table in our database. So, it really doesn&rsquo;t make sense for our model to contain all this logic that doesn&rsquo;t <em>add</em> any new behavior to it.</p>

<p>It would be nice, however, if we could apply the rule of &ldquo;separation of concerns&rdquo; here, and have an entire class whose sole responsibility would be to dig up the correct objects based on the parameters we were querying by. Really, this class should do nothing more than <em>find the right objects</em>. You might even say that instances of this class are just&hellip;<em>finder objects</em>! (Get it? Man, I really hope you got it.)</p>

<p>Anyways, how might this class look? Well, we don&rsquo;t need any of the functionality from ActiveRecord, so we can create it as just a Plain Old Ruby Class:</p>

<pre><code class="ruby">class ShipmentFinder
end
</code></pre>

<p>Next, we&rsquo;ll want to tell our finder object which models to query for, so it will know how to construct our queries, and which table to query. Since we never really want to have this method accessible elsewhere, we can make it a private class method that will only be called from the context of another <code>ShipmentFinder</code> class method:</p>

<pre><code class="ruby">class ShipmentFinder
    class &lt;&lt; self
        private
        def resource_class
            ::Shipment
        end
    end
end
</code></pre>

<p>Now, we can use Rails&#8217; <a href="https://github.com/rails/arel">arel DSL</a> to construct a basic query. To do this, we&rsquo;ll need a method that returns the table, which can also be a private method since we&rsquo;ll never want to call it explicitly:</p>

<pre><code class="ruby">class ShipmentFinder
    class &lt;&lt; self
      private

      def table
        resource_class.arel_table
      end

      def resource_class
        ::Shipment
      end
    end
end
</code></pre>

<p>Now, we can write as many specific queries as we want. For example, we could write a <code>urgent_needs_tracking</code> class method that could constructs a query using two private methods, <code>needs_tracking</code> and <code>is_ready</code>:</p>

<pre><code class="ruby">class ShipmentFinder
    class &lt;&lt; self
      def urgent_needs_tracking
        query = needs_tracking.and(is_ready)

        resource_class.where(query)
      end

      def shipped
        resource_class.where(state: 'shipped')
      end

      private

      def urgent
        resource_class.where('created_at &lt;= ?', Time.zone.now + 7.days))
      end

      def is_ready
        table[:state].eq('ready')
      end

      def needs_tracking
        table[:state].eq('needs_tracking')
      end

      def needs_label
        table[:state].eq('needs_label')
      end

      def table
        resource_class.arel_table
      end

      def resource_class
        ::Shipment
      end
    end
end
</code></pre>

<p>Now we can rely on our <code>ShipmentFinder</code> class to find our shipments that have been created more than 7 days ago, and still don&rsquo;t have a tracking number. We also can add more functionality that can be used in specific instances, which is exactly what we&rsquo;ve done with our <code>needs_label</code> and <code>is_ready</code> private methods. We can use arel to construct queries using those methods to scope down what objects are actually returned. We don&rsquo;t have to do anything fancy, if we don&rsquo;t want to. Take a look at that <code>shipped</code> method &mdash; this is just using a simple <code>where</code> arel method to construct a query that reads like this: <code>SELECT "shipments".* FROM "shipments" WHERE "shipments"."state" = "shipped"</code>.</p>

<p>Finally, the last step: it&rsquo;s time for us to actually call on our finder object to do its job!</p>

<h2>Cleaner Querying, Cleaner Controllers</h2>

<p>Let&rsquo;s bring it all together by going back to our <code>ShipmentsController</code> and add our new finder object into it. Our <code>index</code> action should now be able to account for different types of shipments that our admins might want to query for. For now, we&rsquo;ll construct our controller to accept a query parameter in our params hash that will be that <code>status</code> of the types of shipments we want to return. Depending on the frontend framework we&rsquo;re using, this might be a dropdown or checkbox option that will set a value on the <code>status</code> key in our params hash.</p>

<p>Our controller action could now be rewritten to look something like this:</p>

<pre><code class="ruby">class ShipmentsController &lt; ApplicationController
  def index
    status = params[:status]
    status_method = status.to_sym

    if ShipmentFinder.respond_to?(status_method)
            @shipments = ShipmentFinder.send(status_method)
        else
            @shipments = Shipment.all
        end
  end
end
</code></pre>

<p>Here, we&rsquo;re accessing the query param from <code>params[:status]</code>, and turning it into a symbol (<code>status_method</code>). Next, we&rsquo;re using Ruby&rsquo;s super handy <code>respond_to?</code> method, and sending our <code>status_method</code> symbol to our <code>ShipmentFinder</code>. So, if our admin selects an option that sends the query param <code>urgent_needs_tracking</code>, we are telling our finder object to call that method, and execute that query. The return value of the query executed by our <code>ShipmentFinder</code>&rsquo;s <code>urgent_needs_tracking</code> method is what will be set as the instance variable <code>@shipments</code> for the duration of this action on the controller.</p>

<p>If no query param is set, or if our <code>ShipmentFinder</code> doesn&rsquo;t have a method that maps to a query param, we&rsquo;re just returning all of our <code>Shipment</code> objects by default.</p>

<p>This is quite an improvement from our earlier code, which had our controller digging for rows in a database that it really didn&rsquo;t have anything to do with. Now, we&rsquo;ve separated our concerns into a new finder object, which exists as its own query interface on its own. It&rsquo;s also worth noting that sometimes, creating a finder object can be overkill, and sometimes, if we have a lot of finder objects, we&rsquo;d probably want to abstract a lot of this functionality out into a <code>BaseFinder</code> class, which our finder objects could inherit from. But this is definitely a great start. No more digging for us!</p>

<iframe src="//giphy.com/embed/FqEDV3gjMhqRG" width="480" height="267" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The finder object pattern helps keep your model logic strictly related to a class&#8217; behavior, while also keeping your controller&rsquo;s skinny. Since they are nothing more than plain old Ruby classes, finder objects don&rsquo;t need to inherit from <code>ActiveRecord::Base</code>, and should be responsible for nothing more than executing queries. Read more about them on this <a href="http://twin.github.io/finder-objects/">fantastic blog post</a>.</li>
<li>Scopes are a great tool to use if a finder object seems like more work than it&rsquo;s really worth, given the size and context of your application. Read more about scopes in the Rails <a href="http://guides.rubyonrails.org/active_record_querying.html#scopes">documentation</a>.</li>
<li>Want to see more examples of implementing finder objects? Check out this <a href="https://speakerdeck.com/weppos/maintaining-a-5yo-ruby-project-shark-edition?slide=103">slidedeck</a> series.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Solutions for Slugs of All Sizes: Acts_as_url + To_param]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/10/20/solutions-for-slugs-of-all-sizes-acts-as-url-plus-to-param/"/>
    <updated>2015-10-20T08:17:21-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/10/20/solutions-for-slugs-of-all-sizes-acts-as-url-plus-to-param</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/g5FB33d3GVUkg" width="480" height="288" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Last week was my first week of working from home, which meant two things: spending a lot of time with my computer and limited time with other human beings and, more importantly, debugging things on my own without having anyone nearby to ask for help. The latter of the two actually ended up reaffirming the fact that I actually <em>can</em> debug a decent amount of things on my own if I just power through and am stubborn enough to not give up.</p>

<p>I also learned something interesting about the debugging process: while we&rsquo;re learning, we often solve the same problem again and again. At least, this was the case for one of the features I was working on which involved using an object&rsquo;s slug to generate a url. As I started thinking through how to approach solving this, I immediately had the feeling that I had done something similar in another project. Digging through another repository&rsquo;s source code confirmed my suspicions, and I rediscovered the <code>stringex</code> gem and its multiple libraries, including <code>acts_as_url</code>!</p>

<p>All of this begs the question: why didn&rsquo;t I remember that this gem existed &mdash; or that I had already used it? My guess is that it&rsquo;s because I neither wrote about it nor understood how it worked until a few days ago. This week, it&rsquo;s time to rectify that situation and dive into the <code>acts_as_url</code> library and find a solution for all slug problems, once and for all!</p>

<!--more-->


<h2>The Other Kind of Slug</h2>

<iframe src="//giphy.com/embed/C1aCu8kUyF6p2" width="480" height="350" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>We all are familiar with the Rails mantra of <em>convention over configuration</em>, aka making the lives of developers easier by eliminating the need for them to make decisions about how to structure their code. Now, this design paradigm is pretty fantastic, particularly when we&rsquo;re first learning a new framework. But eventually, there comes a time when we need to tweak our code&rsquo;s conventions just a tiny little bit.</p>

<p>What&rsquo;s an example of this? Well, take Rails convention of finding an object by it&rsquo;s <code>id</code>. This standardization pops up all over the place, but the one that we&rsquo;re particularly concerned with is the generation of a url. By default, Rails applications will build a URL path for the <code>show</code> action of any given controller based on the primary key (aka the <code>id</code> column in our database) of the object that we&rsquo;re trying to &ldquo;show&rdquo;.</p>

<p>Let&rsquo;s put this in context of our bookstore application. We have a bunch of <code>Book</code> objects, and we want to iterate through their titles and then link to their individual &ldquo;show&rdquo; pages. A very basic, not-at-all-fancy template might look something like this:</p>

<pre><code class="slim">h2 Books!
- @books.each do |book|
    p = link_to book.title, book_path(book)
</code></pre>

<p>It&rsquo;s important to note that we&rsquo;re actually passing in the <code>book</code> instance here &mdash; an <code>ActiveRecord</code> object, and <em>not</em> the <code>book</code>&rsquo;s <code>id</code>. Why is this important? Because there&rsquo;s a method that Rails is using to convert the <code>Book</code> object into a URL in order to generate the correct address for our <code>book_path</code>. That&rsquo;s why we need to pass it an <code>ActiveRecord</code> object, because the method that&rsquo;s being called expects an object and returns the <code>id</code> as parameters in the url. What does this look like, exactly? Well, right now our <code>book_path</code> takes a <code>Book</code> instance and creates a path that looks like this: <code>localhost:3000/books/25</code>.</p>

<p>Which is fine! Actually, it&rsquo;s more than fine: it&rsquo;s the expected behavior given our Rails mantra of convention over configuration. But, what if we actually <em>want</em> to configure this a little bit more. What if, instead of using the primary key of our <code>Book</code> instances, we wanted to use the title of the book? It would be lovely if we could link someone to a particular book&rsquo;s page with a more human-readable url (for example, something like <code>awesomebookstore.com/books/the-bell-jar</code> in production).</p>

<p>There&rsquo;s a solution for this problem, and it&rsquo;s called slugs. Slugs are a solution for semantic URL generation, which is also sometimes referred to as &ldquo;RESTful&rdquo; or &ldquo;SEO-friendly&rdquo; URL generation. As our application grows, not only would we want our URLs to be user-friendly, but we probably also will want them to be optimized for search engine results. So, we need to change our application&rsquo;s configuration to use a slug.</p>

<p><em>Protip:</em> if anyone ever pop quizzes you about where the term &ldquo;slug&rdquo; comes from, you can totally school them with the following interesting fact: a &ldquo;slug&rdquo; used to be <a href="https://en.wikipedia.org/wiki/Slug_(publishing)">a shorter name</a> given to a newspaper article while it was in production; during the editing process, the article would be labeled by its slug, which would more specifically indicate the content of the story to the editors and reporters. The more you know, amirite?</p>

<p>There are obviously a lot of ways to approach this, but why reinvent the wheel by writing a bunch of methods that someone else has already written? Let&rsquo;s make use of someone&rsquo;s open source work and use the <code>acts_as_url</code> library to get the job done for us!</p>

<h2>Don&rsquo;t Let Slugs Slow You Down</h2>

<iframe src="//giphy.com/embed/11zeCgKZ1MaNuE" width="480" height="342" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>The <code>acts_as_url</code> library is actually part of the <code>stringex</code> gem, which adds some useful extensions to Ruby&rsquo;s <code>String</code> class. After we add this gem to our <code>Gemfile</code> (<code>gem "stringex"</code>) and run <code>bundle install</code>, we can get started doing a quick setup.</p>

<p>The documentation for this library is fairly straightforward, and a quick read-through gives us a good idea of what we need to do in order to make it work properly. The basic implementation of this library is four-fold:</p>

<ol>
<li>We need a column in our database that will map to the attribute used in generating our url.</li>
<li>We need to call the <code>acts_as_url</code> method in our model using the attribute name that we want to use for generating our url.</li>
<li>We need to override Rails&#8217; <code>to_param</code> method (Confused? Hang tight, we&rsquo;ll get there in a second!)</li>
<li>We need to <code>find_by</code> our new url attribute inside of our controllers.</li>
</ol>


<p>Let&rsquo;s take it step by step. First, we&rsquo;ll write a migration that will add a <code>slug</code> column to our <code>books</code> database. This is going to be the column that will map to a <code>slug</code> attribute on our <code>Book</code> objects:</p>

<pre><code class="ruby">class AddSlugColumnToBooks &lt; ActiveRecord::Migration
  def change
    add_column :books, :slug, :string
  end
end
</code></pre>

<p>Once we run <code>rake db:migrate</code> and add this attribute, we will want to add the <code>acts_as_url</code> class method to our <code>Book</code> model.</p>

<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  acts_as_url :title, url_attribute: :slug
end
</code></pre>

<p>The default behavior of this method expects that we have a column and attribute called <code>url</code> on our object. Since we aren&rsquo;t using the default attribute name, we need to specify the name of the attribute that we&rsquo;re using to store the generated url string. Thankfully, <code>acts_as_url</code> takes a bunch of options, including <code>url_attribute</code>, which is what we&rsquo;re using here. There are some other useful options <a href="https://github.com/rsl/stringex">worth checking out</a> in the documentation, including <code>scope</code>, <code>limit</code>, <code>truncate_words</code>, and <code>blacklist</code>.</p>

<p>Next, we&rsquo;ll need to override Rail&rsquo;s <code>to_param</code> method in order to actually <em>use</em> our generated url attribute. Basically, we&rsquo;ll just want to write our own <code>to_param</code> method and return our <code>slug</code> attribute from inside of it.</p>

<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  acts_as_url :title, url_attribute: :slug

  def to_param
    slug
  end
end
</code></pre>

<p>And finally, we need to make sure that we&rsquo;re finding our object using the appropriate attribute from within the context of our controller. The documentation suggests we use
the <code>find_by_url</code> method, but we could also use the <code>find_by</code> method in our controller as well.</p>

<pre><code class="ruby">class BooksController &lt; ApplicationController
  def show
    @book = Book.find_by(slug: params[:id]).decorate
  end
end
</code></pre>

<p>Nothing changes about how our controller works and we can still do all the fancy things we were doing before, like use a decorator (<a href="http://vaidehijoshi.github.io/blog/2015/01/13/tidying-up-those-views-using-decorators-in-rails/">Remember those?</a>). The only thing that happens now is that our original <code>book_path</code> helper will now use the <code>book</code> instance we passed it to generate a url with a slug instead of the primary key!</p>

<p>Success! We&rsquo;ve done it! Actually, we&rsquo;ve <em>almost</em> done it. One tiny little thing that I always forget is all of the books that already exist in our database. What about them? They all have a <code>slug</code> attribute, sure, and a <code>slug</code> column &ndash; but there&rsquo;s a slight problem: the column is empty! So we can&rsquo;t <code>find_by</code> the <code>slug</code> attribute for those books, can we? In fact, if we try to call <code>to_param</code> on any of our preexisting <code>Book</code> instances right now, all we&rsquo;ll get is <code>nil</code>!</p>

<p>No worries, we just need to call a method inside of our console:</p>

<pre><code class="ruby">♥ rails c
Loading development environment (Rails 4.1.4)
irb(main):001:0&gt; Book.initialize_urls
</code></pre>

<p>Now all of the <code>Book</code> instances that had empty <code>slug</code> attributes have ben initialized, and we&rsquo;re good to go! Right? Wrong. Because I haven&rsquo;t explained the whole <code>to_param</code> situation yet, and I promised that I would get to it. Now&rsquo;s the time to figure out the magic behind that!</p>

<h2>Rails Non-Sluggish Solution: <code>to_param</code></h2>

<p>The Rails solution to generating params for an object&rsquo;s url path comes from its elegant <code>to_param</code> method. By default, this method just calls <code>to_s</code> on a Plain Old Ruby Object, and converts it to an instance of Ruby&rsquo;s <code>String</code> class. However, there are plenty of places where Rails itself <em>overrides</em> this method (which explains why we also have to do it in the context of our own controller)!</p>

<p>In fact, the Rails documentation even explains when and how to go about redefining the implementation of this method:</p>

<blockquote><p>&ldquo;Notably, the Rails routing system calls <code>to_param</code> on models to get a value for the <code>:id</code> placeholder. <code>ActiveRecord::Base#to_param</code> returns the <code>id</code> of a model, but you can redefine that method in your models.&rdquo;</p></blockquote>

<pre><code class="ruby">class User
  def to_param
    "#{id}-#{name.parameterize}"
  end
end
</code></pre>

<p>Of course, we could have easily redefined this in the context of each of our models, but using the <code>acts_as_url</code> library reduces the amount of duplicated code that we need in each of our models, and is pretty sophisticated in that it allows us to use <em>different</em> attributes across different models to generate our url path.</p>

<p>Interestingly, <a href="https://github.com/rails/rails/blob/7f18ea14c893cb5c9f04d4fda9661126758332b5/activemodel/lib/active_model/conversion.rb#L71">the source code</a> for Rails&#8217; <code>to_param</code> method reveals some elegant checks as well. This method first checks whether the object as been persisted to the database, and then returns a string representing the object&rsquo;s key. We can actually see how the <code>to_key</code> method is being called from <em>inside</em> of <code>to_param</code>, and how the default return value of an unpersisted object&rsquo;s param will be <code>nil</code>. This is the magic that goes on under the hood when we were trying to find the <code>slug</code> attributes for all of those <code>Book</code> instances before we called <code>initialize_urls</code> on them!</p>

<p>So, even though slugs have a <em>reputation</em> of being slow, now we know how to speed through this problem with an elegant and quick solution! I can&rsquo;t say the same for this poor guy, though:</p>

<iframe src="//giphy.com/embed/1KJPg114jm68U" width="480" height="169" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>acts_as_url</code> library expects an <code>url</code> attribute on a model, and uses that to generate the path for an object. You need to override Rails&#8217; <code>to_param</code> method that, by default, will use the <code>id</code> of an object to generate its path.</li>
<li>This <a href="https://gist.github.com/jcasimir/1209730">awesome gist</a> by Jeff Casimir is the best write-up on slugs and Rails&#8217; url generation out there. Give it a read!</li>
<li>The original <code>to_param</code> method used to be defined inside of <code>ActiveRecord::Base</code>, but has since moved to the <code>ActiveModel::Conversion</code> module, which handles default conversions, including <code>to_model</code>, <code>to_key</code>, and <code>to_partial_path</code>. Read more about how these methods work in the Conversion <a href="http://apidock.com/rails/ActiveModel/Conversion">module documentation</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stop Worrying and Start Being Concerned: ActiveSupport Concerns]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/10/13/stop-worrying-and-start-being-concerned-activesupport-concerns/"/>
    <updated>2015-10-13T09:22:16-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/10/13/stop-worrying-and-start-being-concerned-activesupport-concerns</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/iQA2hMPX88icM" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>A few weeks ago, while learning everything I never knew about <a href="http://vaidehijoshi.github.io/blog/2015/09/29/using-pundit-the-cool-kid-of-authorization/">user authorization</a>, I also stumbled upon a cool refactoring pattern that I didn&rsquo;t even know existed. This pattern is based on the simple idea of Ruby modules and mixins, but is particularly handy when it comes to dealing with class methods and callbacks.</p>

<p>ActiveSupport is a pretty massive component within Rails, and it&rsquo;s responsible for a ton of different functionality, including language extensions and utilities. I last wrote about ActiveSupport back when we were exploring the <a href="http://vaidehijoshi.github.io/blog/2015/09/01/inflections-everywhere-using-activesupport-inflector/">Rails inflector</a> and the libraries it provides for handling the pluralization of different strings. This was way back in September, and at the time, my understanding of ActiveSupport was pretty limited. It turns out that yes, ActiveSupport does provide a bunch of different patterns to transform simple Ruby strings&hellip;but it also has a lot more going on inside of it. For example, the <strong>ActiveSupport Concern module</strong>, which only recently made its debut in Rails 4.</p>

<p>The ActiveSupport::Concern wrapper is an interesting way of encapsulating&hellip;well, certain functionality that you might be <em>concerned</em> with. These concerns take advantage of two directories that are automatically part of the load path within a Rails application: <code>app/models/concerns</code> and <code>app/controllers/concerns</code>. So, how do you write a concern, and what should go inside of it? Don&rsquo;t worry, that&rsquo;s exactly what we&rsquo;ll concern ourselves with next.</p>

<!--more-->


<h2>Should We Be Concerned?</h2>

<iframe src="//giphy.com/embed/374pcIBVEGb6g" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Concerns are meant to make our lives less complicated. Or at the very least, we should be less concerned about the quality of our code if we use concerns, right? But what are ActiveSupport&rsquo;s Concerns really meant to be used for? And how do we know if we should be using them? Well, to answer this question, we can turn to the creator of Rails himself. In a blog post pre-Rails 4 titled <em>Put chubby models on a diet with concerns</em>, DHH explains when and why to consider using ActiveSupport&rsquo;s Concern module:</p>

<blockquote><p>&ldquo;Concerns encapsulate both data access and domain logic about a certain slice of responsibility. Concerns are also a helpful way of extracting a slice of model that doesn’t seem part of its essence (what is and isn’t in the essence of a model is a fuzzy line and a longer discussion) without going full-bore Single Responsibility Principle and running the risk of ballooning your object inventory.&rdquo;</p></blockquote>

<p>When we talk about concerns, what we really are honing in on is the most effective <em>separation of concerns</em>. I really like the way that David thinks of models having an &ldquo;essence&rdquo;, and I think that this is a great way of approaching when and when <em>not</em> to use a concern.</p>

<p>Let&rsquo;s look at our bookstore application. We have an <code>User</code> model for anyone that signs up to use our application. Whenever a <code>User</code> signs up, we want to send them an email telling them that they&rsquo;ve been registered, and probably highlighting some of the cool things that they can do to set up their profile on our application. Now, this seems like something that only the <code>User</code> model would be concerned with, right? Well, yes, until we realize that we have another model that needs to share this same functionality!</p>

<p>For example, we now have organizations that want to sign up for our application. They also need to receive the same email and be &ldquo;registered&rdquo;. As our application grows, we might even want to create a <code>Registration</code> model, which would belong to an <code>User</code> and <code>Organization</code>. Now, obviously we could accomplish what we wanted to by just adding the same lines of code to both models, but that makes for neither DRY code, nor a great separation of concerns. But wouldn&rsquo;t it be great if we could take this piece of &ldquo;registration&rdquo; functionality, wrap it up, and only pull it out when we need to use it? It turns out that is exactly what we can do with <code>ActiveSupport::Concern</code>.</p>

<h2>Extending Our Concerns</h2>

<iframe src="//giphy.com/embed/dnNuJUQvEnmjC" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Before we write our concern, let&rsquo;s look at what our <code>User</code> model looks like. Here&rsquo;s a truncated version that contains only the logic pertaining to registering a user:</p>

<pre><code class="ruby">class User &lt; ActiveRecord::Base
    after_commit :register_user, on: :create

    def register_user
        # Where our logic for registering a user
        # would go. Would call on a background job
        # to perform and send our registration email.
    end
end
</code></pre>

<p>We very well <em>could</em> stick this inside of our <code>organization.rb</code> model file, but there&rsquo;s a better way to do this. There are a few steps to creating a concern, the first of which is recognizing where to put it! Since we&rsquo;re creating a concern for a model, this will live inside of our <code>app/models/concerns</code> directory. We&rsquo;ll call this concern a  <code>Registerer</code> concern, since that&rsquo;s its single responsibility, and we can preemptively namespace our concern under <code>Users</code>, which would make its path <code>app/models/concerns/users/registerer.rb</code>.</p>

<p>Next, we&rsquo;ll want to <code>extend</code> the Rails <code>ActiveSupport::Concern</code> module itself from within our concern:</p>

<pre><code class="ruby">module Users
    module Registerer
        extend ActiveSupport::Concern
    end
end
</code></pre>

<p>Now, for the actual writing, there&rsquo;s one method that&rsquo;s going to be our new best friend: the <code>included</code> method, which takes a block. A little-known fact about this callback is that it&rsquo;s actually defined by Ruby&rsquo;s <code>Module</code> class, and it&rsquo;s called whenever a module is &ldquo;included&rdquo; into another class or module. This is where we&rsquo;ll put the important class methods and callbacks that we want to be shared amongst the models that will use our concern.</p>

<pre><code class="ruby">module Users
    module Registerer
        extend ActiveSupport::Concern

        included do
            has_one :registration, dependent: :destroy

            after_commit :register_user, on: :create
        end

        def register_user
            send_registration_email(self)

            touch(:registered_at)
        end

        def send_registration_email(self)
            RegistrationEmailerJob.perform_later(self)
        end
    end
end
</code></pre>

<p>This is mostly straightforward. All the logic for a registration now lives in this single file, including the creating of a registration association on our target object (in this case, the <code>User</code> model), the registering of a user by passing our <code>User</code> instance (<code>self</code>) to our <code>RegistrationEmailerJob</code>, and the updating of the <code>registered_at</code> attribute on our <code>User</code> model using the <a href="http://vaidehijoshi.github.io/blog/2015/09/22/working-hard-or-hardly-working-part-2-custom-jobs/">touch method</a> &mdash; assuming, of course, that we&rsquo;ve defensively coded this attribute onto our <code>User</code> model. We&rsquo;re also able to use the <code>after_commit</code> callback hook, since the <code>included</code> method can accept callback names as parameters.</p>

<p>Now that we have all this code in one place, how do we add it to our model? Well, we can do it in a single line:</p>

<pre><code class="ruby">class User &lt; ActiveRecord::Base
    include Users::Registerer
end
</code></pre>

<p>All we need to do is <code>include</code> our concern, just as we would a module. And down the road, when we find out that we need to create <code>Organization</code> model that shares this set of functionality, all we need to do is add the exact same line to our new model:</p>

<pre><code class="ruby">class Organization &lt; ActiveRecord::Base
    include Users::Registerer
end
</code></pre>

<p>And here&rsquo;s the really nice part about utilizing concerns in this way: when we realize that we need to change how this works &mdash; maybe we need to add another job or service object, or perhaps another, more specific callback &mdash; we can add it to one place and update our logic in a single file! This ties in quite nicely to DHH&rsquo;s point of a model&rsquo;s &ldquo;essence&rdquo;. In this case, being able to be &ldquo;registered&rdquo; isn&rsquo;t necessarily something that pertains to the <code>User</code> model specifically. But, it also doesn&rsquo;t need to be its own <em>object</em> per se. Instead, we really just need a set of methods that can be available to be invoked upon an object, which is exactly what <code>ActiveSupport::Concern</code> provides us with.</p>

<h2>Helpful Inclusion</h2>

<p>Because concerns are so simple to extend and include, there are lots of use cases for them. We learned earlier that Rails comes with two <code>concerns</code> directories preloaded: one for <code>models</code>, and another for <code>controllers</code>. Let&rsquo;s look at a practical example for using <code>ActiveSupport::Concern</code> in the context of a controller.</p>

<p>We <a href="http://vaidehijoshi.github.io/blog/2015/09/29/using-pundit-the-cool-kid-of-authorization/">recently added</a> the <code>pundit</code> gem to our bookstore app for user authorization. But we only had a few controller actions that actually <em>needed</em> to be authorized; the rest of our controllers didn&rsquo;t need any authorization, because they could be accessed by anyone. Our <code>Reviews</code> controller was being authorized, for example, but our <code>Comments</code> controller didn&rsquo;t need any authorization whatsoever.</p>

<p>So, for the controllers that <em>didn&rsquo;t</em> need authorization, what did we do? Well, we were adding some <code>skip_after_actions</code> lines, which were instructions that the <code>pundit</code> gem documentation had given us:</p>

<pre><code class="ruby">class CommentsController &lt; ApplicationController
  skip_after_action :verify_authorized
  skip_after_action :verify_policy_scoped

  # RESTful controller actions go here!
end
</code></pre>

<p>Now, imagine we also have a <code>BlogsController</code> with just an <code>index</code> action API endpoint, which doesn&rsquo;t need to be authorized. And maybe we also have <code>TagsController</code>, which also doesn&rsquo;t need to be authorized by <code>pundit</code>. We <em>could</em> copy and paste these two lines into every single controller&hellip;<em>or</em>, we could use our newfound knowledge of <code>ActiveSupport::Concern</code>!</p>

<p>Let&rsquo;s share some of this code, shall we? We can create a <code>skip_authorized.rb</code> file inside of <code>app/controllers/concerns</code>. And inside of it, we&rsquo;ll include <code>Pundit</code> &mdash; otherwise, our <code>skip_after_actions</code> will have no idea what actions we&rsquo;re trying to skip! Our concern might look something like this:</p>

<pre><code class="ruby">module SkipAuthorized
  extend ActiveSupport::Concern

  included do
    skip_after_action :verify_authorized
    skip_after_action :verify_policy_scoped
  end
end
</code></pre>

<p>Pretty simple, right? And suddenly, our <code>CommentsController</code>, <code>BlogsController</code>, <code>TagsController</code>, and pretty much <em>every single</em> controller that we want to share these <code>skip_after_action</code> callbacks now can be refactored to have this single line:</p>

<pre><code class="ruby">class CommentsController &lt; ApplicationController
    include SkipAuthorized

    # RESTful controller actions go here!
end
</code></pre>

<p>And now, if we wanted to <code>rescue</code> from a <code>Pundit::UnauthorizedError</code>, we could add a single line, into a single file&hellip;but all of our controllers would mix that in! Similarly, we could create an <code>Authorized</code> concern for every controller that needed to actually implement <code>pundit</code> authorization. See, there&rsquo;s no need to worry for the rest of our days, because instead, we can just be concerned &mdash; ActiveSupport concerned!</p>

<iframe src="//giphy.com/embed/jfw9xNEouCJO" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>ActiveSupport&rsquo;s <code>Concern</code> module allows us to mix in callbacks, class and instance methods, and create associations on target objects. This module has an <code>included</code> method, which takes a block, as well as an <code>append_features</code> method and <code>class_methods</code> block, which you can read about in <a href="http://api.rubyonrails.org/classes/ActiveSupport/Concern.html#method-i-included">the source code</a>.</li>
<li>This <a href="http://engineering.appfolio.com/2013/06/17/ruby-mixins-activesupportconcern/">blog post</a> is pretty fantastic in its explanation of mixins, modules, and concerns.</li>
<li>Concerns are a little controversial in Railsland. This <a href="http://www.slideshare.net/justingordon/rails-conf-2014concernsdecoratorspresentersserviceobjectshelpershelpmedecideapril222014">slide deck</a> from RailsConf 2014 shares a bit about why that&rsquo;s the case.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fleeting Filing With Ruby Tempfile]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/10/06/fleeting-filing-with-ruby-tempfile/"/>
    <updated>2015-10-06T08:46:30-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/10/06/fleeting-filing-with-ruby-tempfile</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/3ViDyv13D9HQQ" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>There are times in a Ruby program or Rails application that one comes to a single realization: <em>Oh no, I need to deal with an external file!</em> For larger applications, this might manifest as a request to your Amazon S3 bucket for a file, which you then need to modify in some way, or perhaps just simply read and have access to. But sometimes, even a simple Ruby script or plain old Ruby class may need to read or write to an external file.</p>

<p>I honestly didn&rsquo;t know a lot about Ruby&rsquo;s File class (wait, Ruby has a <em>file</em> class?! Yes, yes it does.) until recently, when I had to handle a situation that would allow me to download files from a file storage service (such as S3), and then process the file locally on my machine. The process was a bit complicated, and I still think that I have more to learn about how it actually works. But, one thing that I <em>did</em> actually start to wrap my head around is <strong>Ruby Tempfiles</strong>. Yup, that&rsquo;s right: not only does Ruby have a <code>File</code> class &mdash; it also has a <code>Tempfile</code> class.</p>

<p>It turns out that these two classes intersect quite a bit, and it can be a little confusing to know how they differ. The only way to really understand Ruby&rsquo;s <code>Tempfile</code> class is to play around with it and create some tempfiles. So let&rsquo;s get filin&#8217;!</p>

<!--more-->


<h2>To File Or To Tempfile</h2>

<iframe src="//giphy.com/embed/TxIwSAVQL18WI" width="480" height="430" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>The reason that the <code>Tempfile</code> class and <code>File</code> class seem so similar &mdash; and can therefore be so confusing &mdash; is because the <code>Tempfile</code> class actually inherits from its parent delegate class, which just so happens to be&hellip;<code>File</code>! So, tempfiles are actually just a type of file. So, what can you do with files in Ruby? And what makes tempfiles different from a regular old file?</p>

<p>Well, the <a href="http://ruby-doc.org/core-2.2.0/File.html">documentation</a> for <code>File</code> objects is hugely informative, and if we dove into it, we&rsquo;d learn that Ruby files actually inherit from a class called <code>IO File</code>. But let&rsquo;s not get too distracted here: what can we do with files, again? Well, we can read a file&rsquo;s data, we can write more data to it, and we can even change its permissions (i.e. who can access and write to the file). Pretty straightforward, right?</p>

<p>Now, onto tempfiles. As their name would suggest, they&rsquo;re files that are temporary. But even though they are named pretty well, it still might not be clear in what <em>way</em> these files are temporary. Well, we can create tempfiles in the same way that we create regular Ruby files, but what makes them unique is that tempfiles <strong>only exist as long as there is a reference to them</strong>. In other words, tempfiles get deleted automatically by the Ruby garbage collector. If no variable is pointing (read: assigned) to a tempfile, the garbage collector will &ldquo;finalize&rdquo; the tempfile object, and the file would be deleted from our system.</p>

<p>So&hellip;why is this significant? Well, what would happen if we tried to access a tempfile that Ruby has deleted? Bad things, that&rsquo;s what! Well, we&rsquo;d actually just get an error, because we&rsquo;d be trying to access a file at a path that doesn&rsquo;t exist anymore. But still, things could get pretty bleak if we didn&rsquo;t know what was going on &mdash; or worse, if we didn&rsquo;t fundamentally understand how tempfiles worked!</p>

<p>A good rule of thumb for deciding whether or not to use a tempfile is this: if we need access to the file outside of the context of our Ruby script, we probably shouldn&rsquo;t be using a tempfile. However, if we want to temporarily create, read, or write to a file, and then have Ruby delete it for us (for free!) when we&rsquo;re done using it, then a tempfile is our new best friend!</p>

<h2>The Order of Filing Operations</h2>

<iframe src="//giphy.com/embed/xTiTnjZAjQipGn9JFS" width="480" height="143" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>When it comes to creating files, there&rsquo;s a certain order of operations with method invocation. Even though the documentation for the <code>Tempfile</code> class has a list of helpful methods for us to use, there&rsquo;s a lot of less obvious functionality at our disposal, as long as we know where to look. Because the Ruby <code>Tempfile</code> essentially inherits from <code>File</code>, a tempfile behaves just like a file object. This means that we can call any <code>File</code> instance method on a <code>Tempfile</code> object. This is particularly important to note since some of the most common methods that are called on a tempfile are actually defined within the <code>File</code> class. So, if we couldn&rsquo;t find where a particular method on a tempfile was being defined, it probably means that we need to go look inside of the <code>File</code> class.</p>

<p>Okay, enough talk about where to <em>find</em> these methods; let&rsquo;s figure out which methods are actually pertinent to tempfiles. Both files and tempfiles share a sequence of events: generally, we create the file, then we read or write to it, and then we close it. But with tempfiles, there&rsquo;s a little twist at the end. Let&rsquo;s take a look at the order of filing operations:</p>

<h3>1. <code>new</code></h3>

<p>This method is pretty self-explanatory: it&rsquo;s what we&rsquo;ll use to create a new tempfile. This comes from the <code>File</code> class, and takes a single argument: the name of our file. Let&rsquo;s create a tempfile called <code>cats</code>:</p>

<pre><code>♥ irb
irb(main):001:0&gt; tempfile = Tempfile.new('cats')
=&gt; #&lt;Tempfile:/var/folders/v7/8rk39kc11ln54w3tl7twrhwc0000gn/T/cats20151005-24769-ac6qgw&gt;
</code></pre>

<p>This creates a unique filename in our operating slystem&rsquo;s temp directory, and it contains our filename <code>cats</code> in its basename. If we wanted to find out exactly <em>where</em> in our temp directory this file lives, we could just ask it for its path using &mdash; you guessed it &mdash; the <code>path</code> method:</p>

<pre><code>irb(main):002:0&gt; tempfile.path
=&gt; "/var/folders/v7/8rk39kc11ln54w3tl7twrhwc0000gn/T/cats20151005-24769-ac6qgw"
</code></pre>

<p>We could also specify the extension of the file that we&rsquo;re creating (i.e., <code>pdf</code>, <code>gif</code>, etc.). However, it&rsquo;s not as simple as just appending it to our filename; if we do that, this is what happens:</p>

<pre><code>irb(main):003:0&gt; Tempfile.new('cats.pdf').path
=&gt; "/var/folders/v7/8rk39kc11ln54w3tl7twrhwc0000gn/T/cats.pdf20151006-24769-xvpyh0"
</code></pre>

<p>Not great! We don&rsquo;t want our extension to be a <em>part</em> of our filename, we want it to be at the end, obviously! Luckily, the <code>new</code> method <a href="http://makandracards.com/makandra/13719-ruby-how-to-ensure-a-tempfile-s-extension">allows us</a> to pass the filename and extension as an array:</p>

<pre><code>irb(main):004:0&gt; Tempfile.new([ 'cats', '.pdf' ]).path
=&gt; "/var/folders/v7/8rk39kc11ln54w3tl7twrhwc0000gn/T/cats20151006-24769-1kzx615.pdf"
</code></pre>

<p>Much better! Now, let&rsquo;s open this file up.</p>

<h3>2. <code>binmode</code></h3>

<p>The next step is to put our file into binary mode by using the <code>binmode</code> method. As <a href="http://ruby-doc.org/core-2.0.0/IO.html#method-i-binmode">the documentation</a> explains, this method is what changes how we write data to the tempfile&rsquo;s binary.</p>

<pre><code>irb(main):005:0&gt; tempfile.binmode
=&gt; #&lt;File:/var/folders/v7/8rk39kc11ln54w3tl7twrhwc0000gn/T/cats20151005-24769-ac6qgw&gt;
</code></pre>

<p>This disables us from encoding and creating new lines, and it changes the way that we write content; setting a file to binary mode forces Ruby to treat the content as ASCII-8BIT. There&rsquo;s also a handy <code>binmode?</code> method that we can use to check whether our file is in binary mode or not.</p>

<h3>3. <code>write</code></h3>

<p>Finally, once we&rsquo;re in binary mode, we actually write to our file! And of course, the tool for the job is the <code>write</code> method. This takes a parameter of whatever it is that you want to write to the file.</p>

<pre><code>irb(main):006:0&gt; file.write("meow meow meow")
</code></pre>

<p>Interestingly, this method is <a href="http://ruby-doc.org/core-2.2.3/IO.html#method-c-write">defined</a> in the <code>IO</code> class, which subclasses into <code>StringIO</code>.</p>

<h3>4. <code>rewind</code></h3>

<p>Now, if we wanted to read to our file, we could just read it, right?</p>

<pre><code>irb(main):007:0&gt; file.read
=&gt; ""
</code></pre>

<p>Wait, what happened to our <code>"meow meow meow"</code> string? Well, if we think about it, when we were writing to our file, we ended at the end of wherever we stopped writing. And that means that there&rsquo;s nothing to read, because we&rsquo;re at the <em>end</em> of our file. This calls for the <code>rewind</code> method, which will take us back to the beginning of our tempfile.</p>

<pre><code>irb(main):008:0&gt; file.rewind
=&gt; 0
</code></pre>

<p>We&rsquo;re now at the beginning of our file!</p>

<h3>5. <code>read</code></h3>

<p>After rewinding back to the beginning of our file, we can now actually read it using the <code>read</code> method:</p>

<pre><code>irb(main):009:0&gt; file.read
=&gt; "meow meow meow"
</code></pre>

<p>So far, we&rsquo;ve been working with this file as though it&rsquo;s a normal Ruby <code>File</code> class. But let&rsquo;s not forget&hellip;this is actually a <code>Tempfile</code>. And dealing with how to close and clean up a tempfile is where things can get tricky. Now all that&rsquo;s left is for us to elegantly handle these fleeting, disappearing files.</p>

<h2>Disappearing Files</h2>

<p>The last steps in the order of filing operations is explicitly closing our tempfile. This is probably the most complicated part to understand, especially if we&rsquo;re not familiar with the concept of garbage collection. However, I think that the Ruby docs do a pretty great job of explaining the how and why of explicitly closing tempfiles, a good practice that the core team strongly encourages:</p>

<blockquote><p>&ldquo;When a Tempfile object is garbage collected, or when the Ruby interpreter exits, its associated temporary file is automatically deleted. This means that it’s unnecessary to explicitly delete a Tempfile after use, though it’s good practice to do so: not explicitly deleting unused Tempfiles can potentially leave behind large amounts of tempfiles on the filesystem until they’re garbage collected. The existance of these temp files can make it harder to determine a new Tempfile filename.&rdquo;</p></blockquote>

<p>The guides suggest that the best way to go about deleting a tempfile after we&rsquo;re done using it is by calling two specific methods from within an <code>ensure</code> block (remember the <code>ensure</code> keyword? No? Don&rsquo;t worry, you can read about it <a href="http://vaidehijoshi.github.io/blog/2015/08/25/unlocking-ruby-keywords-begin-end-ensure-rescue/">over here</a>).</p>

<p>But first, let&rsquo;s round out our order of filing operations with the two most important tempfile methods.</p>

<h3>6. <code>close</code></h3>

<p>This method basically tells the Ruby interpreter, <em>you can&rsquo;t read the file now!</em>. It closes the file and doesn&rsquo;t allow it to be read or written to.</p>

<pre><code>irb(main):010:0&gt; file.close
=&gt; nil
</code></pre>

<p>Some blogs have mentioned that this method isn&rsquo;t always necessary, but it can&rsquo;t hurt to use it.</p>

<h3>7. <code>unlink</code></h3>

<p>This method is what actualy <em>deletes</em> the file from the filesystem.</p>

<pre><code>irb(main):034:0&gt; file.unlink
=&gt; #&lt;Tempfile:&gt;
</code></pre>

<p>We could also use the <code>delete</code> method, which is just an alias for <code>unlink</code>.</p>

<p>Playing with these methods in <code>irb</code> has been fun, but what would this look like in a Rails application? Well, we&rsquo;d probably want a single method to handle the creation, writing, and deletion of our tempfile (think separation of concerns!). And this is where the use of our <code>ensure</code> block would come in.</p>

<p>This might look something like this:</p>

<pre><code class="ruby">def file_attachment
  tempfile = Tempfile.new(SecureRandom.uuid)
  tempfile.binmode

  begin
    tempfile.write("some text we could write dynamically")

    tempfile.rewind
  ensure
    tempfile.close
    tempfile.unlink
  end
end
</code></pre>

<p>Here, we&rsquo;re using all of the methods in our order of tempfile operations! And, because ensure runs <em>even if</em> there were any errors raised, we&rsquo;re basically always going to handle the closing and deleting of our tempfile. In this case, we probably don&rsquo;t want to call all our tempfiles <code>cats</code>, so instead we can be a bit more fancy and use the <code>SecureRandom</code> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/securerandom/rdoc/SecureRandom.html">module</a> to create a base64 tempfile name each time. We even go crazy and take this yet another step further, and have our <code>file_attachment</code> method take a block, which we could <code>yield</code> to inside of our <code>begin</code> block, before we <code>rewind</code> to the beginning of our tempfile.</p>

<p>As you can see, the possibilies are pretty endless! Tempfiles are our oysters! Well, until Ruby&rsquo;s garbage collector deletes them, that is.</p>

<iframe src="//giphy.com/embed/m77wEsvF99FyU" width="480" height="322" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The fundamental difference between Ruby&rsquo;s <code>File</code> class and <code>Tempfile</code> class is that tempfiles are cleaned up (deleted by the garbage collector) once there is nothing pointing to them. Tempfile objects inherit from the <code>File</code> class, which means that we can use any file method on a <code>Tempfile</code> instance.</li>
<li>The <code>unlink</code> method is super important to use, since that&rsquo;s what actually deletes our tempfile from the filesystem.</li>
<li>There are some great tutorials out there on dealing with creating files and directories from within a Ruby script. Check out my two favorites <a href="http://code.tutsplus.com/tutorials/ruby-for-newbies-working-with-directories-and-files--net-18810">here</a> and <a href="http://www.techotopia.com/index.php/Working_with_Files_in_Ruby">here</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Pundit, the Cool Kid of Authorization]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/09/29/using-pundit-the-cool-kid-of-authorization/"/>
    <updated>2015-09-29T08:57:21-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/09/29/using-pundit-the-cool-kid-of-authorization</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/OdVug9ZRk8sqA" width="480" height="192" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Ah, authorization &ndash; or as I like to call it, authentication&rsquo;s cooler, slightly less complicated twin. It&rsquo;s easy to confuse the two, but there&rsquo;s a fundamental difference between them. I recently learned that while setting up an authorization system for an application that&rsquo;s nearing the end of development. Authentication focuses on who you are as a user &mdash; an admin, guest, or user with an account, for example &mdash; while authorization is about what actions you can take. Authorization centers around what you are actually <em>able to do</em> within the context of your role.</p>

<p>It often makes sense to leave authorization as one of the later (and sometimes, last) step of development, purely because it means that you don&rsquo;t need to worry about making sure that you are authenticated in your development environment while you are still building out your application. But eventually, somewhere between development and deployment, you&rsquo;ll have to think about the abilities of your users &mdash; or, what they can and can&rsquo;t do.</p>

<p>There are a few different ways to go about creating an authorization system, one of the most popular being <code>can_can</code>, a gem that has been around in the Rails community since 2010, as well as a newer gem called <code>rolify</code>. But the one that I&rsquo;ve found really easy and fun to work with is <code>pundit</code>, an <a href="https://github.com/elabs/pundit">authorization system</a> crafted by eLabs, and interestingly enough, based off of the logic and thought behind the CanCan&rsquo;s approach. The developers at eLabs actually started off using the CanCan library in their own applications, but quickly realized that it could become very complicated, very quickly. So, they built the simpler authorization system of <code>pundit</code>, which is exactly what we&rsquo;ll play around with today!</p>

<!--more-->


<h2>Policies of Pundit</h2>

<iframe src="//giphy.com/embed/zCn93ehzAzZNC" width="480" height="198" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Implementing the <code>pundit</code> gem is easy once we understand how it&rsquo;s structured, what it&rsquo;s expecting, and what conventions to follow. But before we do anything else, we&rsquo;ll need to add it to our <code>Gemfile</code>:</p>

<p><code>gem "pundit"</code></p>

<p>and run our favorite command, <code>bundle install</code>.</p>

<p>The documentation for this gem is fairly well-explained, and even allows you to generate all the basic files you need with a single command (<code>rails g pundit:install</code>). However, generators can be a little bit dangerous if you don&rsquo;t understand what&rsquo;s going on behind the scenes, since all logic has been abstracted away and things start happening automagically! So, let&rsquo;s set up our authorization system for our bookstore manually. Don&rsquo;t worry &mdash; it&rsquo;s not going to be <em>too</em> painful!</p>

<p>First things first: we need to make sure that we include <code>pundit</code> in our controllers. This is a particularly important step because we&rsquo;re going to use a method inside of all of our controllers, and if we don&rsquo;t <code>include Pundit</code>, none of our controllers will have any idea what method we&rsquo;re trying to call. Since we&rsquo;re going to be authorizing multiple classes, it makes sense to add <code>pundit</code> to the file where all our other controllers will inherit from: <code>ApplicationController</code>.</p>

<pre><code class="ruby">class ApplicationController &lt; ActionController::Base
  include Pundit
  protect_from_forgery
end
</code></pre>

<p>Next, we need to understand how <code>pundit</code> actually works. If we take a look at <a href="https://github.com/elabs/pundit">the documentation</a>, there are a few things that immediately become clear: <code>pundit</code> is focused around something called &ldquo;policy classes&rdquo;. Similar to how <code>cancan</code> relies &ldquo;ability classes&rdquo;, <code>pundit</code> expects a policy class to house our authorization logic.</p>

<p>Okay, so we need policy classes. But what kind of classes are they? Do they inherit from anything? How many do we need, exactly? And what should go inside of them? If these are the questions running through your head, fret not: there are answers to all of them!</p>

<p>Here are the basics of building a <code>pundit</code> policy class:</p>

<ol>
<li>Every policy class is just a plain old ruby class. It doesn&rsquo;t need to inherit from <code>ActiveRecord::Base</code>, or anything else. The only thing that the class <em>must</em> have is the suffix <code>Policy</code>.</li>
<li>Each policy class should contain the authorization logic for the model class that it corresponds to. A <code>User</code> model would have a <code>UserPolicy</code>, while a <code>Book</code> model would have a <code>BookPolicy</code> class.</li>
<li>A policy class should initialize with two instance variables: a <code>user</code>, and the <code>model</code> that we want to authorize. The <code>initialize</code> method in a policy class will always expect these two parameters in a certain order: <code>user</code> as the first argument, and the <code>model</code> object that we want to authorize as the second arugment. The <code>model</code> doesn&rsquo;t have to be an <code>ActiveRecord</code> object &ndash; it can literally be anything that you want to authorize!</li>
<li>Inside of the policy class are query methods that actually contain the code for specific authorization checks. These should correspond and map to the actions in the controller for the model we want to authorize. If our <code>UsersController</code> has <code>create</code>, <code>update</code>, and <code>destroy</code> actions, our <code>UserPolicy</code> class should (theoretically) have <code>create?</code>, <code>update?</code>, and <code>destroy?</code> query methods inside of it.</li>
</ol>


<p>Okay, that&rsquo;s enough on policies to start. Let&rsquo;s actually start writing some of those policy classes! We&rsquo;ll need to create a folder for all of our policies since we&rsquo;re not using the generator (<code>app/policies</code>), which will house our policy classes. The most important policy class that we should write first is our <code>ApplicationPolicy</code>, which will reside at <code>app/policies/application_policy.rb</code>. This is where we can put our <code>initialize</code> method in, since we know that every policy needs to have this method inside of it.</p>

<pre><code class="ruby">class ApplicationPolicy 
  attr_reader :user, :resource

  def initialize(user, resource)
    @user = user
    @resource = resource
  end
end
</code></pre>

<p>Since the <code>initialize</code> method of our <code>ApplicationPolicy</code> is going to be used by all of our other policy classes, we can refer to the second argument (the model that we want to authorize) as <code>resource</code>. Depending on what policy class we are in, the <code>resource</code> object will change. If we had used the generator, we&rsquo;d notice that the model object is actually referred to as <code>record</code>, which also would have been an acceptable name for our second argument. Either way, this is a nice and easy way of abstracting out this method into one file, and then reusing it in our other policy classes. Speaking of which&hellip;it&rsquo;s time for us to write those, next!</p>

<h2>Authorize Me</h2>

<iframe src="//giphy.com/embed/4SmyjSEh4wsPm" width="480" height="202" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>We&rsquo;ll start by authorizing (one of) the most important objects in our application: our users! Since we have a <code>User</code> model, we&rsquo;ll need to abide by <code>pundit</code>&rsquo;s policies, and create a <code>user_policy.rb</code> file inside of <code>app/policies</code>. We&rsquo;ll make sure that it inherit from <code>ApplicationPolicy</code>, so that we&rsquo;ll have access to the <code>initialize</code> method:</p>

<pre><code class="ruby">class UserPolicy &lt; ApplicationPolicy
end
</code></pre>

<p>Next, let&rsquo;s take a look at our <code>UsersController</code>:</p>

<pre><code class="ruby">class UsersController &lt; ApplicationController

    # Some more RESTful actions would go here,
    # probably like #create and #destroy 

    def update
      user = User.find(params[:id])

      user.assign_attributes(user_params)

      if user.save
        render json: user
      else
        render json: {}, status: :unprocessable_entity
      end
    end

    private

    def user_params
      params.require(:user).permit(:name, :email)
    end
end
</code></pre>

<p>There&rsquo;s nothing too fancy going on in here at the moment, and for now, we&rsquo;re only concerned with authorizing the <code>update</code> action in our <code>UsersController</code>. Ultimately, we don&rsquo;t want any user to be able to update their information unless they are logged in; in other words, a user shouldn&rsquo;t be able to update anyone else&rsquo;s name and email except for their own.</p>

<p>So, if we want to authorize the <code>update</code> action, we&rsquo;ll need a query method in our <code>UserPolicy</code> class called &mdash; you guessed it &mdash; <code>update?</code>:</p>

<pre><code class="ruby">class UserPolicy &lt; ApplicationPolicy

    # Inherited from ApplicationPolicy:
    # def initialize(user, resource)
        # @user = user
        # @resource = resource
    # end

    def update?
        user == resource
    end
end
</code></pre>

<p>All we&rsquo;re doing here is verifying that the <code>user</code> instance that we&rsquo;re passing in to the <code>initialize</code> method (which we&rsquo;re inheriting, remember?) is the same instance as the <code>resource</code> that we&rsquo;re passing in. The <code>resource</code> is the model that corresponds to the policy; in our case, we&rsquo;re in the context of the <code>UserPolicy</code>, so our <code>resource</code> is the <code>user</code> instance.</p>

<p>The last step is actually telling our <code>update</code> action in our <code>UsersController</code> to <em>use</em> the <code>UserPolicy</code> and authorize our <code>user</code> instance. To do this, we&rsquo;ll need to call the <code>authorize</code> method, and pass in our <code>resource</code> that we want to authorize:</p>

<pre><code class="ruby">class UsersController &lt; ApplicationController
    after_action :verify_authorized

    def update
      user = User.find(params[:id])

      authorize user
      user.assign_attributes(user_params)

      if user.save
        render json: user
      else
        render json: {}, status: :unprocessable_entity
      end
    end

    private

    def user_params
      params.require(:user).permit(:name, :email)
    end
end
</code></pre>

<p>In addition to calling <code>authorize</code>, we also need to make sure that our policy is actually being used! In fact, that&rsquo;s what the <code>after_action :verify_authorized</code> line is doing. The documentation suggests adding this to our <code>ApplicationController</code>, but for the sake of clarify, we can put it here temporarily, just to see how everything is working together. Pundit adds a method called <code>verify_authorized</code> to our controllers. It&rsquo;s this method that is reponsible for raising an exception if <code>authorize</code> is not called. It&rsquo;s recommended to put this in an <code>after_action</code> so that we don&rsquo;t forget to authorize any controller actions when we invoke them. Eventually, we&rsquo;ll want to abstract this line to our <code>ApplicationController</code>:</p>

<p><code>after_action :verify_authorized, except: :index</code></p>

<p>Since this is an <code>after_action</code>, we can pass it <code>except</code> or <code>only</code>, if we want to skip authorization for certain controller actions.</p>

<p>So, how is all of this working? Well, when we pass <code>user</code> to the <code>authorize</code> method, we are actually telling <code>pundit</code> to look for a <code>UserPolicy</code>, find the corresponding action, and invoke it. If our <code>user</code> instance is <em>not</em> authorized, <code>pundit</code> will raise a <code>Pundit::NotAuthorizedError</code>. The source code for the <a href="https://github.com/elabs/pundit/blob/145d7592c0028c26e61e8a9569ed3440323eaa40/lib/pundit/policy_finder.rb">policy finder</a> and the <a href="https://github.com/elabs/pundit/blob/8d73705ca6886b757c9d41e13c1cb32a7b97334b/lib/pundit.rb">authorize method</a> reveal exactly how this happens, and are pretty cool to look at under the hood.</p>

<h2>Scopin&#8217; Out More Policies</h2>

<p>The <code>pundit</code> gem is pretty powerful, but the thing that makes it the cool kid of authorization is how it handles scopes. We can use scopes when we want to have a specific subset of records that a user has access to &mdash; basically, when we want to narrow the &ldquo;scope&rdquo; of the resources that are visible to our user, based on their &ldquo;level&rdquo; of authorization (admin, guest, etc.).</p>

<p>Let&rsquo;s write a quick scope for the <code>Review</code> objects of the book reviews in our bookstore. Right now, our <code>ReviewPolicy</code> looks like this:</p>

<pre><code class="ruby">class ReviewPolicy &lt; ApplicationPolicy
    def update?
        resource.user == user
    end
end
</code></pre>

<p>We have a corresponding <code>update</code> action in our <code>ReviewsController</code>, and we&rsquo;re allowing a review to be updated only by the user who wrote it (in other words, the <code>user</code> object that the <code>review</code> belongs to). But we also need an <code>index</code> action, and we want to limit the <code>reviews</code> that can be viewed by a user in the index action. Ultimately, the only <code>user</code> that should be able to see <em>all</em> reviews (including drafts) should be admins; otherwise, the only reviews that should be visible are the ones that have been published.</p>

<p>And that&rsquo;s where scopes come into play. There&rsquo;s a few rules to scopes:</p>

<ol>
<li>They are plain old ruby classes, nested within the policy class.</li>
<li>They have an initialize method that takes a <code>user</code> instance, and a <code>scope</code>. The <code>scope</code> is what we&rsquo;ll perform some kind of database query on &mdash; usually an ActiveRecord class or <code>ActiveRecord::Relation</code>.</li>
<li>The class should have a <code>resolve</code> method, which should return an array of instances that we can iterate over &mdash; again, probably an <code>ActiveRecord::Relation</code>.</li>
</ol>


<p>Let&rsquo;s go ahead and add a scope to our preexisting <code>ReviewPolicy</code>:</p>

<pre><code class="ruby">class ReviewPolicy &lt; ApplicationPolicy
  class Scope
    attr_reader :user, :scope

    def initialize(user, scope)
      @user = user
      @scope = scope
    end

    def resolve
        if user.admin?
            scope.all
        else
            scope.where(published: true)
        end
    end
  end

  def update?
    resource.user == user
  end
end
</code></pre>

<p>The only thing that&rsquo;s actually happening here is that we&rsquo;re limiting the number and types of book <code>reviews</code> that will be rendered by the <code>resolve</code> method. If our <code>user</code> is an admin, we&rsquo;ll run the query <code>Review.all</code>; otherwise, we&rsquo;ll execute the query, <code>Review.where(published: true)</code>.</p>

<p>Again, we could abstract the initialize method of our <code>Scope</code> class into the <code>ApplicationPolicy</code> so that we could inherit <code>class Scope &lt; Scope</code>, rather that actually writing the method directly into this class. In fact, that&rsquo;s probably exactly what we would do once we realized that we needed to write more than a single scope.</p>

<p>The last step is adding our scope to our <code>ReviewsController</code>. We can use a method provided by <code>pundit</code> in our controller called <code>policy_scope</code>, which takes an class instance of a model (in our case, <code>Review</code>):</p>

<pre><code class="ruby">class ReviewsController &lt; BaseController
    after_action :verify_policy_scoped, only: :index
    skip_after_action :verify_authorized, only: :index

    def index
      if user_signed_in?
        reviews = policy_scope(Review)

        render json: reviews
      else
        render json: { reviews: [] }
      end
    end

    def update
        review = Review.find(params[:id])

        authorize review

        # Logic for updating our review
    end
end
</code></pre>

<p>Now, our <code>index</code> action uses the <code>policy_scope</code> method to find the reviews that we&rsquo;ll render. The <code>policy_scope</code> method infers that we want to use the <code>ReviewPolicy::Scope</code> class, and it will instantiate the class and then call resolve on the instance. In fact, the code that&rsquo;s actually getting executed here is this:</p>

<p><code>reviews = ReviewPolicy::Scope.new(current_user, Review).resolve</code></p>

<p>The other important line in our controller is the method that&rsquo;s actually mkaing sure that the policy scope is being used:</p>

<p><code>after_action :verify_policy_scoped, only: :index</code></p>

<p>Similar to <code>verify_authorized</code>, the <code>verify_policy_scoped</code> method is what ensures that the policy scope is actually being used. And in our case, we only have a scope on our <code>index</code> action, so we can specify that we only want to use a scope on <code>:index</code>. Not too bad, right? Just tell <code>pundit</code> what you want to scope, and what you want to authorize, and it will do the rest for us!</p>

<p>But what if we had a class that never needed to be authorized or scoped? How could we tell <code>pundit</code> to just skip the authorization for that specific model? Well, it&rsquo;s pretty easy &mdash; we can just use <code>skip_after_action</code>:</p>

<pre><code class="ruby">class CommentsController &lt; ApplicationController
    skip_after_action :verify_authorized
    skip_after_action :verify_policy_scoped

    # RESTful controller actions go here!
end
</code></pre>

<p>Simple! This gem is pretty fantastic to work with, and gives us great guidelines on the proper way of using it. I really liked this particular piece of advice from the library&rsquo;s developers:</p>

<blockquote><p>&ldquo;Pundit strongly encourages you to model your application in such a way that the only context you need for authorization is a user object and a domain model that you want to check authorization for. If you find yourself needing more context than that, consider whether you are authorizing the right domain model, maybe another domain model (or a wrapper around multiple domain models) can provide the context you need.&rdquo;</p></blockquote>

<p>It turns out that authorizing with <code>pundit</code> can be a really good time. You might say that it&rsquo;s even kind of&hellip;fun!</p>

<iframe src="//giphy.com/embed/btKQIhrebJ3Og" width="480" height="200" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>pundit</code> gem is a simple way to build a powerful authorization system. It expects plain old ruby policy classes for each model that you want to authorize, and each class should contain query methods that map to controller actions for the model. The controller that corresponds to the model should call the <code>authorize</code> method for the object, and should either contain or inherit an <code>after_action :verify_authorized</code> method.</li>
<li>The developers at eLabs put a lot of work into building <code>pundit</code>, and based it off of the <code>cancan</code> library. In fact, they even wrote a super blog post about their process, which you can read <a href="http://www.elabs.se/blog/52-simple-authorization-in-ruby-on-rails-apps">over here</a>.</li>
<li>Still confused about when to authorize and when to authenticate? Check out this <a href="http://www.slideshare.net/BruceWhite3/pundit-37048056">awesome slidedeck</a> that clarifies all your authorization confusion!</li>
</ul>

]]></content>
  </entry>
  
</feed>
