<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: #technicaltuesdays | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/number-technicaltuesdays/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-08-11T08:56:11-04:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rolling Out the Redcarpet for Rendering Markdown]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/08/11/rolling-out-the-redcarpet-for-rendering-markdown/"/>
    <updated>2015-08-11T08:47:54-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/08/11/rolling-out-the-redcarpet-for-rendering-markdown</id>
    <content type="html"><![CDATA[<p><img src="http://cdn.lolbrary.com/2013/12/6/lolbrary.com_45273_1386359887.jpg" style="display: block; margin-left: auto; margin-right: auto; max-width: 400px; max-height: 500px;"/></p>

<p>Sometimes, it&rsquo;s the little things that matter the most. As cool and complex as your giant application might be, small details like a toggleable button, or beautiful-formatted and styled dropdown select can have the biggest impact on the look and feel of the rest of your application.</p>

<p>Once you&rsquo;ve built out the skeleton of your application and filled in the backend functionality, the next step is to connect the all the logic with your frontend framework. And once you&rsquo;ve done that, you start to see all the gaping holes that you need to fix next. One of the applications that I have been working on recently got to that state. Once I ensured that the user-facing page corresponded to the admin panel, it was time to fix all the little things that I had been putting off until we got the application working!</p>

<p>One of those minute details was rendering markdown. While building out the application, we were just using Ruby string primitives in our database to render text. But no one wants to see a long five-paragraph article rendered as a single, huge block of text, right? So, we had to make our text easily editable on the admin panel and renderable &mdash; that&rsquo;s word, right? &mdash; on the user-facing side. At first, I had no idea how to go about doing this. But it turns out that (no surprise here!) this problem has been solved before! All we had to do next was figure out how to implement someone else&rsquo;s solution on our own application. Luckily, the answer to our prayers is as simple as rolling out the <code>redcarpet</code> gem.</p>

<!--more-->


<h2>Markdown: What is it?</h2>

<p><img src="http://kirkstrobeck.github.io/whatismarkdown.com/img/markdown.png" style="display: block; margin-left: auto; margin-right: auto; max-width: 400px; max-height: 300px;"/></p>

<p>The Markdown language didn&rsquo;t exist until 2004, when it was created by John Gruber of <a href="http://daringfireball.net/">Daring Fireball</a> blog fame. Unlike markup languages such as HTML or RTF (Rich Text Format), Markdown was created to not have any tags for formatting &ldquo;instructions&rdquo; when rendered. Instead, it is structured to be <a href="http://whatismarkdown.com/">readable without formatting</a> or any tags. Ultimately, the language converts simple text into structurally valid markup HTML (or XHTML).</p>

<p>We interact with Markdown a lot, even though we might not always realize it. Files that end in <code>.md</code>, for example, are written in Markdown, and a lot of blog generators (including octopress and jekyll) use Markdown as their formatting language. In fact, this language is exactly what allows us to write something like this into a code snippet or CMS parser:</p>

<pre><code># I'm a heading

This is a list:

* thing one
* thing two
* thing three

And here's some *italics* and some **bold**.
</code></pre>

<p>which will then be processed by Markdown to render actually <em>this</em> HTML in our templates:</p>

<p>&#8220;`html</p>

<h1>I&#8217;m a heading</h1>




<p>This is a list:</p>




<ul>
  <li>thing one</li>
  <li>thing two</li>
  <li>thing three</li>
</ul>




<p>And here&#8217;s some <em>italics</em> and some <strong>bold</strong>.</p>


<pre><code>
Not only is that incredibly cool, but it's also a powerful templating tool! There's one slight problem, however: our templates don't look anything like this. We have neither any Markdown, nor any HTML! Instead, we're just rendering long strings (saved in our Postgres database as `text` attributes) that look like this:

`Here's a news article about Harper Lee's new novel, Go Set A Watchman, but it has no formatting at all...`

So, how do we get our text to look like the beautiful markup from above? Why, by using a special Markdown gem, of course!

## HTML All Of The Things

Markdown processig in Ruby is made especially easy thanks to a library called `redcarpet`, created by a Github developer named &lt;a href="https://github.com/vmg"&gt;Vicent Marti&lt;/a&gt; (thanks, Vicent!). The library is available as a gem, and its parser doesn't require any additional installed libraries aside from Ruby itself.

Let's get set up by adding it to our `Gemfile`:

`gem "redcarpet"`

and bundling up this gem:

`$ bundle install`

Great. Now we need figure out how to recarpet our application using this library! The first thing I like to do whenever I'm working with a library or gem that's completely new to me is decipher what exactly I'm working with here. Thankfully, the `redcarpet` documentation is really fantastic, and they answer this question almost immediately:

&gt;"The core of the Redcarpet library is the Redcarpet::Markdown class. Each instance of the class is attached to a Renderer object; the Markdown class performs parsing of a document and uses the attached renderer to generate output."

Okay...what does this mean, exactly? Well, it's actually not *too* complicated. The library has a `Redcarpet::Markdown` class, which --- you guessed it --- is going to be responsible for handling the transforming/parsing of Markdown to markup (we'll be using HTML, in our case). But it's also attached to a Renderer object, it seems.

An example will help us visualize what exactly is going on here:

`markdown = Redcarpet::Markdown.new(renderer, extensions = {})`

Interesting! the new instance of our `Redcarpet::Markdown` class takes two arguments, one of which *is* our Renderer object. It also seems to take a hash of `extensions`, but we'll come back to that in a bit.

We know that we want to pass in a renderer to our `Redcarpet::Markdown` class...but what are our options? It turns out that there are two built-in renderers that the `redcarpet` library uses: `Redcarpet::Render::HTML` and `Redcarpet::Render::XHTML`. 

*Protip: the `redcarpet` renderers are actually implemented in C, which means that they are incredibly performant and so much faster than other Ruby Markdown renderers!*

Since we want our articles to render HTML, we'll stick with the former renderer rather than the latter:

`markdown = Redcarpet::Markdown.new(Redcarpet::Render::HTML)`

It's important to note that what's *actually* happening here is that we are creating a new *instance* of an HTML renderer, and passing that to our `Redcarpet::Markdown` object. This is crucial to remember because our `Redcarpet::Render::HTML` can also take its own set of options! When we initialize our HTML renderer, we have the option of passing some flags to it. And then, we pass our HTML renderer to our `markdown` object, which will actually handle parsing it:
</code></pre>

<p>renderer = Redcarpet::Render::HTML.new(render_options)
markdown = Redcarpet::Markdown.new(renderer, extensions)
&#8220;`</p>

<p>We won&rsquo;t add any options to start, but don&rsquo;t forget that this is what&rsquo;s <em>actually</em> happening! Now it&rsquo;s time for a deep breath; next, we&rsquo;ll need to actually implement this <code>markdown</code> object in our application!</p>

<p><img src="http://g-ecx.images-amazon.com/images/G/01/askville/137733_9521259_mywrite/html_cat.jpg" style="display: block; margin-left: auto; margin-right: auto; max-width: 500px; max-height: 400px;"/><br></p>

<p>The first thing we&rsquo;ll want to do is add our <code>markdown</code> object to the class that will need our Markdown parser. For our Bookstore application, we&rsquo;ll have a set of news articles that will show up on our homepage when a user signs in. This means that we&rsquo;ll want our <code>Article</code> objects to be able to implement markdown. Since this is something our <em>entire</em> class should be able to do, we&rsquo;ll add our <code>markdown</code> object as a class method to our <code>Article</code> model:</p>

<pre><code class="ruby">class Article &lt; ActiveRecord::Base
  class &lt;&lt; self
    def markdown
      Redcarpet::Markdown.new(Redcarpet::Render::HTML)
    end
  end
end
</code></pre>

<p>This method isn&rsquo;t doing anything aside from creating a new instance of a <code>Redcarpet::Markdown</code> parser, with a <code>Redcarpet::Render::HTML</code> renderer. Next, we&rsquo;ll want to add write a migration that will create another column in our database that will save our markdown content:</p>

<pre><code class="ruby">class AddMarkdownContentToArticles &lt; ActiveRecord::Migration
  def change
    add_column :articles, :markdown_content, :text
  end
end
</code></pre>

<p>The reason that we have two different columns for persisting content is simple: we have two different types of content that we&rsquo;re dealing with. The <code>content</code> column in the database is what the admins will edit in the admin panel, while the <code>markdown_content</code> column is what will be rendered to the user.</p>

<p>This will be especially evident when we integrate this with our Ember frontend, which would require us to serialize all the data that Rails is passing to the Ember models. In our <code>ArticleSerializer</code>, we are are only passing our <code>markdown_content</code> through to the frontend:</p>

<pre><code class="ruby">class ArticleSerializer &lt; ApplicationSerializer
    attributes :id, :slug, :title, :markdown_content, :published_at
end
</code></pre>

<p>On the other hand, in our <code>Admin::ArticleSerializer</code>, which is hooked up to our admin panel, we are <em>only</em> passing the raw <code>:content</code>, which is our content <em>before</em> is has been parsed through our <code>markdown</code> object:</p>

<pre><code class="ruby">module Admin
  class ArticleSerializer &lt; ApplicationSerializer
    attributes :id, :slug, :title, :content, :published_at
  end
end
</code></pre>

<p>Nice! We have everything set up, finally. Let&rsquo;s make sure that we&rsquo;re actually parsing our <code>content</code> and assigning our <code>markdown_content</code> when our article is saved. We can do this by adding a <code>before_save</code> hook, which will call whatever method we pass it right before our <code>Article</code> model is saved:</p>

<pre><code class="ruby">class Article &lt; ActiveRecord::Base
  class &lt;&lt; self
    def markdown
      Redcarpet::Markdown.new(Redcarpet::Render::HTML)
    end
  end

  before_save :assign_markdown_content, if: -&gt; { content_changed? }

  def assign_markdown_content
    assign_attributes({
      markdown_content: self.class.markdown.render(content)
    })
  end
end
</code></pre>

<p>Cool! We wrote a <code>assign_markdown_content</code> method that assigns the <code>markdown_content</code> attribute on our <code>Article</code>. And what exactly is it using to assign the <code>markdown_content</code>? Oh, that&rsquo;s right: our <code>markdown</code> object! We&rsquo;re calling the <code>markdown</code> class method, and passing the <code>Article</code>&rsquo;s content to its <code>render</code> method, which means that the <code>Redcarpet::Markdown</code> instance will parse the content into HTML!</p>

<p>We&rsquo;re also doing a pre-check in our <code>before_save</code> by passing a proc to this callback which will only call the <code>assign_markdown_content</code> method if our <code>content</code> column in the database has changed (isn&rsquo;t that <code>content_changed?</code> method is a cool ActiveRecord trick?). This means that we&rsquo;re not assigning attributes on our <code>Article</code> unless we really need to. This is super efficient because it means avoiding unnecessary queries to our database!</p>

<h2>Carpeting Options</h2>

<p>The last part of this <code>redcarpet</code> magic is rendering our content in our views and adding any options we might need. If we wanted to do this in a simple Rails view, we could just ask the <code>Article</code> object for its <code>markdown_content</code>:</p>

<pre><code class="slim">article
  = @article.markdown_content.html_safe
</code></pre>

<p>We might need to call <code>html_safe</code> on this particular column since Rails will try to escape the content automatically. We could do a similar thing in an Ember view as well, using triple handlebars to handle the HTML safe issue.</p>

<p>Now that we finally have everything working, we can add some cool options to our renderer! You&rsquo;ll remember that the <code>Redcarpet::Markdown</code> class takes a hash of options.</p>

<p>In my opinion, the most helpful and important option to pass in is <code>autolink</code>. It&rsquo;s super crucial if you don&rsquo;t know what your content might look like, since it parses links even when they&rsquo;re not enclosed in <code>&lt; &gt;</code> characters. It will detect autolinks for http, https, and ftp protocols, and it also handles email addresses and links that start with <code>www</code>.</p>

<p>We can pass in this option directly as second arguments after we pass in our <code>Redcarpet::Render::HTML</code> object:</p>

<pre><code class="ruby">def markdown
  Redcarpet::Markdown.new(Redcarpet::Render::HTML, autolink: true)
end
</code></pre>

<p>Other helpful options on the <code>Redcarpet::Render::HTML</code> object include <code>tables</code>, <code>space_after_headers</code>, <code>lax_spacing</code>, and <code>highlight</code>. Of course, just as you can pass in options to the markdown object you can do the same for the renderer:</p>

<p><code>Redcarpet::Render::HTML.new(hard_wrap: true, safe_links_only: true, escape_html: true)</code></p>

<p>The <code>escape_html</code> option is particularly interesting because it takes precedence over <code>:no_styles</code>, <code>:no_links</code>, <code>:no_images</code> and <code>:filter_html</code>, which means that any existing html tags will be escaped instead of being removed. I&rsquo;m also pretty sure that it would escape any cats you try to pass in through params as well&hellip;although I haven&rsquo;t tried that one yet.</p>

<p><img src="http://geekandpoke.typepad.com/.a/6a00d8341d3df553ef0120a8b86eae970b-800wi" style="display: block; margin-left: auto; margin-right: auto; max-width: 400px; max-height: 500px;"/><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>redcarpet</code> gem is an awesome way to handle rendering Markdown in Rails. It creates a new instance of a Markdown object, which takes either a HTML or XHTML renderer object. You can also write your own, custom render! Check out the <a href="https://github.com/vmg/redcarpet">documentation</a> to learn more on how to do that.</li>
<li>Want to see a step-by-step Rails tutorial on <code>redcarpet</code>? Check out <a href="http://railscasts.com/episodes/272-markdown-with-redcarpet">this Railscast</a>.</li>
<li>Here&rsquo;s a super <a href="https://richonrails.com/articles/rendering-markdown-with-redcarpet">detailed blog post</a> on implementing <code>redcarpet</code>, with some great code snippets and examples.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Safely Storing Your Assets: Paperclip With AWS + Heroku]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/08/04/safely-storing-your-assets-paperclip-with-aws-plus-heroku/"/>
    <updated>2015-08-04T08:15:32-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/08/04/safely-storing-your-assets-paperclip-with-aws-plus-heroku</id>
    <content type="html"><![CDATA[<p>We all know how this scene plays out: you&rsquo;ve created the first iteration of your application and you&rsquo;re ready to test it out in production. You can&rsquo;t wait to see what it looks like live, and you want people to be able to start playing with it! Everything seems to go smoothly without any glitches while deploying until you go to your app on Heroku and see&hellip;<em>a broken image icon</em>. Tada!</p>

<iframe src="//giphy.com/embed/EVJBgyC41ItfW" width="480" height="208" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>This happened to me recently, and boy was it disheartening. I was all excited because I had used <code>paperclip</code> to get some pretty cool <a href="http://vaidehijoshi.github.io/blog/2015/07/28/clipping-images-for-rails-using-paperclip/">image uploading functionality</a> on my application, but it didn&rsquo;t seem like it was working. It turns out, however, that an application in development is one thing; the same app in production is another game entirely.</p>

<p>While developing an application, our environments are configured in a certain way. It&rsquo;s easy to forget that things will change once we deploy what we&rsquo;ve been working on. Being able to implement something like the <code>paperclip</code> gem in development doesn&rsquo;t easily carry over to your production environment &ndash; unless, of course, you know what tool to use. Luckily, there&rsquo;s a great gem that was created specifically to make the transition from development to production quick and easy: the <code>aws-sdk</code> gem, Amazon Web Services&#8217; Software Development Kit that was created to use with Rails applications for storing your static assets in your AWS Simple Storage bucket. And once you know how to set it up with your Heroku account, you can get rid of that pesky broken image icon once and for all!</p>

<!--more-->


<h2>Street Cred For The Web: S3 Credentials</h2>

<p>Amazon Web Services&#8217; Simple Storage Service (S3) is a one of the most important platform services that a web developer can use. At its most basic level, it&rsquo;s a store that allows us to store important assets that we&rsquo;ll need for our application, including things like media files, pdfs, attachments, and anything that our users may upload.</p>

<p>The <em>really</em> cool thing about AWS is that it allows us to store all those files offsite &ndash; that is to say, <em>not</em> on our Heroku application, and instead using a third-party service. Pretty amazing, right?</p>

<iframe src="//giphy.com/embed/GHTwlFLITq7v2" width="480" height="270" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>This is particularly important as our application starts to grow, and we are forced to scale to size. It also makes our application super fast, since our files aren&rsquo;t being stored within our application itself, which means that we don&rsquo;t need to use our filesystem to retrieve all those assets.</p>

<p>When it comes to integrating your application with AWS S3, however, the most important step is establishing your credentials. In fact, we can&rsquo;t even hook up our <code>paperclip</code> configurations &ndash; or really, <em>any</em> configurations, for that matter &ndash; without our S3 credentials. So, where can we find them?</p>

<p>Well, first we need to know where to look. And in order to know where to look, we have to know how S3 is structured. Thankfully, S3&rsquo;s architecture is pretty simple to understand: everything is just contained in a bucket. We can name our bucket anything that we want, so long as it&rsquo;s a unique name across the Amazon system. A common convention is to name your bucket similarly to your application or repository&rsquo;s name (for example, <code>booklit-website</code>). Once we name our bucket, all of our files sent to S3 will be stored inside and belong to our bucket. An important thing to note is that <a href="http://stackoverflow.com/a/22173939">there are no directories</a> within a bucket; the S3 bucket itself is a top-level container.</p>

<p>Now, how can we access this unique bucket of ours? Using our credentials, of course! In order for us to access the S3 API, we need two things: an <strong>AWS Access Key ID</strong> and an <strong>AWS Secret Access Key</strong>. The access key id identifies our S3 user account, while the secret access key is our &ldquo;password&rdquo; (at least we should think of it as a password, it&rsquo;s a bit more complicated than that) for our account.</p>

<p>We can get these two pieces of information from the &ldquo;Security Credentials&rdquo; section of the AWS console menu when we log into our AWS account. But these keys aren&rsquo;t really helpful until we hook up our S3 bucket with our application. I suppose that&rsquo;s what we should do next!</p>

<h2>Keeping Secrets With <code>.env</code></h2>

<iframe src="//giphy.com/embed/12ROKMe0xvJilW" width="480" height="391" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>There&rsquo;s one golden rule when it comes to our credentials: we should <strong>never, <em>ever</em> store them in a file or commit them to source control</strong>. We never, ever want our credentials to be potentially exposed to anyone via our Github repository, and yet we definitely need our credentials to exist <em>somewhere</em> within our application, don&rsquo;t we? Otherwise we won&rsquo;t be able to tell <code>paperclip</code> where to upload our files and assets. Uh oh&hellip;what do?</p>

<p>Enter <strong>environment variables</strong> to the rescue! There are a few different ways to use environment variables in a Rails application to store our credentials without actually committing them into a file. My favorite way to do this is by creating a <code>.env</code> file in the top-level directory of my application (in our case, <code>booklit-website/.env</code>). Because this file has a <code>.</code> at the beginning, it&rsquo;s actually a hidden file and won&rsquo;t be committed. To double check that this is the case, we can open up our <code>.gitignore</code> file, and make sure that our <code>.env</code> file is included as one of the files that Git should &ldquo;ignore&rdquo; while committing:</p>

<pre><code># See https://help.github.com/articles/ignoring-files for more about ignoring files.

# Ignore Environment Configuration Files
config/database.yml
.env
</code></pre>

<p>This means that we can safely put our important AWS credentials inside of our <code>.env</code> file:</p>

<pre><code>AWS_ACCESS_KEY_ID=our-id-goes-here
AWS_SECRET_ACCESS_KEY=our-access-key-goes-here
AWS_S3_REGION=us-east-1
AWS_S3_BUCKET=booklit-website-bucket
</code></pre>

<p>In addition to the Access Key Id and Secret Access Key that we grabbed from our account information page on the AWS S3 portal, we also put in our S3 Region (the US East Coast), and our S3 Bucket Name (don&rsquo;t try to hack it because it is very much <em>not a real thing</em>).</p>

<p>Okay, this hidden file with our environment variables is cool and all, but how do we actually <em>retrieve</em> these variables? Well, it&rsquo;s actually pretty easy. We can treat the variables in our <code>.env</code> file like items in a hash; if we want to access the value of an item in a hash, we can just reference the value via its key, right? The same applies here. If we want to access our <code>AWS_S3_BUCKET</code> name, we can use <code>ENV['AWS_S3_BUCKET']</code> anywhere in our application in order to access it!</p>

<p>Awesome! We have just one last step before we can finally hook up all of these variables with <code>paperclip</code> and Heroku: we need to create an <code>.env.example</code> file! This is a pretty neat convention that I really liked the first time I saw it, and have since adopted. You&rsquo;ll remember that our <code>.env</code> file is being ignored by our <code>.gitignore</code> file whenever we commit our repository or push it up to Github. This is great, obviously, since we don&rsquo;t want our private credentials to ever be public. There is one downside, however: if someone clones our repository, they&rsquo;ll never know that we even <em>have</em> a <code>.env</code> file, much less what environment variables we have defined inside of it, which means that when they try to run our application or worse, when they try to collaborate with us on it, they&rsquo;ll hit a huge roadblock, and ruby will break and not know where to look while trying to read something like <code>ENV['AWS_S3_BUCKET']</code> from within the application.</p>

<p>There&rsquo;s a quick fix for this: create an &ldquo;example&rdquo; <code>.env</code> file called &ndash; you guessed it &ndash; <code>.env.example</code>. We should make sure that this does <em>not</em> get included in our <code>.gitignore</code> file. Instead, we want it to be committed with our repository. It&rsquo;s also important to note that we&rsquo;re still not going to include <em>our</em> credentials in here; instead, all we&rsquo;ll do is setup our <code>.env.example</code> file as an example of how someone else should create their <code>.env</code> file when they clone or fork our repository:</p>

<pre><code>AWS_ACCESS_KEY_ID=xxxxxx
AWS_SECRET_ACCESS_KEY=xxxxxx
AWS_S3_REGION=xxxxxx
AWS_S3_BUCKET=xxxxxx
</code></pre>

<p>Now that we&rsquo;ve finally got all these variables right where we want them, we can finally get to the good stuff!</p>

<h2>Configuring Paperclip And Heroku</h2>

<p>It may seem like we spent a lot of time setting things up, but it&rsquo;s all about to come together! We initially started off planning to use the <code>aws-sdk</code> gem. Now it&rsquo;s time to implement it in the context of the <code>paperclip</code> gem and configure it to work with our Heroku deploy.</p>

<p>First we&rsquo;ll add it to our <code>Gemfile</code> (<code>gem 'aws-sdk', '~&gt; 2'</code>) and then run <code>bundle install</code>. Now our <code>Gemfile</code> should have both <code>aws-sdk</code> and <code>paperclip</code>.</p>

<p>Next, we&rsquo;ll want to head over to where all the configurations for our <em>production</em> environment are &ndash; namely, our <code>production.rb</code> file, which exists inside of our <code>config/environments</code> directory. It&rsquo;s important to make sure that we&rsquo;re not setting any Heroku configurations inside of our <code>development.rb</code> file, which only runs inside of our development environment. Since we know we&rsquo;ll be deploying only the production environment configurations to Heroku, all of our Heroku setup should always live inside of our production environment.</p>

<p>Inside of our <code>production.rb</code> file, we&rsquo;ll want to add the following configurations:</p>

<pre><code class="ruby">config.paperclip_defaults = {
  storage: :s3,
  s3_credentials: {
    bucket: ENV['AWS_S3_BUCKET'],
    access_key_id: ENV['AWS_ACCESS_KEY_ID'],
    secret_access_key: ENV['AWS_SECRET_ACCESS_KEY']
  }
}
</code></pre>

<p>These lines are how we specify <a href="https://devcenter.heroku.com/articles/paperclip-s3">AWS configuration variables</a> for our production environment. If we wanted to test whether we had set all this up properly, we could copy these lines into our <code>development.rb</code> and test out our S3 uploads on our local server.</p>

<p>Last, but certainly not least, we want to set these configurations up on Heroku. If we don&rsquo;t do this final step in the process, Heroku won&rsquo;t know where to look for our credentials, which means that it won&rsquo;t know where our images are being hosted when it looks inside of our <code>s3_credentials</code> hash!</p>

<p>If we haven&rsquo;t already, we&rsquo;ll want to create an application container on Heroku by running this command in the terminal:</p>

<pre><code>$ heroku create
</code></pre>

<p>And then we&rsquo;ll want to push our code to our Heroku container and run any pending migrations:</p>

<pre><code>$ git push heroku master
$ heroku rake db:migrate
</code></pre>

<p>These first two steps are only necessary if we&rsquo;ve never deployed to Heroku before. If we have, then all we really need to do is set our AWS S3 configuration variables:</p>

<pre><code>$ heroku config:set S3_BUCKET_NAME=our_bucket_name
$ heroku config:set AWS_ACCESS_KEY_ID=our_access_key_id
$ heroku config:set AWS_SECRET_ACCESS_KEY=our_secret_access_key
</code></pre>

<p>Now the moment of truth: we can run <code>heroku open</code> and see&hellip;all of our images live! Next time someone tells us we have to figure out how to safely store our assets, we&rsquo;ll know that it ain&rsquo;t no thing. We got this.</p>

<iframe src="//giphy.com/embed/A4HCrFVdbxZpS" width="480" height="284" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>Environment variables are how we can store our secret credentials; they live inside of the <code>.env</code> file and should never be committed to source control! Want to read more about env variables in Rails? Check out this great <a href="http://bayendor.github.io/blog/2015/01/16/managing-rails-environment-variables/">blog post</a> and this super <a href="http://railsapps.github.io/rails-environment-variables.html">informative tutorial</a>.</li>
<li>The <code>aws-sdk</code> gem is an easy way to integrate <code>paperclip</code> and AWS S3. You can dive into the gem&rsquo;s <a href="https://github.com/aws/aws-sdk-ruby">source code</a> to learn more!</li>
<li>Heroku has some fantastic guides on how to <a href="https://devcenter.heroku.com/articles/s3#s3-setup">set up S3</a> and how to upload files to S3 <a href="https://devcenter.heroku.com/articles/paperclip-s3">using paperclip</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clipping Images for Rails: Using Paperclip]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/07/28/clipping-images-for-rails-using-paperclip/"/>
    <updated>2015-07-28T08:42:36-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/07/28/clipping-images-for-rails-using-paperclip</id>
    <content type="html"><![CDATA[<p><img src="http://www.officemuseum.com/1894_Gem_Paper_Clip_adv_discovered_by_The_Early_Office_Museum.JPG" style="display: block; margin-left: auto; margin-right: auto;"/></p>

<p>They say that a picture is worth a thousand words. How they came up with a such a nice, conveniently specific number number I&rsquo;ll never know. But what I do know is that everything on the web is just data floating around in cyberspace. And when I say everything, I really do mean <em>everything</em> &ndash; including pictures!</p>

<p>I&rsquo;ve worked on a few different projects that have required building out an interface to allow a user or an admin to upload images. The first time that I had to do this, I knew that there were a few different Rails gems out there to help make this magic happen. But I didn&rsquo;t really understand what was going on when I implemented these gems the first time around. To be quite honest, the first time I had to implement file uploading, I just followed the setup steps rather blindly. Now that I&rsquo;ve had to solve the same problem multiple times, however, I feel a bit more comfortable with the process.</p>

<p>There are a few different gems out there for handing file attachment in Rails, but my favorite one to use so far has been <strong>paperclip</strong>. Created by the super cool developers over at <a href="https://github.com/thoughtbot/paperclip">ThoughtBot</a>, the paperclip gem is fairly simple and straightforward to use. The reason that I like this gem in particular is that it fits seamlessly into the Rails framework. Files and attachments are treated just like an attribute on an ActiveRecord object, which makes the setup process both easy and intuitive. However, that doesn&rsquo;t mean that it&rsquo;s not intimidating at first! Luckily, we&rsquo;re going to walk through using the paperclip gem together.</p>

<!--more-->


<h2>How To Start Clipping</h2>

<iframe src="//giphy.com/embed/xXG9gNuwQcN1u" width="480" height="425" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Since <code>paperclip</code> is a gem, the first thing we&rsquo;ll have to do before we really get started on clipping anything is add it to our <code>Gemfile</code>:</p>

<p><code>gem "paperclip", "~&gt; 4.3"</code></p>

<p>and then <code>bundle install</code>, because it&rsquo;s what all the cool kids do. This is also a good time to make sure that we have <code>ImageMagick</code>, which is one of <code>paperclip</code>&rsquo;s dependencies. (We can always run <code>brew install imagemagick</code> to install it if we don&rsquo;t have it already.)</p>

<p>Now it&rsquo;s time to get clipping! And take a look at our schema, obvs. For our Bookstore app, we want each of our authors to have a headshot image uploaded and associated with their work. This is going to be super important from a user experience point of view, and it will be something that will be displayed on the show page of any given author.</p>

<p>There are two ways to go about actually adding an attachment to our model; one of them is is a bit easier because it generates a migration for you. But we&rsquo;ll go ahead and write our own migration to start.</p>

<p>We already have an <code>Author</code> model and migration. What we need to do is add an <code>attachment</code> column that&rsquo;ll handle everything from file uploading to associating a file with a specific <code>Author</code> object. So, we can just write a migration (<code>rails g migration AddProfileMediaToAuthors</code>) that will add an <code>attachment</code> column to our <code>Authors</code> table:</p>

<pre><code class="ruby">class AddProfileMediaToAuthors &lt; ActiveRecord::Migration
  def self.up
    add_attachment :authors, :profile_media
  end

  def self.down
    remove_attachment :authors, :profile_media
  end
end
</code></pre>

<p>We&rsquo;ll call our attachment columns <code>profile_media</code> to preemptively namespace the different types of attachments that we might have on a single <code>Author</code>&rsquo;s page. And just in case you needed a little refresher on the difference between the <code>up</code> and <code>down</code> methods, head <a href="http://vaidehijoshi.github.io/blog/2015/05/19/the-secret-life-of-your-database-part-1-migrations/">over here</a>.</p>

<p>Okay, now we&rsquo;ll run <code>rake db:migrate</code>, and take a look at our <code>schema.rb</code> file. Let&rsquo;s see what happened:</p>

<pre><code class="ruby">create_table "authors", force: :cascade do |t|
    t.string   "firstname"
    t.string   "lastname"
    t.datetime "created_at",         null: false
    t.datetime "updated_at",         null: false
    t.string   "profile_media_file_name"
    t.string   "profile_media_content_type"
    t.integer  "profile_media_file_size"
    t.datetime "profile_media_updated_at"
end
</code></pre>

<p>Interesting! So our <code>add_attachment</code> method actually did a lot of things for us, didn&rsquo;t it? That&rsquo;s because it&rsquo;s actually a helper method does a lot of important things that <code>paperclip</code> relies on:</p>

<ol>
<li>It adds a <code>file_name</code> for our attachment.</li>
<li>It adds a <code>content_type</code> for our attachments, which will be the <em>mime type</em> of our images.</li>
<li>It adds the <code>file_size</code> of our attachments.</li>
<li>It creates a <code>updated_at</code> column, which is particularly useful since we can order and sort our attachments/images by <code>datetime</code> format.</li>
</ol>


<p>Now we need to hook up our database migration with the corresponding model!</p>

<h2>Objects With Attached Files</h2>

<p><img src="http://2.bp.blogspot.com/_khdFP9RCQSw/TSPePSmnscI/AAAAAAAAAK4/My8FyIo8Xuo/s1600/a-jpeg-is-worth-approximately-a-thousand-words.gif" style="display: block; margin-left: auto; margin-right: auto;"/></p>

<p>Inside of our <code>Author</code> class, we need want to add one very important line to our model: <code>has_attached_file</code>. The important thing about this method is that it needs to correspond to whatever we named our attachment in our migrations from earlier. In our case, we called our attachments <code>profile_media</code>, so that&rsquo;s exactly what we&rsquo;ll use inside of our model as well:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
  has_attached_file :profile_media, 
    styles: { 
        large: "500x500", 
        medium: "300x300", 
        thumb: "100x100" 
    }, 
    default_url: "/images/:style/missing_profile_media.png"
end
</code></pre>

<p>This line sets up a few defaults for us and gives us the option of having a few different sizes for our <code>profile_media</code>. The <code>default_url</code> can be helpful if we ever want to give our attachment url a default and avoid an instance of <code>nil</code>. The sizes that we specify here are what we&rsquo;ll use inside of our views:</p>

<pre><code class="ruby">= link_to image_tag(author.profile_media.url(:thumb)), author.profile.url
</code></pre>

<p>But the most important part of making all of this work is, of course, permitting our media to be seen! (I&rsquo;m looking at you, strong params!). All we need to do is add our attachment name (<code>profile_media</code>) to our permitted parameters, which is already being used by our controller actions:</p>

<pre><code class="ruby">class AuthorsController &lt; ApplicationController
    def create
        author = Author.create(author_params)
    end

    private
      def author_params
        params.require(:author).permit(:firstname, :lastname, :profile_media)
      end
end
</code></pre>

<p>Pretty simple, right? But these are just the bare bones of <code>paperclip</code>. We can spice things up a bit, too!</p>

<h2>Validating And Customizing Our Clippings</h2>

<p>Once we have the gem up and working, it&rsquo;s super easy to add some bells and whistles and write it to fit our application&rsquo;s specific standards. The developers at ThoughtBot actually have several different validators that we can implement, including <code>AttachmentContentTypeValidator</code>, <code>AttachmentPresenceValidator</code>, and <code>AttachmentSizeValidator</code>. Personally, however, I prefer the old school helper methods, which function in exactly the same way.</p>

<p>Let&rsquo;s add a <code>validates_attachment_content_type</code> to our <code>Author</code> class, and validate that the content being uploaded is actually an <code>image</code>. We can do that with a nice regular expression:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
    has_attached_file :profile_media, 
        styles: { 
            large: "500x500", 
            medium: "300x300", 
            thumb: "100x100" 
        }, 
        default_url: "/images/:style/missing_profile_media.png"

    validates_attachment_content_type :profile_media, content_type: /\Aimage\/.*\Z/
end
</code></pre>

<p>We can also validate the size and presence of our attachment as well:</p>

<pre><code class="ruby">validates :profile_image, attachment_presence: :true

validates_attachment_size :profile_media, size: { in: 0..100.kilobytes }
</code></pre>

<p>And what about deleting attachments? Well, because <code>paperclip</code> is designed to work so well with ActiveRecord, any attachment we create is treated just like an attribute. As the documentation explains,</p>

<blockquote><p>The intent behind <code>paperclip</code> was to keep setup as easy as possible and to treat files as much like other attributes as possible. This means they aren&rsquo;t saved to their final locations on disk, nor are they deleted if set to nil, until ActiveRecord::Base#save is called. It manages validations based on size and presence, if required.</p></blockquote>

<p>Since the only way to delete an attachment is by setting the attribute to <code>nil</code>, there are a few different ways to actually go about deleting attachments. One implementation that I like to use is writing a custom method that checks whether an <code>Author</code> object has it&rsquo;s <code>profile_media</code> attribute equal to <code>nil</code> before saving it:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
    before_save :delete_profile_media, 
        if: -&gt; { remove_profile_media == '1' &amp;&amp; !profile_media_updated_at_changed? }

    attr_accessor :remove_profile_media

    private
        def delete_profile_media
            self.profile_media = nil
        end
end
</code></pre>

<p>In this structure, I also create an attribute on my <code>Author</code> object called <code>remove_profile_media</code>, which will either be <code>0</code> or <code>1</code>, based on whether a box on a form has been checked or not. If the button is checked, <code>remove_profile_media</code> will be set to <code>1</code>, and I&rsquo;ll call the <code>delete_profile_media</code> method in my <code>before_save</code> hook.</p>

<p>If deleting data is something that scares you (or if you&rsquo;re a fan of the <code>acts_as_paranoid</code> gem) there&rsquo;s also another option. You can just preserve your files along with your &ldquo;soft deleted&rdquo; models:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
    has_attached_file :profile_media, {
        preserve_files: "true",
    }
end
</code></pre>

<p>This extra line prevents any data in our <code>profile_media</code> columns from being completely erased when the model is soft deleted. The good news here is that when the object is restored later on, our images will be too! And that is just as good of a reason as any to celebrate!</p>

<iframe src="//giphy.com/embed/osMIREQbo3s2c" width="480" height="255" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>paperclip</code> gem really needs only two things to function properly: a <code>has_attached_file :attachment</code> in the model and an <code>attachment_file_name</code> column in the database. The <code>attachment_content_type</code> is only required if you&rsquo;re going to use content type validation.</li>
<li>If you want to see some <code>paperclip</code> in action, check out this <a href="http://railscasts.com/episodes/134-paperclip">RailsCast</a> that covers all the basics.</li>
<li>Want to dive into the <code>paperclip</code> source code? Go for it! Perhaps you can start by checking out their well-documented <a href="http://www.rubydoc.info/gems/paperclip/Paperclip/ClassMethods">class methods</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[All the Columns Fit to Index: Unique + Compound Indexing]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/07/21/all-the-columns-fit-to-index-unique-plus-compound-indexing/"/>
    <updated>2015-07-21T08:02:04-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/07/21/all-the-columns-fit-to-index-unique-plus-compound-indexing</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/MMEfo9QQgKInK" width="480" height="269" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Database indexing: the last frontier. Well, okay, not the <em>last</em> frontier perse&hellip;more like the frontier that I&rsquo;ve been reading about a lot recently. While learning about writing about <a href="http://vaidehijoshi.github.io/blog/2015/07/14/writing-smart-migrations-references-reversible-and-indexes/">smart and efficient</a> migrations, I stumbled upon a rabbit hole that I had to restrain myself from going down: the rabbit hole of <strong>database indexing</strong>. But this week, I allowed myself to explore and learn some more about how indexes work.</p>

<p>As the cat gif above might already suggest, an index in a database is much like an index in a book: a place where you can quickly look up the exact information that you need. We already know that indexing can be super helpful when it comes to application performance. Using indexes forces our database to use integers to look up rows &ndash; which are just representations of items or objects &ndash; in our database. The reason that they&rsquo;re so efficient is because looking up something in a database is both fast <em>and</em> cheap if we use an integer to do it (using a string on the other hand, is much, much slower and more expensive). By implementing a simple index, we can speed up a single query by seconds!</p>

<p>But it turns out that even a single index can be complicated. And that&rsquo;s because there are so many kinds of indexes available for us to use. In fact, there&rsquo;s a whole <em>world</em> of different types of database indexes out there. Of course, knowing the options available to us when it comes to database indexing is just half the battle; the other half is knowing when it&rsquo;s the right time to use all these different types of indexes. The best way to learn is by playing around with some indexing ourselves &ndash; so let&rsquo;s dive in!</p>

<!--more-->


<h2>Indexes All Around Us</h2>

<p>The most common index type that we have dealt with so far are <strong>single-column</strong> indexes. They work pretty much exactly as their name would suggest: they create an index on a specific column of a database. So far, almost all of the indexes we&rsquo;ve generated have been indexed on a specific single column of a table.</p>

<iframe src="//giphy.com/embed/bjDq7WCjstuPS" width="480" height="329" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>Let&rsquo;s think for a second: when we use a PostgreSQL to run a migration, the one column that always gets generated is an <code>id</code> column, which is unique for every row in that database, even if the object is deleted. If we think about it, that&rsquo;s an example of an index. In fact, PostgreSQL automatically generates an index for the primary key of any table, and always generates a new, unique key for each new row in the database.</p>

<p>One of the very first migrations we ran for our Bookstore application looked like this:</p>

<pre><code class="ruby">class CreateBooks &lt; ActiveRecord::Migration
  def change
    create_table :books do |t|
      t.string :title
    end 
  end
end
</code></pre>

<p>and generated a tiny little table, which didn&rsquo;t have all that much &ndash; but it did have an index as its <code>id</code> primary key column, which we can confirm by looking at our <code>structure.sql</code> file:</p>

<pre><code class="sql">CREATE TABLE books (
    id integer NOT NULL,
    title character varying(255)
)
</code></pre>

<p>The advantage of having an <code>id integer</code> column here is that our database can very easily look up a specific row in our <code>books</code> table by using the index. We can also see that there&rsquo;s automatically a <code>NOT NULL</code> validation that prevents any row in the database from being created <em>without</em> an <code>id</code>. This isn&rsquo;t something that we wrote &ndash; this is something that Postgres does automatically! And although it might seem pretty obvious and a bit simple right now, it&rsquo;s important to note &ndash; especially since indexes can get rather complicated, rather fast.</p>

<p>Another form of indexing that we&rsquo;ve played around with is adding our own indexes to <code>has_many</code> and <code>belongs_to</code> associations, often by using <code>references</code> to alias those relationships:</p>

<pre><code class="ruby">class AddGenreToBooks &lt; ActiveRecord::Migration
  def change
    add_reference :books, :genre, index: true
  end
end
</code></pre>

<p>And if we already have a relationship set up, we can just write a quick migration to manually add an index to our <code>books</code> table:</p>

<pre><code class="ruby">class AddGenreIndexToBooks &lt; ActiveRecord::Migration
  def change
    add_index :books, :genre
  end
end
</code></pre>

<p>This migration adds an index on <code>genre_id</code> column within our <code>books</code> table, which makes it very quick and easy to look up a book by it&rsquo;s corresponding genre. This is still only a single-column, or <strong>independent index</strong>, because it is only dealing with a single column within a database table. But if there are single indexes, that must mean that the idea of &ldquo;multiple&rdquo; indexes is also must be a real thing, right?</p>

<h2>Two Indexes Are (Sometimes) Better Than One</h2>

<p>Indexes are easy to add; what&rsquo;s harder is knowing what <em>kind</em> of index to add. Sometimes, a single-column index does the trick. But it&rsquo;s also possible that it&rsquo;s quite the right tool for the job.</p>

<p>Let&rsquo;s say that we are doing an overhaul on our Bookstore application and scaling for size. We&rsquo;ve decided that in addition to selling our own curated selection of books, we&rsquo;re also going to allow new, lesser-known bookstores to sign up for our service and sell their own books. Our vendors will have their own admin panel (think vendor portal), and the bookstore staff will have a separate admin panel from which to monitor all the sales across all the vendors who are signed up for our service.</p>

<p>All of our admins (staff and vendors) have an <code>user_id</code>. But, our staff and our vendors aren&rsquo;t just simple users of our application &ndash; they have special roles, and need access to specific pages, depending on their roles. Our admins also have an <code>admin_id</code> in addition to their base <code>user_ids</code>, while our vendors have a <code>vendor_id</code>, based on their roles as smaller-scale booksellers who will be using our software to sell their products.</p>

<p>Within our staff admin panel, we want our admins to be able to quickly view all sales across our signed up vendors, in addition to one specific vendors sales reports. If an admin logs into the admin panel and clicks on a specific bookseller, the panel should immediately load all the information pertinent to that specific vendor.</p>

<p>The first thing we might think to do is what we already know &ndash; namely, add an index on the columns we know we want to look up:</p>

<pre><code class="ruby">class AddIndexesToUsers &lt; ActiveRecord::Migration
    def change
        add_index :users
        add_index :users, :vendor_id
    end
end
</code></pre>

<p>However, these indexes don&rsquo;t actually do what we think they&rsquo;ll do. This adds an index to the primary key column on our <code>users</code> table, which will allow us to quickly look up a single <code>User</code>. It also adds an index to our <code>vendor_id</code> column, and allows us to look up a <code>User</code> instance based on its <code>vendor_id</code>, if it has one.</p>

<p>But here&rsquo;s the rub: we&rsquo;re only adding a single index in this migration. That is to say, we&rsquo;re adding an index on our <code>user_ids</code>, and we&rsquo;re adding an index on our <code>vendor_ids</code>. What we <em>really</em> need is an index that first sorts our data by <code>user_id</code>, and then filters down to the users that match our <code>vendor_id</code>.</p>

<iframe src="//giphy.com/embed/PUBxelwT57jsQ" width="480" height="332" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>Don&rsquo;t worry, this is totally doable! We just need to index <em>two</em> columns, instead of one. Actually, there&rsquo;s a perfect name &ndash; or set of names &ndash; for what we need: a <strong>compound index</strong> (aka a concatenated, multi-column, composite or combined index).</p>

<p>Ultimately, we want our database to execute a query that looks something like this:</p>

<pre><code class="sql">SELECT * FROM users WHERE user_id = ? AND vendor_id = ?;
</code></pre>

<p>so that we can avoid writing a SQL statement in our <code>UsersController</code> like we have now (ew, let&rsquo;s not do that):</p>

<pre><code>class UsersController &lt; ApplicationController
    def sign_in
        @user = User.where("user_id = ? AND vendor_id = ?", params[:user_id], params[:vendor_id])
        # authenticate and sign in the vendor
    end
end
</code></pre>

<p>So how are we going to manage all of this, you might ask? Well, pretty easily. Writing a compound index is almost as easy as writing a single-column index:</p>

<pre><code class="ruby">class AddIndexesToUsers &lt; ActiveRecord::Migration
    def change
        add_index :users, [:id, vendor_id]
    end
end
</code></pre>

<p>And that&rsquo;s it! But what&rsquo;s happening, exactly? Well, we&rsquo;re still creating a single index, but we&rsquo;re doing it across multiple columns. The first column (<code>user_id</code>) is the primary &ldquo;sort criterion&rdquo;, and the second column (<code>vendor_id</code>) is the secondary &ldquo;sort criterion&rdquo;. The important thing to remember here is that <em>order matters</em>. We&rsquo;ll only ever look up a vendor by <code>user_id</code> first, and then by <code>vendor_id</code>. This makes sense if you think about it, since we&rsquo;ll first want to authenticate by the user currently logged in (in other words, using the current session).</p>

<p>I really liked the way that Markus Winand describes two-column indexing on <a href="http://use-the-index-luke.com/sql/where-clause/the-equals-operator/concatenated-keys">his blog</a>:</p>

<blockquote><p>The ordering of a two-column index is therefore like the ordering of a telephone directory: it is first sorted by surname, then by first name. That means that a two-column index does not support searching on the second column alone; that would be like searching a telephone directory by first name.</p></blockquote>

<p>Compound indexes are super cool because they let you quickly look up the first field/column in a database, and then quickly look up <em>another</em> field/column in a database &ndash; but only within the records that were returned by the first index. At the end of the query, you&rsquo;ll only have rows that satisfy parts of that <code>AND</code> SQL query we wrote earlier!</p>

<h2>Indexes Like None Other</h2>

<p>I think we can all agree that indexing can help us narrow down a lot of rows in a database and is probably the coolest filtration system ever invented by and for developers. But that&rsquo;s not all that indexes can do! They can also prevent some pretty sticky situations that we often overlook.</p>

<p>By now, something that we&rsquo;re all familiar with is validations. One of the most common kinds of validations that we see in our Rails models all of the time is <code>uniqueness:true</code>, or <code>validates_uniqueness_of</code>. However, here&rsquo;s something we don&rsquo;t always think about (or perhaps never even realized): these validations only occur at the the ActiveRecord level. And this fact can pose some problems.</p>

<p>Imagine two vendors are signing up to use our Bookstore app. They both want to name their store the same thing, but we definitely don&rsquo;t want that to happen. So we add this line to our <code>Users</code> table:</p>

<pre><code class="ruby">module User
    class Vendor &lt; ActiveRecord::Base
      validates :store_name, presence: true, uniqueness: true
    end
end
</code></pre>

<p>Cool, so this is fine then, right? Wrong! Because we just sent out an email blast telling all these potential vendors that they could sign up for a free 60-day trial. Now, all of a sudden, tons of vendors are signing up! And it just so happens, that two of them signed up at almost the exact same second, and wanted to use the same name: <code>Super Cool Books</code> (I know, I know, what are the chances, right?!)</p>

<p>Here&rsquo;s the problem: the moment that both of these potential vendors signed up for our service, no row in our polymorphic <code>vendors</code> database existed with a <code>store_name</code> that corresponded to the string, <code>Super Cool Books</code>. So what did ActiveRecord do? It created a new row! Actually&hellip;it created <em>two</em> new rows. At almost the exact same time. With the <em>exact same store name</em>. Uh oh.</p>

<p>So how can we fix this? We need to take our <code>uniqueness</code> validation down another level. In fact, we need to make our <em>database</em> responsible for validating uniqueness. And we can do this by adding a <strong>unique index</strong>.</p>

<p>Again, this is pretty easy. We just need to add a <code>unique: true</code> constraint on the column that we want to be able to index:</p>

<pre><code class="ruby">class AddStoreNameIndexToVendors
  def change
    add_index :vendors, :store_name, unique: true
  end
end
</code></pre>

<p>Now, when two vendors try to sign up to be called <code>Super Cool Books</code>, only one will actually be able to have that name. As soon as an unique index is created on the <code>store_name</code> column of our <code>vendors</code> database, any other record that tries to be created with that index will raise a <code>ActiveRecord::RecordNotUnique</code> error. This is going to be super helpful to us in avoiding inconsistant data, particularly when we know that a lot of data is going to be created at once.</p>

<p>The world of indexes is mostly uncharted territory. It&rsquo;s also important to keep in mind that you never want to create <em>too</em> many indexes, and only ones that we actually need, since they will <a href="http://www.rubyonrails365.com/low-hanging-fruits-for-better-sql-performance-in-rails/">slow down</a> the &ldquo;write&rdquo; time to the database (whenever we use SQL commands like <code>UPDATE</code> or <code>CREATE</code>, for example). But that doesn&rsquo;t mean we can&rsquo;t learn about the different kinds of indexes that exist and be completely wowed at how amazing databases are. See, this cat is completely floored &ndash; and quite frankly, I am too:</p>

<iframe src="//giphy.com/embed/vSSdLSLbGIXio" width="480" height="453" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>There are three main types of indexing: <em>single-column</em>, <em>compound</em>, and <em>unique</em> indexes. Compound indexes create an index on two ore more columns in a database, while unique indexes create a restraint on a single column index.</li>
<li>This <a href="http://stackoverflow.com/a/1049392">StackOverflow answer</a> is the best explanation of how compound indexes actually work in terms of running a query. If you&rsquo;re still confused, give it a read!</li>
<li>Uniqueness validations are super cool! Read more about them over <a href="https://robots.thoughtbot.com/the-perils-of-uniqueness-validations">here</a>, and check out some real-life examples of how to use them <a href="http://nyonura.com/blog/2014/Partial-Indexes-with-PostgreSQL-and-Rails/">here</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing Smart Migrations: References, Reversible, and Indexes]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/07/14/writing-smart-migrations-references-reversible-and-indexes/"/>
    <updated>2015-07-14T08:47:19-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/07/14/writing-smart-migrations-references-reversible-and-indexes</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/SUtPZfyDenHoY" width="480" height="270" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>All it takes is a single feature to make you realize how well &ndash; or perhaps not so well &ndash; you&rsquo;ve written your application. Depending on if you&rsquo;ve done a good job of separating concerns, abstracting and encapsulating bits of functionality into cohesive code, and just generally not repeating yourself&hellip;well, you&rsquo;ll probably be way more enthusiastic about adding a huge new feature to an already massive application. But if you haven&rsquo;t done any of those things&hellip;well, you might find yourself doing a massive rewrite of your codebase just to implement a single feature.</p>

<p>Luckily, the application I started adding a feature to last week is pretty well-built, which makes it flexible enough to add new functionality relatively easily. Yet even the most well-thought-out applications need to be teased apart and glued back together during the course of their lives. Often times, a big part of building out a new feature is restructuring the architecture of your application. When you&rsquo;re working with larger code bases (legacy code in particular), that can be the most daunting task. But a lot of the intimidation of that begins to dissipate once you know how to go about restructuring a schema which already exists without breaking all the the things.</p>

<p>The first step in this process is writing migrations to change how the objects in your application and database relate to one another. Of course, knowing how to write the proper migration to suit your needs is just half the battle; the other half is writing a migration that makes object lookup in your database efficient and super fast. Even though I&rsquo;ve <a href="http://vaidehijoshi.github.io/blog/2015/05/19/the-secret-life-of-your-database-part-1-migrations/">written about migrations</a> before, I&rsquo;m learning that there&rsquo;s always so much more to know. So, let&rsquo;s get learning!</p>

<!--more-->


<h2>Referencing Your References</h2>

<p>A really quick way to clean up our code is by changing the way that we create associations between objects from within our migrations. One feature we&rsquo;ll want to add is to have our <code>Book</code>s belong to a <code>Genre</code>. So far, we&rsquo;ve categorized our <code>Author</code>s by genre, but we&rsquo;ll want to be able to sort and organize our <code>Book</code> objects in a similar way.</p>

<p>We often use <code>belongs_to</code> and <code>has_many</code> inside of our migrations, which is totally valid. But in this case, it probably makes more sense to use something called <code>references</code>. According to the Rails <a href="https://github.com/rails/rails/blob/88aa2efd692619e87eee88dfc48d608bea9bcdb4/activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb#L421">source code</a>, <code>references</code> is just an alias of <code>belongs_to</code>. But, a <code>Book</code> doesn&rsquo;t really &ldquo;belong to&rdquo; a <code>Genre</code>, it&rsquo;s more that it should be able to &ldquo;reference&rdquo; the genre that it&rsquo;s associated with. We can add a reference fairly easily just like this:</p>

<pre><code class="ruby">class AddGenreToBooks &lt; ActiveRecord::Migration
  def change
    add_reference :books, :genre
  end
end
</code></pre>

<p>This will create a <code>genre_id</code> column inside of our <code>Books</code> table. We could also have done this initially inside of a <code>change</code> method, and written something like <code>t.references(:genre)</code> inside of our migration method. We also have the option to add a <code>type</code>, and specify whether the reference is a <code>polymorphic</code> association or not, as explained by the <a href="http://apidock.com/rails/ActiveRecord/ConnectionAdapters/Table/references">Rails API</a>:</p>

<blockquote><p><code>references</code>: Adds a reference. Optionally adds a type column, if :polymorphic option is provided. The reference column will be an integer by default, the :type option can be used to specify a different type. A foreign key will be created if a foreign_key option is passed.</p></blockquote>

<p>Using <code>references</code> instead of a typical <code>has_many</code> and <code>belongs_to</code> gives us a bit more flexibility moving forward, especially if we know that we&rsquo;ll be adding different types of associations in the long run.</p>

<h2>Reverse, reverse!</h2>

<p>One big feature we want to add to our Bookstore app is giving our <code>Books</code> a rating. There&rsquo;ll be some slightly complicated logic on the backend for this feature to actually work, since we&rsquo;ll need to update a <code>Book</code>&rsquo;s rating every single time a <code>User</code> rates it. But, let&rsquo;s not worry too much about how that logic will be implemented just yet. Instead, it&rsquo;ll be more helpful to break down this larger problem into a few smaller, bite-sized pieces.</p>

<p>First things first: do what we know. And we know that we&rsquo;ll need to give every <code>Book</code> a <code>rating</code> attribute. We&rsquo;ll want this to use Ruby BigDecimal, so we&rsquo;ll specify that in our migration. This migration will start out pretty simple, since all we want to do is just give our <code>Book</code>s a new attribute:</p>

<pre><code class="ruby">class AddRatingColumnToBooks &lt; ActiveRecord::Migration
  def change
    add_column :books, :rating, :decimal
  end
end
</code></pre>

<p>If we run <code>rake db:migrate</code>, and then open up our console, we can very quickly check that this added a column, just as we expected:</p>

<pre><code>♥ rails c
&gt; Book.all.pluck(:rating)
# =&gt; [nil, nil, nil, nil, nil, nil]
</code></pre>

<p>Uh oh, that&rsquo;s not so great. We really don&rsquo;t want all of the <code>Book</code>s that are <em>already</em> inside of our database to have <code>nil</code> values for their <code>rating</code>. Honestly, a more accurate representation of their <code>rating</code> would just be <code>0</code>, since none of our <code>User</code>s have actually given these products a rating yet.</p>

<p>What would be really nice is if we could do <em>two</em> things within this single migration: give our <code>Books</code> a <code>rating</code> column (done!), and set all of our pre-existing <code>Books</code> to have a <code>rating</code> of <code>0</code>. How can we do that? Well, by using <code>reversible</code>, of course!</p>

<p>We already know that we can use the <code>up</code> and <code>down</code> methods to migrate &ldquo;up&rdquo; and &ldquo;down&rdquo; the history or &ldquo;life&rdquo; of our database. But there&rsquo;s also another handy method that can help us out here, called <code>reversible</code>. Here&rsquo;s what the <a href="http://edgeguides.rubyonrails.org/active_record_migrations.html">Rails Guides</a> say about <code>reversible</code>:</p>

<blockquote><p>Complex migrations may require processing that Active Record doesn&rsquo;t know how to reverse. You can use <code>reversible</code> to specify what to do when running a migration and what else to do when reverting it. Using <code>reversible</code> will ensure that the instructions are executed in the right order too.</p></blockquote>

<iframe src="//giphy.com/embed/11EAsNbNMMcO3u" width="480" height="148" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>So how can we implement <code>reversible</code> here? Well, to start, we need a reversible block, which takes a direction. If you&rsquo;re thinking that the direction should be <code>up</code> or <code>down</code>, you&rsquo;d be right! Since we&rsquo;re only adding a column in this migration, we don&rsquo;t need to worry about a <code>down</code> method, since migrating down will automatically just drop the <code>rating</code> column that we&rsquo;re adding. What we do need to do is make sure that when we migrate <em>up</em>, we&rsquo;re also updating our current <code>Book</code> records. We can do that by specifying the <code>up</code> method on our direction, and then pass a block to <code>reversible</code> telling it what to do:</p>

<pre><code class="ruby">class AddRatingColumnToBooks &lt; ActiveRecord::Migration
  def change
    add_column :books, :rating, :decimal

    reversible do |direction|
      direction.up { Book.update_all(rating: 0.0) }
    end
  end
end
</code></pre>

<p>Cool, this migration seems great. Now, we&rsquo;re not only adding a <code>rating</code> column to our <code>Books</code> table, but we&rsquo;re also updating all of our pre-existing <code>Book</code> objects so that they have some default value for their <code>rating</code>. Nothing about this should break ever, right?</p>

<p>Wrong! Why? Because we can rename anything we want at any time&hellip;and then forget to change all of our files. When we decide to start selling music or movies and go full-on Amazon in our application, we&rsquo;ll probably want to rename our <code>Books</code> table to something like <code>Product</code> or <code>Item</code>. We&rsquo;ll create a new migration to rename our table, change our model names, and everything will be fine. Except for one teeny, tiny little problem: when we decide to deploy to Heroku and try to run <code>rake db:migrate</code>, everything will explode. And why might that happen? Well, because we renamed our table, and now we&rsquo;re trying to run a migration on a <code>Books</code> table for a <code>Book</code> model, which, at this moment in time, <em>doesn&rsquo;t even exist</em>.</p>

<p>So, how can we fix this? Well, we can actually define a <code>Book</code> model inside of this very migration file. And, we can do it all in a single line:</p>

<pre><code class="ruby">class AddRatingColumnToBooks &lt; ActiveRecord::Migration
  class Book &lt; ActiveRecord::Base; end

  def change
    add_column :books, :rating, :decimal

    reversible do |direction|
      direction.up { Book.update_all(rating: 0.0) }
    end
  end
end
</code></pre>

<p>Nice! Now, even if we forget to rename our old migrations, we can be sure that ActiveRecord won&rsquo;t complain if it can&rsquo;t find a <code>Book</code> model when this migration tries to run. In fact, it will <em>always</em> find a model no matter what we might rename our model or table to in the future because we&rsquo;ve defined an empty <code>Book</code> class inside of this migration file. We can be sure that this is the case because Ruby will first look for a class declaration inside of a file before searching anywhere else!</p>

<h2>Index All The Things</h2>

<p>Okay, time to get efficient. Let&rsquo;s look back at our first migration, where we were adding <code>Genre</code>s to <code>Book</code>s:</p>

<pre><code class="ruby">class AddGenreToBooks &lt; ActiveRecord::Migration
  def change
    add_reference :books, :genre
  end
end
</code></pre>

<p>This is fine, but there&rsquo;s one slight problem here: what if we only have a few <code>Genre</code>s, but a ton of <code>Book</code>s? When we want to run a method like <code>where</code> or <code>sort_by</code>, how will our application handle this? Well, without even testing out our query, we know it&rsquo;s not going to go so well. And why not? Because, as it stands, our application will have to sort through <em>every single one</em> of our books to find the ones that match our query. And after a couple hundred or thousands of books, this is going to massively slow down our application.</p>

<p>But, we&rsquo;re smart enough to foresee that problem! We&rsquo;ll outsmart our application from the get-go, and just write a smart migration to begin with:</p>

<pre><code class="ruby">class AddGenreToBooks &lt; ActiveRecord::Migration
  def change
    add_reference :books, :genre, index: true
  end
end
</code></pre>

<p>If we open up our <code>db/structure.sql</code>, we&rsquo;ll see this:</p>

<pre><code class="sql">CREATE TABLE books (
  rating numeric(10,2),
  genre_id integer
);

CREATE INDEX index_books_on_genre_id ON books USING btree (genre_id);
</code></pre>

<p>This created an <code>index</code> on our <code>Books</code> table, which is referenced to <code>Genre</code>. This is pretty amazing, because it means that our table will now use integers (not strings or any other data type) to look up an item on our table. Integer lookup is the cheapest and fastest way to look up an item in a database, which means that it&rsquo;s going to speed up our database like crazy!</p>

<p>We also could have just written a completely new migraiton for this as well, which would implement the <code>add_index</code> method:</p>

<pre><code class="ruby">class AddGenreIndexToBooks &lt; ActiveRecord::Migration
  def change
    add_index(:books, :genre)
  end
end
</code></pre>

<p>We could also use the <code>add_index</code> method to create unique indexes, or named indexes, as highlighted in the <a href="http://apidock.com/rails/ActiveRecord/ConnectionAdapters/SchemaStatements/add_index">documentation</a>. Sometimes, it&rsquo;s actually <a href="http://makandracards.com/makandra/32353-psa-index-true-in-rails-migrations-does-not-work-as-you-d-expect">safer</a> to use the <code>add_index</code> method rather than <code>index: true</code>.</p>

<p>Now our migrations are not just clear and concise, but they&rsquo;re also helping our application run smoother and quicker in the process. Writing smart migrations can not only save us a lot of time down the road, but they make feature-writing a lot more fun! Not as fun as running wildly through the safari, but hey &ndash; it&rsquo;s a close second:</p>

<iframe src="//giphy.com/embed/cyrx5VQ8PiWoE" width="480" height="270" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>Using <code>references</code> in a migration is the same as <code>belongs_to</code>, but can make your code more clear. The <code>reversible</code> method is great for specifying how your migration should handle a reverse migration. Indexes are an easy way of adding an iteger column to speed up database queries.</li>
<li>Need to see another example of manipulating data from within a migraiton? This <a href="http://railsguides.net/change-data-in-migrations-like-a-boss/">blog post</a> walks through some great examples using the <code>up</code> and <code>down</code> methods.</li>
<li>Check out this great <a href="https://www.reinteractive.net/posts/178-reversible-migrations-with-active-record">post</a> on how to implement <code>reversible</code> in different situations!</li>
</ul>

]]></content>
  </entry>
  
</feed>
