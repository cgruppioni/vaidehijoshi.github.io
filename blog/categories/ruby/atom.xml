<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-10-20T08:53:46-04:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Solutions for Slugs of All Sizes: Acts_as_url + To_param]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/10/20/solutions-for-slugs-of-all-sizes-acts-as-url-plus-to-param/"/>
    <updated>2015-10-20T08:17:21-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/10/20/solutions-for-slugs-of-all-sizes-acts-as-url-plus-to-param</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/g5FB33d3GVUkg" width="480" height="288" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Last week was my first week of working from home, which meant two things: spending a lot of time with my computer and limited time with other human beings and, more importantly, debugging things on my own without having anyone nearby to ask for help. The latter of the two actually ended up reaffirming the fact that I actually <em>can</em> debug a decent amount of things on my own if I just power through and am stubborn enough to not give up.</p>

<p>I also learned something interesting about the debugging process: while we&rsquo;re learning, we often solve the same problem again and again. At least, this was the case for one of the features I was working on which involved using an object&rsquo;s slug to generate a url. As I started thinking through how to approach solving this, I immediately had the feeling that I had done something similar in another project. Digging through another repository&rsquo;s source code confirmed my suspicions, and I rediscovered the <code>stringex</code> gem and its multiple libraries, including <code>acts_as_url</code>!</p>

<p>All of this begs the question: why didn&rsquo;t I remember that this gem existed &mdash; or that I had already used it? My guess is that it&rsquo;s because I neither wrote about it nor understood how it worked until a few days ago. This week, it&rsquo;s time to rectify that situation and dive into the <code>acts_as_url</code> library and find a solution for all slug problems, once and for all!</p>

<!--more-->


<h2>The Other Kind of Slug</h2>

<iframe src="//giphy.com/embed/C1aCu8kUyF6p2" width="480" height="350" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>We all are familiar with the Rails mantra of <em>convention over configuration</em>, aka making the lives of developers easier by eliminating the need for them to make decisions about how to structure their code. Now, this design paradigm is pretty fantastic, particularly when we&rsquo;re first learning a new framework. But eventually, there comes a time when we need to tweak our code&rsquo;s conventions just a tiny little bit.</p>

<p>What&rsquo;s an example of this? Well, take Rails convention of finding an object by it&rsquo;s <code>id</code>. This standardization pops up all over the place, but the one that we&rsquo;re particularly concerned with is the generation of a url. By default, Rails applications will build a URL path for the <code>show</code> action of any given controller based on the primary key (aka the <code>id</code> column in our database) of the object that we&rsquo;re trying to &ldquo;show&rdquo;.</p>

<p>Let&rsquo;s put this in context of our bookstore application. We have a bunch of <code>Book</code> objects, and we want to iterate through their titles and then link to their individual &ldquo;show&rdquo; pages. A very basic, not-at-all-fancy template might look something like this:</p>

<pre><code class="slim">h2 Books!
- @books.each do |book|
    p = link_to book.title, book_path(book)
</code></pre>

<p>It&rsquo;s important to note that we&rsquo;re actually passing in the <code>book</code> instance here &mdash; an <code>ActiveRecord</code> object, and <em>not</em> the <code>book</code>&rsquo;s <code>id</code>. Why is this important? Because there&rsquo;s a method that Rails is using to convert the <code>Book</code> object into a URL in order to generate the correct address for our <code>book_path</code>. That&rsquo;s why we need to pass it an <code>ActiveRecord</code> object, because the method that&rsquo;s being called expects an object and returns the <code>id</code> as parameters in the url. What does this look like, exactly? Well, right now our <code>book_path</code> takes a <code>Book</code> instance and creates a path that looks like this: <code>localhost:3000/books/25</code>.</p>

<p>Which is fine! Actually, it&rsquo;s more than fine: it&rsquo;s the expected behavior given our Rails mantra of convention over configuration. But, what if we actually <em>want</em> to configure this a little bit more. What if, instead of using the primary key of our <code>Book</code> instances, we wanted to use the title of the book? It would be lovely if we could link someone to a particular book&rsquo;s page with a more human-readable url (for example, something like <code>awesomebookstore.com/books/the-bell-jar</code> in production).</p>

<p>There&rsquo;s a solution for this problem, and it&rsquo;s called slugs. Slugs are a solution for semantic URL generation, which is also sometimes referred to as &ldquo;RESTful&rdquo; or &ldquo;SEO-friendly&rdquo; URL generation. As our application grows, not only would we want our URLs to be user-friendly, but we probably also will want them to be optimized for search engine results. So, we need to change our application&rsquo;s configuration to use a slug.</p>

<p><em>Protip:</em> if anyone ever pop quizzes you about where the term &ldquo;slug&rdquo; comes from, you can totally school them with the following interesting fact: a &ldquo;slug&rdquo; used to be <a href="https://en.wikipedia.org/wiki/Slug_(publishing)">a shorter name</a> given to a newspaper article while it was in production; during the editing process, the article would be labeled by its slug, which would more specifically indicate the content of the story to the editors and reporters. The more you know, amirite?</p>

<p>There are obviously a lot of ways to approach this, but why reinvent the wheel by writing a bunch of methods that someone else has already written? Let&rsquo;s make use of someone&rsquo;s open source work and use the <code>acts_as_url</code> library to get the job done for us!</p>

<h2>Don&rsquo;t Let Slugs Slow You Down</h2>

<iframe src="//giphy.com/embed/11zeCgKZ1MaNuE" width="480" height="342" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>The <code>acts_as_url</code> library is actually part of the <code>stringex</code> gem, which adds some useful extensions to Ruby&rsquo;s <code>String</code> class. After we add this gem to our <code>Gemfile</code> (<code>gem "stringex"</code>) and run <code>bundle install</code>, we can get started doing a quick setup.</p>

<p>The documentation for this library is fairly straightforward, and a quick read-through gives us a good idea of what we need to do in order to make it work properly. The basic implementation of this library is four-fold:</p>

<ol>
<li>We need a column in our database that will map to the attribute used in generating our url.</li>
<li>We need to call the <code>acts_as_url</code> method in our model using the attribute name that we want to use for generating our url.</li>
<li>We need to override Rails&#8217; <code>to_param</code> method (Confused? Hang tight, we&rsquo;ll get there in a second!)</li>
<li>We need to <code>find_by</code> our new url attribute inside of our controllers.</li>
</ol>


<p>Let&rsquo;s take it step by step. First, we&rsquo;ll write a migration that will add a <code>slug</code> column to our <code>books</code> database. This is going to be the column that will map to a <code>slug</code> attribute on our <code>Book</code> objects:</p>

<pre><code class="ruby">class AddSlugColumnToBooks &lt; ActiveRecord::Migration
  def change
    add_column :books, :slug, :string
  end
end
</code></pre>

<p>Once we run <code>rake db:migrate</code> and add this attribute, we will want to add the <code>acts_as_url</code> class method to our <code>Book</code> model.</p>

<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  acts_as_url :title, url_attribute: :slug
end
</code></pre>

<p>The default behavior of this method expects that we have a column and attribute called <code>url</code> on our object. Since we aren&rsquo;t using the default attribute name, we need to specify the name of the attribute that we&rsquo;re using to store the generated url string. Thankfully, <code>acts_as_url</code> takes a bunch of options, including <code>url_attribute</code>, which is what we&rsquo;re using here. There are some other useful options <a href="https://github.com/rsl/stringex">worth checking out</a> in the documentation, including <code>scope</code>, <code>limit</code>, <code>truncate_words</code>, and <code>blacklist</code>.</p>

<p>Next, we&rsquo;ll need to override Rail&rsquo;s <code>to_param</code> method in order to actually <em>use</em> our generated url attribute. Basically, we&rsquo;ll just want to write our own <code>to_param</code> method and return our <code>slug</code> attribute from inside of it.</p>

<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  acts_as_url :title, url_attribute: :slug

  def to_param
    slug
  end
end
</code></pre>

<p>And finally, we need to make sure that we&rsquo;re finding our object using the appropriate attribute from within the context of our controller. The documentation suggests we use
the <code>find_by_url</code> method, but we could also use the <code>find_by</code> method in our controller as well.</p>

<pre><code class="ruby">class BooksController &lt; ApplicationController
  def show
    @book = Book.find_by(slug: params[:id]).decorate
  end
end
</code></pre>

<p>Nothing changes about how our controller works and we can still do all the fancy things we were doing before, like use a decorator (<a href="http://vaidehijoshi.github.io/blog/2015/01/13/tidying-up-those-views-using-decorators-in-rails/">Remember those?</a>). The only thing that happens now is that our original <code>book_path</code> helper will now use the <code>book</code> instance we passed it to generate a url with a slug instead of the primary key!</p>

<p>Success! We&rsquo;ve done it! Actually, we&rsquo;ve <em>almost</em> done it. One tiny little thing that I always forget is all of the books that already exist in our database. What about them? They all have a <code>slug</code> attribute, sure, and a <code>slug</code> column &ndash; but there&rsquo;s a slight problem: the column is empty! So we can&rsquo;t <code>find_by</code> the <code>slug</code> attribute for those books, can we? In fact, if we try to call <code>to_param</code> on any of our preexisting <code>Book</code> instances right now, all we&rsquo;ll get is <code>nil</code>!</p>

<p>No worries, we just need to call a method inside of our console:</p>

<pre><code class="ruby">♥ rails c
Loading development environment (Rails 4.1.4)
irb(main):001:0&gt; Book.initialize_urls
</code></pre>

<p>Now all of the <code>Book</code> instances that had empty <code>slug</code> attributes have ben initialized, and we&rsquo;re good to go! Right? Wrong. Because I haven&rsquo;t explained the whole <code>to_param</code> situation yet, and I promised that I would get to it. Now&rsquo;s the time to figure out the magic behind that!</p>

<h2>Rails Non-Sluggish Solution: <code>to_param</code></h2>

<p>The Rails solution to generating params for an object&rsquo;s url path comes from its elegant <code>to_param</code> method. By default, this method just calls <code>to_s</code> on a Plain Old Ruby Object, and converts it to an instance of Ruby&rsquo;s <code>String</code> class. However, there are plenty of places where Rails itself <em>overrides</em> this method (which explains why we also have to do it in the context of our own controller)!</p>

<p>In fact, the Rails documentation even explains when and how to go about redefining the implementation of this method:</p>

<blockquote><p>&ldquo;Notably, the Rails routing system calls <code>to_param</code> on models to get a value for the <code>:id</code> placeholder. <code>ActiveRecord::Base#to_param</code> returns the <code>id</code> of a model, but you can redefine that method in your models.&rdquo;</p></blockquote>

<pre><code class="ruby">class User
  def to_param
    "#{id}-#{name.parameterize}"
  end
end
</code></pre>

<p>Of course, we could have easily redefined this in the context of each of our models, but using the <code>acts_as_url</code> library reduces the amount of duplicated code that we need in each of our models, and is pretty sophisticated in that it allows us to use <em>different</em> attributes across different models to generate our url path.</p>

<p>Interestingly, <a href="https://github.com/rails/rails/blob/7f18ea14c893cb5c9f04d4fda9661126758332b5/activemodel/lib/active_model/conversion.rb#L71">the source code</a> for Rails&#8217; <code>to_param</code> method reveals some elegant checks as well. This method first checks whether the object as been persisted to the database, and then returns a string representing the object&rsquo;s key. We can actually see how the <code>to_key</code> method is being called from <em>inside</em> of <code>to_param</code>, and how the default return value of an unpersisted object&rsquo;s param will be <code>nil</code>. This is the magic that goes on under the hood when we were trying to find the <code>slug</code> attributes for all of those <code>Book</code> instances before we called <code>initialize_urls</code> on them!</p>

<p>So, even though slugs have a <em>reputation</em> of being slow, now we know how to speed through this problem with an elegant and quick solution! I can&rsquo;t say the same for this poor guy, though:</p>

<iframe src="//giphy.com/embed/1KJPg114jm68U" width="480" height="169" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>acts_as_url</code> library expects an <code>url</code> attribute on a model, and uses that to generate the path for an object. You need to override Rails&#8217; <code>to_param</code> method that, by default, will use the <code>id</code> of an object to generate its path.</li>
<li>This <a href="https://gist.github.com/jcasimir/1209730>awesome gist</a> by Jeff Casimir is the best write-up on slugs and Rails&#8217; url generation out there. Give it a read!</li>
<li>The original <code>to_param</code> method used to be defined inside of <code>ActiveRecord::Base</code>, but has since moved to the <code>ActiveModel::Conversion</code> module, which handles default conversions, including <code>to_model</code>, <code>to_key</code>, and <code>to_partial_path</code>. Read more about how these methods work in the Conversion <a href="http://apidock.com/rails/ActiveModel/Conversion">module documentation</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stop Worrying and Start Being Concerned: ActiveSupport Concerns]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/10/13/stop-worrying-and-start-being-concerned-activesupport-concerns/"/>
    <updated>2015-10-13T09:22:16-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/10/13/stop-worrying-and-start-being-concerned-activesupport-concerns</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/iQA2hMPX88icM" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>A few weeks ago, while learning everything I never knew about <a href="http://vaidehijoshi.github.io/blog/2015/09/29/using-pundit-the-cool-kid-of-authorization/">user authorization</a>, I also stumbled upon a cool refactoring pattern that I didn&rsquo;t even know existed. This pattern is based on the simple idea of Ruby modules and mixins, but is particularly handy when it comes to dealing with class methods and callbacks.</p>

<p>ActiveSupport is a pretty massive component within Rails, and it&rsquo;s responsible for a ton of different functionality, including language extensions and utilities. I last wrote about ActiveSupport back when we were exploring the <a href="http://vaidehijoshi.github.io/blog/2015/09/01/inflections-everywhere-using-activesupport-inflector/">Rails inflector</a> and the libraries it provides for handling the pluralization of different strings. This was way back in September, and at the time, my understanding of ActiveSupport was pretty limited. It turns out that yes, ActiveSupport does provide a bunch of different patterns to transform simple Ruby strings&hellip;but it also has a lot more going on inside of it. For example, the <strong>ActiveSupport Concern module</strong>, which only recently made its debut in Rails 4.</p>

<p>The ActiveSupport::Concern wrapper is an interesting way of encapsulating&hellip;well, certain functionality that you might be <em>concerned</em> with. These concerns take advantage of two directories that are automatically part of the load path within a Rails application: <code>app/models/concerns</code> and <code>app/controllers/concerns</code>. So, how do you write a concern, and what should go inside of it? Don&rsquo;t worry, that&rsquo;s exactly what we&rsquo;ll concern ourselves with next.</p>

<!--more-->


<h2>Should We Be Concerned?</h2>

<iframe src="//giphy.com/embed/374pcIBVEGb6g" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Concerns are meant to make our lives less complicated. Or at the very least, we should be less concerned about the quality of our code if we use concerns, right? But what are ActiveSupport&rsquo;s Concerns really meant to be used for? And how do we know if we should be using them? Well, to answer this question, we can turn to the creator of Rails himself. In a blog post pre-Rails 4 titled <em>Put chubby models on a diet with concerns</em>, DHH explains when and why to consider using ActiveSupport&rsquo;s Concern module:</p>

<blockquote><p>&ldquo;Concerns encapsulate both data access and domain logic about a certain slice of responsibility. Concerns are also a helpful way of extracting a slice of model that doesn’t seem part of its essence (what is and isn’t in the essence of a model is a fuzzy line and a longer discussion) without going full-bore Single Responsibility Principle and running the risk of ballooning your object inventory.&rdquo;</p></blockquote>

<p>When we talk about concerns, what we really are honing in on is the most effective <em>separation of concerns</em>. I really like the way that David thinks of models having an &ldquo;essence&rdquo;, and I think that this is a great way of approaching when and when <em>not</em> to use a concern.</p>

<p>Let&rsquo;s look at our bookstore application. We have an <code>User</code> model for anyone that signs up to use our application. Whenever a <code>User</code> signs up, we want to send them an email telling them that they&rsquo;ve been registered, and probably highlighting some of the cool things that they can do to set up their profile on our application. Now, this seems like something that only the <code>User</code> model would be concerned with, right? Well, yes, until we realize that we have another model that needs to share this same functionality!</p>

<p>For example, we now have organizations that want to sign up for our application. They also need to receive the same email and be &ldquo;registered&rdquo;. As our application grows, we might even want to create a <code>Registration</code> model, which would belong to an <code>User</code> and <code>Organization</code>. Now, obviously we could accomplish what we wanted to by just adding the same lines of code to both models, but that makes for neither DRY code, nor a great separation of concerns. But wouldn&rsquo;t it be great if we could take this piece of &ldquo;registration&rdquo; functionality, wrap it up, and only pull it out when we need to use it? It turns out that is exactly what we can do with <code>ActiveSupport::Concern</code>.</p>

<h2>Extending Our Concerns</h2>

<iframe src="//giphy.com/embed/dnNuJUQvEnmjC" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Before we write our concern, let&rsquo;s look at what our <code>User</code> model looks like. Here&rsquo;s a truncated version that contains only the logic pertaining to registering a user:</p>

<pre><code class="ruby">class User &lt; ActiveRecord::Base
    after_commit :register_user, on: :create

    def register_user
        # Where our logic for registering a user
        # would go. Would call on a background job
        # to perform and send our registration email.
    end
end
</code></pre>

<p>We very well <em>could</em> stick this inside of our <code>organization.rb</code> model file, but there&rsquo;s a better way to do this. There are a few steps to creating a concern, the first of which is recognizing where to put it! Since we&rsquo;re creating a concern for a model, this will live inside of our <code>app/models/concerns</code> directory. We&rsquo;ll call this concern a  <code>Registerer</code> concern, since that&rsquo;s its single responsibility, and we can preemptively namespace our concern under <code>Users</code>, which would make its path <code>app/models/concerns/users/registerer.rb</code>.</p>

<p>Next, we&rsquo;ll want to <code>extend</code> the Rails <code>ActiveSupport::Concern</code> module itself from within our concern:</p>

<pre><code class="ruby">module Users
    module Registerer
        extend ActiveSupport::Concern
    end
end
</code></pre>

<p>Now, for the actual writing, there&rsquo;s one method that&rsquo;s going to be our new best friend: the <code>included</code> method, which takes a block. A little-known fact about this callback is that it&rsquo;s actually defined by Ruby&rsquo;s <code>Module</code> class, and it&rsquo;s called whenever a module is &ldquo;included&rdquo; into another class or module. This is where we&rsquo;ll put the important class methods and callbacks that we want to be shared amongst the models that will use our concern.</p>

<pre><code class="ruby">module Users
    module Registerer
        extend ActiveSupport::Concern

        included do
            has_one :registration, dependent: :destroy

            after_commit :register_user, on: :create
        end

        def register_user
            send_registration_email(self)

            touch(:registered_at)
        end

        def send_registration_email(self)
            RegistrationEmailerJob.perform_later(self)
        end
    end
end
</code></pre>

<p>This is mostly straightforward. All the logic for a registration now lives in this single file, including the creating of a registration association on our target object (in this case, the <code>User</code> model), the registering of a user by passing our <code>User</code> instance (<code>self</code>) to our <code>RegistrationEmailerJob</code>, and the updating of the <code>registered_at</code> attribute on our <code>User</code> model using the <a href="http://vaidehijoshi.github.io/blog/2015/09/22/working-hard-or-hardly-working-part-2-custom-jobs/">touch method</a> &mdash; assuming, of course, that we&rsquo;ve defensively coded this attribute onto our <code>User</code> model. We&rsquo;re also able to use the <code>after_commit</code> callback hook, since the <code>included</code> method can accept callback names as parameters.</p>

<p>Now that we have all this code in one place, how do we add it to our model? Well, we can do it in a single line:</p>

<pre><code class="ruby">class User &lt; ActiveRecord::Base
    include Users::Registerer
end
</code></pre>

<p>All we need to do is <code>include</code> our concern, just as we would a module. And down the road, when we find out that we need to create <code>Organization</code> model that shares this set of functionality, all we need to do is add the exact same line to our new model:</p>

<pre><code class="ruby">class Organization &lt; ActiveRecord::Base
    include Users::Registerer
end
</code></pre>

<p>And here&rsquo;s the really nice part about utilizing concerns in this way: when we realize that we need to change how this works &mdash; maybe we need to add another job or service object, or perhaps another, more specific callback &mdash; we can add it to one place and update our logic in a single file! This ties in quite nicely to DHH&rsquo;s point of a model&rsquo;s &ldquo;essence&rdquo;. In this case, being able to be &ldquo;registered&rdquo; isn&rsquo;t necessarily something that pertains to the <code>User</code> model specifically. But, it also doesn&rsquo;t need to be its own <em>object</em> per se. Instead, we really just need a set of methods that can be available to be invoked upon an object, which is exactly what <code>ActiveSupport::Concern</code> provides us with.</p>

<h2>Helpful Inclusion</h2>

<p>Because concerns are so simple to extend and include, there are lots of use cases for them. We learned earlier that Rails comes with two <code>concerns</code> directories preloaded: one for <code>models</code>, and another for <code>controllers</code>. Let&rsquo;s look at a practical example for using <code>ActiveSupport::Concern</code> in the context of a controller.</p>

<p>We <a href="http://vaidehijoshi.github.io/blog/2015/09/29/using-pundit-the-cool-kid-of-authorization/">recently added</a> the <code>pundit</code> gem to our bookstore app for user authorization. But we only had a few controller actions that actually <em>needed</em> to be authorized; the rest of our controllers didn&rsquo;t need any authorization, because they could be accessed by anyone. Our <code>Reviews</code> controller was being authorized, for example, but our <code>Comments</code> controller didn&rsquo;t need any authorization whatsoever.</p>

<p>So, for the controllers that <em>didn&rsquo;t</em> need authorization, what did we do? Well, we were adding some <code>skip_after_actions</code> lines, which were instructions that the <code>pundit</code> gem documentation had given us:</p>

<pre><code class="ruby">class CommentsController &lt; ApplicationController
  skip_after_action :verify_authorized
  skip_after_action :verify_policy_scoped

  # RESTful controller actions go here!
end
</code></pre>

<p>Now, imagine we also have a <code>BlogsController</code> with just an <code>index</code> action API endpoint, which doesn&rsquo;t need to be authorized. And maybe we also have <code>TagsController</code>, which also doesn&rsquo;t need to be authorized by <code>pundit</code>. We <em>could</em> copy and paste these two lines into every single controller&hellip;<em>or</em>, we could use our newfound knowledge of <code>ActiveSupport::Concern</code>!</p>

<p>Let&rsquo;s share some of this code, shall we? We can create a <code>skip_authorized.rb</code> file inside of <code>app/controllers/concerns</code>. And inside of it, we&rsquo;ll include <code>Pundit</code> &mdash; otherwise, our <code>skip_after_actions</code> will have no idea what actions we&rsquo;re trying to skip! Our concern might look something like this:</p>

<pre><code class="ruby">module SkipAuthorized
  extend ActiveSupport::Concern

  included do
    skip_after_action :verify_authorized
    skip_after_action :verify_policy_scoped
  end
end
</code></pre>

<p>Pretty simple, right? And suddenly, our <code>CommentsController</code>, <code>BlogsController</code>, <code>TagsController</code>, and pretty much <em>every single</em> controller that we want to share these <code>skip_after_action</code> callbacks now can be refactored to have this single line:</p>

<pre><code class="ruby">class CommentsController &lt; ApplicationController
    include SkipAuthorized

    # RESTful controller actions go here!
end
</code></pre>

<p>And now, if we wanted to <code>rescue</code> from a <code>Pundit::UnauthorizedError</code>, we could add a single line, into a single file&hellip;but all of our controllers would mix that in! Similarly, we could create an <code>Authorized</code> concern for every controller that needed to actually implement <code>pundit</code> authorization. See, there&rsquo;s no need to worry for the rest of our days, because instead, we can just be concerned &mdash; ActiveSupport concerned!</p>

<iframe src="//giphy.com/embed/jfw9xNEouCJO" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>ActiveSupport&rsquo;s <code>Concern</code> module allows us to mix in callbacks, class and instance methods, and create associations on target objects. This module has an <code>included</code> method, which takes a block, as well as an <code>append_features</code> method and <code>class_methods</code> block, which you can read about in <a href="http://api.rubyonrails.org/classes/ActiveSupport/Concern.html#method-i-included">the source code</a>.</li>
<li>This <a href="http://engineering.appfolio.com/2013/06/17/ruby-mixins-activesupportconcern/">blog post</a> is pretty fantastic in its explanation of mixins, modules, and concerns.</li>
<li>Concerns are a little controversial in Railsland. This <a href="http://www.slideshare.net/justingordon/rails-conf-2014concernsdecoratorspresentersserviceobjectshelpershelpmedecideapril222014">slide deck</a> from RailsConf 2014 shares a bit about why that&rsquo;s the case.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fleeting Filing With Ruby Tempfile]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/10/06/fleeting-filing-with-ruby-tempfile/"/>
    <updated>2015-10-06T08:46:30-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/10/06/fleeting-filing-with-ruby-tempfile</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/3ViDyv13D9HQQ" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>There are times in a Ruby program or Rails application that one comes to a single realization: <em>Oh no, I need to deal with an external file!</em> For larger applications, this might manifest as a request to your Amazon S3 bucket for a file, which you then need to modify in some way, or perhaps just simply read and have access to. But sometimes, even a simple Ruby script or plain old Ruby class may need to read or write to an external file.</p>

<p>I honestly didn&rsquo;t know a lot about Ruby&rsquo;s File class (wait, Ruby has a <em>file</em> class?! Yes, yes it does.) until recently, when I had to handle a situation that would allow me to download files from a file storage service (such as S3), and then process the file locally on my machine. The process was a bit complicated, and I still think that I have more to learn about how it actually works. But, one thing that I <em>did</em> actually start to wrap my head around is <strong>Ruby Tempfiles</strong>. Yup, that&rsquo;s right: not only does Ruby have a <code>File</code> class &mdash; it also has a <code>Tempfile</code> class.</p>

<p>It turns out that these two classes intersect quite a bit, and it can be a little confusing to know how they differ. The only way to really understand Ruby&rsquo;s <code>Tempfile</code> class is to play around with it and create some tempfiles. So let&rsquo;s get filin&#8217;!</p>

<!--more-->


<h2>To File Or To Tempfile</h2>

<iframe src="//giphy.com/embed/TxIwSAVQL18WI" width="480" height="430" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>The reason that the <code>Tempfile</code> class and <code>File</code> class seem so similar &mdash; and can therefore be so confusing &mdash; is because the <code>Tempfile</code> class actually inherits from its parent delegate class, which just so happens to be&hellip;<code>File</code>! So, tempfiles are actually just a type of file. So, what can you do with files in Ruby? And what makes tempfiles different from a regular old file?</p>

<p>Well, the <a href="http://ruby-doc.org/core-2.2.0/File.html">documentation</a> for <code>File</code> objects is hugely informative, and if we dove into it, we&rsquo;d learn that Ruby files actually inherit from a class called <code>IO File</code>. But let&rsquo;s not get too distracted here: what can we do with files, again? Well, we can read a file&rsquo;s data, we can write more data to it, and we can even change its permissions (i.e. who can access and write to the file). Pretty straightforward, right?</p>

<p>Now, onto tempfiles. As their name would suggest, they&rsquo;re files that are temporary. But even though they are named pretty well, it still might not be clear in what <em>way</em> these files are temporary. Well, we can create tempfiles in the same way that we create regular Ruby files, but what makes them unique is that tempfiles <strong>only exist as long as there is a reference to them</strong>. In other words, tempfiles get deleted automatically by the Ruby garbage collector. If no variable is pointing (read: assigned) to a tempfile, the garbage collector will &ldquo;finalize&rdquo; the tempfile object, and the file would be deleted from our system.</p>

<p>So&hellip;why is this significant? Well, what would happen if we tried to access a tempfile that Ruby has deleted? Bad things, that&rsquo;s what! Well, we&rsquo;d actually just get an error, because we&rsquo;d be trying to access a file at a path that doesn&rsquo;t exist anymore. But still, things could get pretty bleak if we didn&rsquo;t know what was going on &mdash; or worse, if we didn&rsquo;t fundamentally understand how tempfiles worked!</p>

<p>A good rule of thumb for deciding whether or not to use a tempfile is this: if we need access to the file outside of the context of our Ruby script, we probably shouldn&rsquo;t be using a tempfile. However, if we want to temporarily create, read, or write to a file, and then have Ruby delete it for us (for free!) when we&rsquo;re done using it, then a tempfile is our new best friend!</p>

<h2>The Order of Filing Operations</h2>

<iframe src="//giphy.com/embed/xTiTnjZAjQipGn9JFS" width="480" height="143" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>When it comes to creating files, there&rsquo;s a certain order of operations with method invocation. Even though the documentation for the <code>Tempfile</code> class has a list of helpful methods for us to use, there&rsquo;s a lot of less obvious functionality at our disposal, as long as we know where to look. Because the Ruby <code>Tempfile</code> essentially inherits from <code>File</code>, a tempfile behaves just like a file object. This means that we can call any <code>File</code> instance method on a <code>Tempfile</code> object. This is particularly important to note since some of the most common methods that are called on a tempfile are actually defined within the <code>File</code> class. So, if we couldn&rsquo;t find where a particular method on a tempfile was being defined, it probably means that we need to go look inside of the <code>File</code> class.</p>

<p>Okay, enough talk about where to <em>find</em> these methods; let&rsquo;s figure out which methods are actually pertinent to tempfiles. Both files and tempfiles share a sequence of events: generally, we create the file, then we read or write to it, and then we close it. But with tempfiles, there&rsquo;s a little twist at the end. Let&rsquo;s take a look at the order of filing operations:</p>

<h3>1. <code>new</code></h3>

<p>This method is pretty self-explanatory: it&rsquo;s what we&rsquo;ll use to create a new tempfile. This comes from the <code>File</code> class, and takes a single argument: the name of our file. Let&rsquo;s create a tempfile called <code>cats</code>:</p>

<pre><code>♥ irb
irb(main):001:0&gt; tempfile = Tempfile.new('cats')
=&gt; #&lt;Tempfile:/var/folders/v7/8rk39kc11ln54w3tl7twrhwc0000gn/T/cats20151005-24769-ac6qgw&gt;
</code></pre>

<p>This creates a unique filename in our operating slystem&rsquo;s temp directory, and it contains our filename <code>cats</code> in its basename. If we wanted to find out exactly <em>where</em> in our temp directory this file lives, we could just ask it for its path using &mdash; you guessed it &mdash; the <code>path</code> method:</p>

<pre><code>irb(main):002:0&gt; tempfile.path
=&gt; "/var/folders/v7/8rk39kc11ln54w3tl7twrhwc0000gn/T/cats20151005-24769-ac6qgw"
</code></pre>

<p>We could also specify the extension of the file that we&rsquo;re creating (i.e., <code>pdf</code>, <code>gif</code>, etc.). However, it&rsquo;s not as simple as just appending it to our filename; if we do that, this is what happens:</p>

<pre><code>irb(main):003:0&gt; Tempfile.new('cats.pdf').path
=&gt; "/var/folders/v7/8rk39kc11ln54w3tl7twrhwc0000gn/T/cats.pdf20151006-24769-xvpyh0"
</code></pre>

<p>Not great! We don&rsquo;t want our extension to be a <em>part</em> of our filename, we want it to be at the end, obviously! Luckily, the <code>new</code> method <a href="http://makandracards.com/makandra/13719-ruby-how-to-ensure-a-tempfile-s-extension">allows us</a> to pass the filename and extension as an array:</p>

<pre><code>irb(main):004:0&gt; Tempfile.new([ 'cats', '.pdf' ]).path
=&gt; "/var/folders/v7/8rk39kc11ln54w3tl7twrhwc0000gn/T/cats20151006-24769-1kzx615.pdf"
</code></pre>

<p>Much better! Now, let&rsquo;s open this file up.</p>

<h3>2. <code>binmode</code></h3>

<p>The next step is to put our file into binary mode by using the <code>binmode</code> method. As <a href="http://ruby-doc.org/core-2.0.0/IO.html#method-i-binmode">the documentation</a> explains, this method is what changes how we write data to the tempfile&rsquo;s binary.</p>

<pre><code>irb(main):005:0&gt; tempfile.binmode
=&gt; #&lt;File:/var/folders/v7/8rk39kc11ln54w3tl7twrhwc0000gn/T/cats20151005-24769-ac6qgw&gt;
</code></pre>

<p>This disables us from encoding and creating new lines, and it changes the way that we write content; setting a file to binary mode forces Ruby to treat the content as ASCII-8BIT. There&rsquo;s also a handy <code>binmode?</code> method that we can use to check whether our file is in binary mode or not.</p>

<h3>3. <code>write</code></h3>

<p>Finally, once we&rsquo;re in binary mode, we actually write to our file! And of course, the tool for the job is the <code>write</code> method. This takes a parameter of whatever it is that you want to write to the file.</p>

<pre><code>irb(main):006:0&gt; file.write("meow meow meow")
</code></pre>

<p>Interestingly, this method is <a href="http://ruby-doc.org/core-2.2.3/IO.html#method-c-write">defined</a> in the <code>IO</code> class, which subclasses into <code>StringIO</code>.</p>

<h3>4. <code>rewind</code></h3>

<p>Now, if we wanted to read to our file, we could just read it, right?</p>

<pre><code>irb(main):007:0&gt; file.read
=&gt; ""
</code></pre>

<p>Wait, what happened to our <code>"meow meow meow"</code> string? Well, if we think about it, when we were writing to our file, we ended at the end of wherever we stopped writing. And that means that there&rsquo;s nothing to read, because we&rsquo;re at the <em>end</em> of our file. This calls for the <code>rewind</code> method, which will take us back to the beginning of our tempfile.</p>

<pre><code>irb(main):008:0&gt; file.rewind
=&gt; 0
</code></pre>

<p>We&rsquo;re now at the beginning of our file!</p>

<h3>5. <code>read</code></h3>

<p>After rewinding back to the beginning of our file, we can now actually read it using the <code>read</code> method:</p>

<pre><code>irb(main):009:0&gt; file.read
=&gt; "meow meow meow"
</code></pre>

<p>So far, we&rsquo;ve been working with this file as though it&rsquo;s a normal Ruby <code>File</code> class. But let&rsquo;s not forget&hellip;this is actually a <code>Tempfile</code>. And dealing with how to close and clean up a tempfile is where things can get tricky. Now all that&rsquo;s left is for us to elegantly handle these fleeting, disappearing files.</p>

<h2>Disappearing Files</h2>

<p>The last steps in the order of filing operations is explicitly closing our tempfile. This is probably the most complicated part to understand, especially if we&rsquo;re not familiar with the concept of garbage collection. However, I think that the Ruby docs do a pretty great job of explaining the how and why of explicitly closing tempfiles, a good practice that the core team strongly encourages:</p>

<blockquote><p>&ldquo;When a Tempfile object is garbage collected, or when the Ruby interpreter exits, its associated temporary file is automatically deleted. This means that it’s unnecessary to explicitly delete a Tempfile after use, though it’s good practice to do so: not explicitly deleting unused Tempfiles can potentially leave behind large amounts of tempfiles on the filesystem until they’re garbage collected. The existance of these temp files can make it harder to determine a new Tempfile filename.&rdquo;</p></blockquote>

<p>The guides suggest that the best way to go about deleting a tempfile after we&rsquo;re done using it is by calling two specific methods from within an <code>ensure</code> block (remember the <code>ensure</code> keyword? No? Don&rsquo;t worry, you can read about it <a href="http://vaidehijoshi.github.io/blog/2015/08/25/unlocking-ruby-keywords-begin-end-ensure-rescue/">over here</a>).</p>

<p>But first, let&rsquo;s round out our order of filing operations with the two most important tempfile methods.</p>

<h3>6. <code>close</code></h3>

<p>This method basically tells the Ruby interpreter, <em>you can&rsquo;t read the file now!</em>. It closes the file and doesn&rsquo;t allow it to be read or written to.</p>

<pre><code>irb(main):010:0&gt; file.close
=&gt; nil
</code></pre>

<p>Some blogs have mentioned that this method isn&rsquo;t always necessary, but it can&rsquo;t hurt to use it.</p>

<h3>7. <code>unlink</code></h3>

<p>This method is what actualy <em>deletes</em> the file from the filesystem.</p>

<pre><code>irb(main):034:0&gt; file.unlink
=&gt; #&lt;Tempfile:&gt;
</code></pre>

<p>We could also use the <code>delete</code> method, which is just an alias for <code>unlink</code>.</p>

<p>Playing with these methods in <code>irb</code> has been fun, but what would this look like in a Rails application? Well, we&rsquo;d probably want a single method to handle the creation, writing, and deletion of our tempfile (think separation of concerns!). And this is where the use of our <code>ensure</code> block would come in.</p>

<p>This might look something like this:</p>

<pre><code class="ruby">def file_attachment
  tempfile = Tempfile.new(SecureRandom.uuid)
  tempfile.binmode

  begin
    tempfile.write("some text we could write dynamically")

    tempfile.rewind
  ensure
    tempfile.close
    tempfile.unlink
  end
end
</code></pre>

<p>Here, we&rsquo;re using all of the methods in our order of tempfile operations! And, because ensure runs <em>even if</em> there were any errors raised, we&rsquo;re basically always going to handle the closing and deleting of our tempfile. In this case, we probably don&rsquo;t want to call all our tempfiles <code>cats</code>, so instead we can be a bit more fancy and use the <code>SecureRandom</code> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/securerandom/rdoc/SecureRandom.html">module</a> to create a base64 tempfile name each time. We even go crazy and take this yet another step further, and have our <code>file_attachment</code> method take a block, which we could <code>yield</code> to inside of our <code>begin</code> block, before we <code>rewind</code> to the beginning of our tempfile.</p>

<p>As you can see, the possibilies are pretty endless! Tempfiles are our oysters! Well, until Ruby&rsquo;s garbage collector deletes them, that is.</p>

<iframe src="//giphy.com/embed/m77wEsvF99FyU" width="480" height="322" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The fundamental difference between Ruby&rsquo;s <code>File</code> class and <code>Tempfile</code> class is that tempfiles are cleaned up (deleted by the garbage collector) once there is nothing pointing to them. Tempfile objects inherit from the <code>File</code> class, which means that we can use any file method on a <code>Tempfile</code> instance.</li>
<li>The <code>unlink</code> method is super important to use, since that&rsquo;s what actually deletes our tempfile from the filesystem.</li>
<li>There are some great tutorials out there on dealing with creating files and directories from within a Ruby script. Check out my two favorites <a href="http://code.tutsplus.com/tutorials/ruby-for-newbies-working-with-directories-and-files--net-18810">here</a> and <a href="http://www.techotopia.com/index.php/Working_with_Files_in_Ruby">here</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Pundit, the Cool Kid of Authorization]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/09/29/using-pundit-the-cool-kid-of-authorization/"/>
    <updated>2015-09-29T08:57:21-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/09/29/using-pundit-the-cool-kid-of-authorization</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/OdVug9ZRk8sqA" width="480" height="192" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Ah, authorization &ndash; or as I like to call it, authentication&rsquo;s cooler, slightly less complicated twin. It&rsquo;s easy to confuse the two, but there&rsquo;s a fundamental difference between them. I recently learned that while setting up an authorization system for an application that&rsquo;s nearing the end of development. Authentication focuses on who you are as a user &mdash; an admin, guest, or user with an account, for example &mdash; while authorization is about what actions you can take. Authorization centers around what you are actually <em>able to do</em> within the context of your role.</p>

<p>It often makes sense to leave authorization as one of the later (and sometimes, last) step of development, purely because it means that you don&rsquo;t need to worry about making sure that you are authenticated in your development environment while you are still building out your application. But eventually, somewhere between development and deployment, you&rsquo;ll have to think about the abilities of your users &mdash; or, what they can and can&rsquo;t do.</p>

<p>There are a few different ways to go about creating an authorization system, one of the most popular being <code>can_can</code>, a gem that has been around in the Rails community since 2010, as well as a newer gem called <code>rolify</code>. But the one that I&rsquo;ve found really easy and fun to work with is <code>pundit</code>, an <a href="https://github.com/elabs/pundit">authorization system</a> crafted by eLabs, and interestingly enough, based off of the logic and thought behind the CanCan&rsquo;s approach. The developers at eLabs actually started off using the CanCan library in their own applications, but quickly realized that it could become very complicated, very quickly. So, they built the simpler authorization system of <code>pundit</code>, which is exactly what we&rsquo;ll play around with today!</p>

<!--more-->


<h2>Policies of Pundit</h2>

<iframe src="//giphy.com/embed/zCn93ehzAzZNC" width="480" height="198" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Implementing the <code>pundit</code> gem is easy once we understand how it&rsquo;s structured, what it&rsquo;s expecting, and what conventions to follow. But before we do anything else, we&rsquo;ll need to add it to our <code>Gemfile</code>:</p>

<p><code>gem "pundit"</code></p>

<p>and run our favorite command, <code>bundle install</code>.</p>

<p>The documentation for this gem is fairly well-explained, and even allows you to generate all the basic files you need with a single command (<code>rails g pundit:install</code>). However, generators can be a little bit dangerous if you don&rsquo;t understand what&rsquo;s going on behind the scenes, since all logic has been abstracted away and things start happening automagically! So, let&rsquo;s set up our authorization system for our bookstore manually. Don&rsquo;t worry &mdash; it&rsquo;s not going to be <em>too</em> painful!</p>

<p>First things first: we need to make sure that we include <code>pundit</code> in our controllers. This is a particularly important step because we&rsquo;re going to use a method inside of all of our controllers, and if we don&rsquo;t <code>include Pundit</code>, none of our controllers will have any idea what method we&rsquo;re trying to call. Since we&rsquo;re going to be authorizing multiple classes, it makes sense to add <code>pundit</code> to the file where all our other controllers will inherit from: <code>ApplicationController</code>.</p>

<pre><code class="ruby">class ApplicationController &lt; ActionController::Base
  include Pundit
  protect_from_forgery
end
</code></pre>

<p>Next, we need to understand how <code>pundit</code> actually works. If we take a look at <a href="https://github.com/elabs/pundit">the documentation</a>, there are a few things that immediately become clear: <code>pundit</code> is focused around something called &ldquo;policy classes&rdquo;. Similar to how <code>cancan</code> relies &ldquo;ability classes&rdquo;, <code>pundit</code> expects a policy class to house our authorization logic.</p>

<p>Okay, so we need policy classes. But what kind of classes are they? Do they inherit from anything? How many do we need, exactly? And what should go inside of them? If these are the questions running through your head, fret not: there are answers to all of them!</p>

<p>Here are the basics of building a <code>pundit</code> policy class:</p>

<ol>
<li>Every policy class is just a plain old ruby class. It doesn&rsquo;t need to inherit from <code>ActiveRecord::Base</code>, or anything else. The only thing that the class <em>must</em> have is the suffix <code>Policy</code>.</li>
<li>Each policy class should contain the authorization logic for the model class that it corresponds to. A <code>User</code> model would have a <code>UserPolicy</code>, while a <code>Book</code> model would have a <code>BookPolicy</code> class.</li>
<li>A policy class should initialize with two instance variables: a <code>user</code>, and the <code>model</code> that we want to authorize. The <code>initialize</code> method in a policy class will always expect these two parameters in a certain order: <code>user</code> as the first argument, and the <code>model</code> object that we want to authorize as the second arugment. The <code>model</code> doesn&rsquo;t have to be an <code>ActiveRecord</code> object &ndash; it can literally be anything that you want to authorize!</li>
<li>Inside of the policy class are query methods that actually contain the code for specific authorization checks. These should correspond and map to the actions in the controller for the model we want to authorize. If our <code>UsersController</code> has <code>create</code>, <code>update</code>, and <code>destroy</code> actions, our <code>UserPolicy</code> class should (theoretically) have <code>create?</code>, <code>update?</code>, and <code>destroy?</code> query methods inside of it.</li>
</ol>


<p>Okay, that&rsquo;s enough on policies to start. Let&rsquo;s actually start writing some of those policy classes! We&rsquo;ll need to create a folder for all of our policies since we&rsquo;re not using the generator (<code>app/policies</code>), which will house our policy classes. The most important policy class that we should write first is our <code>ApplicationPolicy</code>, which will reside at <code>app/policies/application_policy.rb</code>. This is where we can put our <code>initialize</code> method in, since we know that every policy needs to have this method inside of it.</p>

<pre><code class="ruby">class ApplicationPolicy 
  attr_reader :user, :resource

  def initialize(user, resource)
    @user = user
    @resource = resource
  end
end
</code></pre>

<p>Since the <code>initialize</code> method of our <code>ApplicationPolicy</code> is going to be used by all of our other policy classes, we can refer to the second argument (the model that we want to authorize) as <code>resource</code>. Depending on what policy class we are in, the <code>resource</code> object will change. If we had used the generator, we&rsquo;d notice that the model object is actually referred to as <code>record</code>, which also would have been an acceptable name for our second argument. Either way, this is a nice and easy way of abstracting out this method into one file, and then reusing it in our other policy classes. Speaking of which&hellip;it&rsquo;s time for us to write those, next!</p>

<h2>Authorize Me</h2>

<iframe src="//giphy.com/embed/4SmyjSEh4wsPm" width="480" height="202" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>We&rsquo;ll start by authorizing (one of) the most important objects in our application: our users! Since we have a <code>User</code> model, we&rsquo;ll need to abide by <code>pundit</code>&rsquo;s policies, and create a <code>user_policy.rb</code> file inside of <code>app/policies</code>. We&rsquo;ll make sure that it inherit from <code>ApplicationPolicy</code>, so that we&rsquo;ll have access to the <code>initialize</code> method:</p>

<pre><code class="ruby">class UserPolicy &lt; ApplicationPolicy
end
</code></pre>

<p>Next, let&rsquo;s take a look at our <code>UsersController</code>:</p>

<pre><code class="ruby">class UsersController &lt; ApplicationController

    # Some more RESTful actions would go here,
    # probably like #create and #destroy 

    def update
      user = User.find(params[:id])

      user.assign_attributes(user_params)

      if user.save
        render json: user
      else
        render json: {}, status: :unprocessable_entity
      end
    end

    private

    def user_params
      params.require(:user).permit(:name, :email)
    end
end
</code></pre>

<p>There&rsquo;s nothing too fancy going on in here at the moment, and for now, we&rsquo;re only concerned with authorizing the <code>update</code> action in our <code>UsersController</code>. Ultimately, we don&rsquo;t want any user to be able to update their information unless they are logged in; in other words, a user shouldn&rsquo;t be able to update anyone else&rsquo;s name and email except for their own.</p>

<p>So, if we want to authorize the <code>update</code> action, we&rsquo;ll need a query method in our <code>UserPolicy</code> class called &mdash; you guessed it &mdash; <code>update?</code>:</p>

<pre><code class="ruby">class UserPolicy &lt; ApplicationPolicy

    # Inherited from ApplicationPolicy:
    # def initialize(user, resource)
        # @user = user
        # @resource = resource
    # end

    def update?
        user == resource
    end
end
</code></pre>

<p>All we&rsquo;re doing here is verifying that the <code>user</code> instance that we&rsquo;re passing in to the <code>initialize</code> method (which we&rsquo;re inheriting, remember?) is the same instance as the <code>resource</code> that we&rsquo;re passing in. The <code>resource</code> is the model that corresponds to the policy; in our case, we&rsquo;re in the context of the <code>UserPolicy</code>, so our <code>resource</code> is the <code>user</code> instance.</p>

<p>The last step is actually telling our <code>update</code> action in our <code>UsersController</code> to <em>use</em> the <code>UserPolicy</code> and authorize our <code>user</code> instance. To do this, we&rsquo;ll need to call the <code>authorize</code> method, and pass in our <code>resource</code> that we want to authorize:</p>

<pre><code class="ruby">class UsersController &lt; ApplicationController
    after_action :verify_authorized

    def update
      user = User.find(params[:id])

      authorize user
      user.assign_attributes(user_params)

      if user.save
        render json: user
      else
        render json: {}, status: :unprocessable_entity
      end
    end

    private

    def user_params
      params.require(:user).permit(:name, :email)
    end
end
</code></pre>

<p>In addition to calling <code>authorize</code>, we also need to make sure that our policy is actually being used! In fact, that&rsquo;s what the <code>after_action :verify_authorized</code> line is doing. The documentation suggests adding this to our <code>ApplicationController</code>, but for the sake of clarify, we can put it here temporarily, just to see how everything is working together. Pundit adds a method called <code>verify_authorized</code> to our controllers. It&rsquo;s this method that is reponsible for raising an exception if <code>authorize</code> is not called. It&rsquo;s recommended to put this in an <code>after_action</code> so that we don&rsquo;t forget to authorize any controller actions when we invoke them. Eventually, we&rsquo;ll want to abstract this line to our <code>ApplicationController</code>:</p>

<p><code>after_action :verify_authorized, except: :index</code></p>

<p>Since this is an <code>after_action</code>, we can pass it <code>except</code> or <code>only</code>, if we want to skip authorization for certain controller actions.</p>

<p>So, how is all of this working? Well, when we pass <code>user</code> to the <code>authorize</code> method, we are actually telling <code>pundit</code> to look for a <code>UserPolicy</code>, find the corresponding action, and invoke it. If our <code>user</code> instance is <em>not</em> authorized, <code>pundit</code> will raise a <code>Pundit::NotAuthorizedError</code>. The source code for the <a href="https://github.com/elabs/pundit/blob/145d7592c0028c26e61e8a9569ed3440323eaa40/lib/pundit/policy_finder.rb">policy finder</a> and the <a href="https://github.com/elabs/pundit/blob/8d73705ca6886b757c9d41e13c1cb32a7b97334b/lib/pundit.rb">authorize method</a> reveal exactly how this happens, and are pretty cool to look at under the hood.</p>

<h2>Scopin&#8217; Out More Policies</h2>

<p>The <code>pundit</code> gem is pretty powerful, but the thing that makes it the cool kid of authorization is how it handles scopes. We can use scopes when we want to have a specific subset of records that a user has access to &mdash; basically, when we want to narrow the &ldquo;scope&rdquo; of the resources that are visible to our user, based on their &ldquo;level&rdquo; of authorization (admin, guest, etc.).</p>

<p>Let&rsquo;s write a quick scope for the <code>Review</code> objects of the book reviews in our bookstore. Right now, our <code>ReviewPolicy</code> looks like this:</p>

<pre><code class="ruby">class ReviewPolicy &lt; ApplicationPolicy
    def update?
        resource.user == user
    end
end
</code></pre>

<p>We have a corresponding <code>update</code> action in our <code>ReviewsController</code>, and we&rsquo;re allowing a review to be updated only by the user who wrote it (in other words, the <code>user</code> object that the <code>review</code> belongs to). But we also need an <code>index</code> action, and we want to limit the <code>reviews</code> that can be viewed by a user in the index action. Ultimately, the only <code>user</code> that should be able to see <em>all</em> reviews (including drafts) should be admins; otherwise, the only reviews that should be visible are the ones that have been published.</p>

<p>And that&rsquo;s where scopes come into play. There&rsquo;s a few rules to scopes:</p>

<ol>
<li>They are plain old ruby classes, nested within the policy class.</li>
<li>They have an initialize method that takes a <code>user</code> instance, and a <code>scope</code>. The <code>scope</code> is what we&rsquo;ll perform some kind of database query on &mdash; usually an ActiveRecord class or <code>ActiveRecord::Relation</code>.</li>
<li>The class should have a <code>resolve</code> method, which should return an array of instances that we can iterate over &mdash; again, probably an <code>ActiveRecord::Relation</code>.</li>
</ol>


<p>Let&rsquo;s go ahead and add a scope to our preexisting <code>ReviewPolicy</code>:</p>

<pre><code class="ruby">class ReviewPolicy &lt; ApplicationPolicy
  class Scope
    attr_reader :user, :scope

    def initialize(user, scope)
      @user = user
      @scope = scope
    end

    def resolve
        if user.admin?
            scope.all
        else
            scope.where(published: true)
        end
    end
  end

  def update?
    resource.user == user
  end
end
</code></pre>

<p>The only thing that&rsquo;s actually happening here is that we&rsquo;re limiting the number and types of book <code>reviews</code> that will be rendered by the <code>resolve</code> method. If our <code>user</code> is an admin, we&rsquo;ll run the query <code>Review.all</code>; otherwise, we&rsquo;ll execute the query, <code>Review.where(published: true)</code>.</p>

<p>Again, we could abstract the initialize method of our <code>Scope</code> class into the <code>ApplicationPolicy</code> so that we could inherit <code>class Scope &lt; Scope</code>, rather that actually writing the method directly into this class. In fact, that&rsquo;s probably exactly what we would do once we realized that we needed to write more than a single scope.</p>

<p>The last step is adding our scope to our <code>ReviewsController</code>. We can use a method provided by <code>pundit</code> in our controller called <code>policy_scope</code>, which takes an class instance of a model (in our case, <code>Review</code>):</p>

<pre><code class="ruby">class ReviewsController &lt; BaseController
    after_action :verify_policy_scoped, only: :index
    skip_after_action :verify_authorized, only: :index

    def index
      if user_signed_in?
        reviews = policy_scope(Review)

        render json: reviews
      else
        render json: { reviews: [] }
      end
    end

    def update
        review = Review.find(params[:id])

        authorize review

        # Logic for updating our review
    end
end
</code></pre>

<p>Now, our <code>index</code> action uses the <code>policy_scope</code> method to find the reviews that we&rsquo;ll render. The <code>policy_scope</code> method infers that we want to use the <code>ReviewPolicy::Scope</code> class, and it will instantiate the class and then call resolve on the instance. In fact, the code that&rsquo;s actually getting executed here is this:</p>

<p><code>reviews = ReviewPolicy::Scope.new(current_user, Review).resolve</code></p>

<p>The other important line in our controller is the method that&rsquo;s actually mkaing sure that the policy scope is being used:</p>

<p><code>after_action :verify_policy_scoped, only: :index</code></p>

<p>Similar to <code>verify_authorized</code>, the <code>verify_policy_scoped</code> method is what ensures that the policy scope is actually being used. And in our case, we only have a scope on our <code>index</code> action, so we can specify that we only want to use a scope on <code>:index</code>. Not too bad, right? Just tell <code>pundit</code> what you want to scope, and what you want to authorize, and it will do the rest for us!</p>

<p>But what if we had a class that never needed to be authorized or scoped? How could we tell <code>pundit</code> to just skip the authorization for that specific model? Well, it&rsquo;s pretty easy &mdash; we can just use <code>skip_after_action</code>:</p>

<pre><code class="ruby">class CommentsController &lt; ApplicationController
    skip_after_action :verify_authorized
    skip_after_action :verify_policy_scoped

    # RESTful controller actions go here!
end
</code></pre>

<p>Simple! This gem is pretty fantastic to work with, and gives us great guidelines on the proper way of using it. I really liked this particular piece of advice from the library&rsquo;s developers:</p>

<blockquote><p>&ldquo;Pundit strongly encourages you to model your application in such a way that the only context you need for authorization is a user object and a domain model that you want to check authorization for. If you find yourself needing more context than that, consider whether you are authorizing the right domain model, maybe another domain model (or a wrapper around multiple domain models) can provide the context you need.&rdquo;</p></blockquote>

<p>It turns out that authorizing with <code>pundit</code> can be a really good time. You might say that it&rsquo;s even kind of&hellip;fun!</p>

<iframe src="//giphy.com/embed/btKQIhrebJ3Og" width="480" height="200" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>pundit</code> gem is a simple way to build a powerful authorization system. It expects plain old ruby policy classes for each model that you want to authorize, and each class should contain query methods that map to controller actions for the model. The controller that corresponds to the model should call the <code>authorize</code> method for the object, and should either contain or inherit an <code>after_action :verify_authorized</code> method.</li>
<li>The developers at eLabs put a lot of work into building <code>pundit</code>, and based it off of the <code>cancan</code> library. In fact, they even wrote a super blog post about their process, which you can read <a href="http://www.elabs.se/blog/52-simple-authorization-in-ruby-on-rails-apps">over here</a>.</li>
<li>Still confused about when to authorize and when to authenticate? Check out this <a href="http://www.slideshare.net/BruceWhite3/pundit-37048056">awesome slidedeck</a> that clarifies all your authorization confusion!</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Working Hard or Hardly Working, Part 2: Custom Jobs]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/09/22/working-hard-or-hardly-working-part-2-custom-jobs/"/>
    <updated>2015-09-22T08:59:45-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/09/22/working-hard-or-hardly-working-part-2-custom-jobs</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/XgE4LlECZjw6k" width="480" height="218" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>With the advent of Rails 4.2, one thing is definitely for sure: there is now one background job to rule them all: Active Job. Last week, I learned about Active Job&rsquo;s <a href="http://vaidehijoshi.github.io/blog/2015/09/15/working-hard-or-hardly-working-part-1-active-job/">easy integration</a> with ActionMailer. But, as nice as it is to have those simple <code>deliver_now</code> and <code>deliver_later</code> methods, there will inevitably be a time that we want to do something more &mdash; something that requires writing our own custom job.</p>

<p>Active Job is, thankfully, very good at letting us do this. Since my ActionMailer post last week, I&rsquo;ve written a few jobs using Active Job&rsquo;s framework. And each time that I&rsquo;ve done it, it&rsquo;s gotten easier and easier. Of course, not all of my jobs have been super complex, but once I understood the basics, I could look at other people&rsquo;s code and understand how it was structure and what exactly was going on.</p>

<p>The only way to get comfortable writing my own custom jobs was by &ndash; wait for it &ndash; actually <em>writing</em> one! So that&rsquo;s exactly what we&rsquo;ll do together. Let&rsquo;s turn our ActionMailer method from last week into its own job that will be able to run asychronously. Hold on to your hats, because we&rsquo;re about to leave the shire.</p>

<!--more-->


<h2>Job Generating</h2>

<iframe src="//giphy.com/embed/qxWJDbOnrNOAU" width="480" height="264" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>The most important first step before even generating a job is to make sure that we have our queue adapter set up for Active Job. The default queue adapter for Active Job is to run inline (or, within the <em>same</em> request-response cycle), which means that it will not run in the background. One of the lovely things about Active Job is that we can use any queueing backend that we prefer, as long as we follow the documentation to set it up. Last week, we did this by adding <code>delayed_job</code> to our <code>Gemfile</code>, and setting our queueing configurations inside of <code>config/application.rb</code>:</p>

<p><code>config.active_job.queue_adapter = :delayed_job</code></p>

<p>The <code>delayed_job</code> backend also requires us to run a migration, which adds <code>Delayed::Job</code> objects to our database:</p>

<pre><code class="ruby">♥ rails generate delayed_job:active_record
♥ rake db:migrate
</code></pre>

<p>This will be important later on, because the only way for us to see any jobs that are enqueued or that have failed is by calling <code>Delayed::Job.all</code> in the console or from within the context of a controller. This migration also adds helpful columns to our <code>delayed_jobs</code> table, including <code>priority</code>, <code>attempts</code>, <code>run_at</code>, <code>failed_at</code>, and <code>last_error</code>. This data would be particularly relevant if we wanted to allow a job to be re-run, or for a job&rsquo;s errors to be displayed within an admin panel.</p>

<p>Now that we have all of our queueing backend setup taken care of, we can start to <em>write</em> our job. At the moment, we have an instance method called <code>send_confirmation_email</code> on our <code>Order</code> class, which uses <code>deliver_now</code> to send an email. You&rsquo;ll remember that we&rsquo;re calling this method from within a state machine:</p>

<pre><code class="ruby">class Order &lt; ActiveRecord::Base
    include AASM

    aasm column: 'state', whiny_transitions: false do
        # state machine truncated for brevity!
        state :complete

        event :completed, after: :send_confirmation_email
    end


    def send_confirmation_email
        OrderMailer.confirmation_email(self).deliver_now
    end
end
</code></pre>

<p>We still want to use our <code>OrderMailer</code>, but it would be nice to be able to do that within the context of a background job that exists in its own file, so that we can customize it. Let&rsquo;s generate our job and text unit for our order confirmation emailer, with a nice namespace to boot:</p>

<pre><code class="ruby">♥ bin/rails generate job order/confirmation_emailer
</code></pre>

<p>Now, inside of <code>app/jobs/order/confirmation_emailer.rb</code>, we have a simple little file that looks like this:</p>

<pre><code class="ruby">module Order
    class ConfirmationEmailerJob &lt; ActiveJob::Base
        queue_as :default

        def perform()
            # Do something later
        end
    end
end
</code></pre>

<p>It doesn&rsquo;t look like much, does it? But, it&rsquo;s honestly almost all that we need. The most important thing to know about ActiveJob when it comes to writing a job is this: you must have a <code>perform</code> method. And, as you might expect, the <code>perform</code> method should be, well, responsible for actually <em>performing</em> the job. However, our job doesn&rsquo;t do anything yet. And we&rsquo;re not even calling it anywhere! You know what that means, right? It&rsquo;s time for us to set off on our custom job adventure and start writing!</p>

<h2>Job Writing</h2>

<iframe src="//giphy.com/embed/g7SFZQGzS4HwQ" width="480" height="235" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Since we already know that our <code>perform</code> method is going to be responsible for performing our job, we know that this is where all of our logic should go. It would be nice if we could just pass this background job an <code>order</code> instance, and then tell it what to do with that order. Our <code>OrderMailer</code> has a <code>confirmation_email</code> method that accepts an <code>order</code> object, so we can really just use the mailer inside of our job.</p>

<p>Let&rsquo;s pass an <code>order</code> to our job, and then have the job be responsible for delivering the confirmation email:</p>

<pre><code class="ruby">module Order
    class ConfirmationEmailerJob &lt; ActiveJob::Base
        def perform(order)
          OrderMailer.confirmation_email(order).deliver
        end
    end
end
</code></pre>

<p>Nice! That was easy enough, right? You&rsquo;ll notice that our <code>ConfirmationEmailerJob</code> inherits from <code>ActiveJob::Base</code>. This is very important, because without inherting from this module, our job would have no idea what to do with its <code>perform</code> method! It&rsquo;s crucial to keep this in mind particularly if we are manually creating our jobs and not using the rails generator; in that case, we need to add the <code>ActiveJob::Base</code> inheritance on our own. (I was bit by this recently, so don&rsquo;t make the same mistake that I did!)</p>

<p>Honestly though, this isn&rsquo;t doing that much more than what our <code>OrderMailer</code> did initially. We&rsquo;re writing a <em>custom</em> job, so let&rsquo;s customize what this job can do. In addition to delivering our confirmation email, it would be cool if this job could also update an attribute on our <code>order</code> called <code>confirmation_sent_at</code>. This is just a datetime format attribute that will probably end up in an admin panel or dashboard. And there&rsquo;s a really elegant way that we can update this attribute from within the job:</p>

<pre><code class="ruby">module Order
    class ConfirmationEmailerJob &lt; ActiveJob::Base
        def perform(order)
          OrderMailer.confirmation_email(order).deliver

          order.touch(:confirmation_sent_at)
        end
    end
end
</code></pre>

<p>The <code>touch</code> method is part of ActiveRecord, and allows us to save an ActiveRecord object with the <code>updated_at</code> and <code>updated_on</code> attributes set to the current date and time. It&rsquo;s important to note that there are no validations that are performed by this method, and it&rsquo;s actually only the <code>after_touch</code>, <code>after_commit</code>, and <code>after_rollback</code> ActiveRecord callbacks that are ever executed.</p>

<p>If we called <code>order.touch</code>, we would only update <code>order.updated_at</code>. But, since we have a specific attribute called <code>confirmation_sent_at</code> in order to specifically keep track of our confirmation emails, we can tell the <code>touch</code> method to update that attribute by passing it in as an parameter: <code>order.touch(:confirmation_sent_at)</code>. This is a pretty awesome method, but don&rsquo;t make the mistake of trying to call it on a plain old Ruby object, or on an unsaved ActiveRecord object! The object <em>must</em> be persisted, since the <code>touch</code> method is defined in the <code>ActiveRecord::Persistence</code> module. Otherwise, you&rsquo;ll get an ActiveRecordError, and we don&rsquo;t have time for that silliness!</p>

<p>However, what we <em>do</em> need to do next is call our background job and have it&hellip;well, do it&rsquo;s job!</p>

<h2>Job Winning</h2>

<p>Now that we have our <code>Order::ConfirmationEmailerJob</code> class ready to get to work, it&rsquo;s time for us to actually get to work and start performing. Since we already have our state machine in place, let&rsquo;s just call our job from within our <code>Order</code> class:</p>

<pre><code class="ruby">class Order &lt; ActiveRecord::Base
    include AASM

    aasm column: 'state', whiny_transitions: false do
        state :complete

        event :completed, after do
            Order::ConfirmationEmailerJob.perform_later(self)
        end
    end
end
</code></pre>

<p>Nice! The <code>perform_later</code> method on our <code>Order::ConfirmationEmailerJob</code> will instantiate our job and call <code>perform</code> on it. Since we&rsquo;re already in the context of the <code>Order</code> model, we can simply pass in <code>self</code>, which is just the <code>order</code> instance, into our job, which will know exactly what to do with it. We&rsquo;re also taking advantage of the <code>after</code> callback in our state machine, and invoking our job directly inside of our <code>completed</code> event. Alternatively, we could have abstracted this out into a method for a more granular separation of concerns. But since our job is pretty simple, it also makes sense to put it directly into the <code>after</code> block.</p>

<p>Now, when we call <code>order.completed!</code>, our state machine will transition our <code>order</code> object to the state <code>'complete'</code>, and after the event, it will create a new instance of our <code>Order::ConfirmationEmailerJob</code>, which will call the <code>perform</code> method asychronously, and will use <code>delayed_job</code> to enqueue the job in the background. The emailer job would then send our order confirmation email using ActionMailer, and then it would update the <code>confirmation_sent_at</code> attribute on our <code>order</code> instance. And, if we wanted to see what the job looked like while it was being running asychronously, we could open up the rails console and run <code>Delayed::Job.last</code>, which would show us all the details about the most recent job that we had called.</p>

<p>Wow, that&rsquo;s a <em>lot</em> of things happening in a pretty complex sequence! That tiny little <code>perform</code> method isn&rsquo;t looking so tiny after all, is it?</p>

<p>Interestingly, the job that we wrote is still a lot simpler than how Rails jobs used to be written. Before Active Job was integrated into Rails 4.2, we weren&rsquo;t able to pass in an <code>order</code> instance into the <code>perform</code> method of our job. Instead, we had to pass in the <code>id</code> of an object, and then look it up inside of our job:</p>

<pre><code class="ruby">module Order
    class ConfirmationEmailerJob &lt; ActiveJob::Base
        attr_reader :order_id

        def initialize(order_id:)
            @order_id = order_id
        end

        def perform
          OrderMailer.confirmation_email(order).deliver

          order.touch(:confirmation_sent_at)
        end

        private
        def order
            Order.find(order_id)
        end
    end
end
</code></pre>

<p>Not as nice as clean as what we wrote initially, right? But still, despite all the extra lines of code, it&rsquo;s pretty amazing that all of these actions can be performed asynchronously, and within different request-response cycles. Rails&#8217; ActiveJob truly does rule all.</p>

<iframe src="//giphy.com/embed/zGnnFpOB1OjMQ" width="480" height="215" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The most important part about setting up a job through ActiveJob is inheriting from <code>ActiveJob::Base</code>, and implementing a <code>perform</code> method. Now, we can actually pass in instances of objects to the <code>perform</code> method, rather than ids, which is all thanks to <a href="http://dev.mikamai.com/post/96343027199/rails-42-new-gems-active-job-and-global-id">global ids</a>.</li>
<li>Curious how the <code>touch</code> method works? Check out <a href="http://apidock.com/rails/ActiveRecord/Persistence/touch">the documentation</a> on this amazing little function.</li>
<li>Here&rsquo;s a <a href="http://railscasts.com/episodes/171-delayed-job?autoplay=true">great railscast</a> on setting up a job &ndash; keep in mind though, it&rsquo;s pre-Rails 4.2 and ActiveJob!</li>
</ul>

]]></content>
  </entry>
  
</feed>
