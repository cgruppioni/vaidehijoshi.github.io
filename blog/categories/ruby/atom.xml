<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-06-22T18:57:33-04:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[To Serialize or Not to Serialize: ActiveModel Serializers]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/06/23/to-serialize-or-not-to-serialize-activemodel-serializers/"/>
    <updated>2015-06-23T08:10:05-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/06/23/to-serialize-or-not-to-serialize-activemodel-serializers</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/WgTf8fPTjJZAI" width="480" height="270" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Lesson number one when it comes to developing for the web: everything is just data. When you send something to the server in a request, or when you get something back from the server as a response, all you&rsquo;re really dealing with is data. Simple enough to remember, right? Wrong. Because data can be complicated. Especially when you consider the fact that it has to be passed back and forth in very specific ways. And if you don&rsquo;t format your data correctly, your computer is going to be very, very mad at you (or probably just throw a really unhelpful error message).</p>

<p>I encountered the complications of data formatting the hard way, while trying to pass data between two parts of my application. I wanted to send some data to update a Ruby object in my Postgres database on the server-side, and then I wanted the Rails side to send back an updated response. As if that wasn&rsquo;t enough, I then needed the Ember front end to grab the updated data and immediately render it to the user on the client-side. Data formatting can already be complex when you have only one framework or language; throw in another framework and language, and, well&hellip;you might feel like you&rsquo;re having a little bit of a meltdown.</p>

<p>But fear not! Because here&rsquo;s one awesome thing about data: once you understand the way that it&rsquo;s structured, it&rsquo;s pretty simple to use. And when it comes to working on a more intricate Rails + JavaScript application (like the one I was building recently), there&rsquo;s one kind of data manipulation you&rsquo;re probably going to have to do at some point or another: data serialization. When working with a JavaScript front end, you&rsquo;ll probably have to serialize your data into a <strong>JSON format</strong>, which is short for <em>JavaScript Object Notation</em>. Thankfully, there&rsquo;s a handy gem that makes this so easy that you&rsquo;ll never again question whether or not to serialize your data.</p>

<!--more-->


<h2>Why Serialize?</h2>

<p>The time has finally come: it&rsquo;s time for us to spiff up our Bookstore application with some JavaScript. (I know, I know, it sounds horrible &ndash; but it&rsquo;ll be so good for our users, I promise). But let&rsquo;s start off simple and keep working with the Rails API we&rsquo;ve been building out.</p>

<p>Let&rsquo;s pretend for a second that we&rsquo;ve already implemented authentication in our application, which means we have access to the <code>current_user</code> who is logged in at the highest controller level of our application: the <code>ApplicationController</code>. In our <code>UsersController</code>, we want an <code>index</code> action that will be invoked when the <code>current_user</code> logs into their account page. On that page, we&rsquo;ll want to show the user&rsquo;s &ldquo;wish lists&rdquo;, or the list of books that they want to read. Each <code>WishList</code> object belongs to a <code>User</code> and has many <code>Books</code>, and a <code>Book</code> can belong to a <code>WishList</code>. Right now in our controller, we are rendering all the <code>WishLists</code> that are associated with the <code>current_user</code> as JSON:</p>

<pre><code class="ruby">class UsersController &lt; ApplicationController
  def index
    @wish_lists = current_user.wish_lists

    render json: @wish_lists
  end
end
</code></pre>

<p>Cool, we have our <code>WishLists</code> already rendered as JSON. Why serialize anything in that case? I&rsquo;m sure our JSON is structured perfectly well, and that we can convert our Ruby object data into Ember models seamlessly!</p>

<pre><code class="json">[
   {
      "id":43,
      "user":
        {
            "id": 1,
            "username": "Vaidehi"
        },
      "name":"Favorite Shakespeare Plays To Re-Read",
      "created_at":"2015-06-23T21:07:30.108Z",
      "updated_at":"2015-06-23T21:07:30.108Z",
      "books": 
        [
            {
                "id": 24,
                "title": "A Midsummer Night's Dream",
                "author": "William Shakespeare"
            },
            {
                "id": 48,
                "title": "The Tempest",
                "author": "William Shakespeare"
            },
            {
                "id": 13,
                "title": "Much Ado About Nothing",
                "author": "William Shakespeare"
            }
        ]
   }
]
</code></pre>

<p>Oh my. That is <em>definitely</em> not how we want our JSON to look!</p>

<iframe src="//giphy.com/embed/12mPcp41D9a1i0" width="480" height="274" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>For one thing, if we give this JSON to Ember, it won&rsquo;t know how to turn it into an Ember model. But there are also some other issues with exactly how this data is structured.</p>

<p>For now, we don&rsquo;t need to render anything to our user about when the created or updated their list, so that&rsquo;s some superfluous data that we shouldn&rsquo;t be requesting from the server.</p>

<p>We also don&rsquo;t want to render anything about our actual <code>User</code> object &ndash; we probably just want to include the <code>user_id</code>, and nothing else. And because we can load the correct <code>Book</code> models via Ember itself, let&rsquo;s not bother with requesting all the details of every <code>Book</code> in our <code>WishList</code>. Instead, let&rsquo;s just get an array of associated <code>book_ids</code>, and then have Ember render the appropriate ones for us from its data store.</p>

<p>So, to serialize or not to serialize? That is the question. And I think you and I both know the answer.</p>

<h2>ActiveModel Serializers</h2>

<p>Before we can get our serializing on, we&rsquo;ll need to add our new favorite gem to our <code>Gemfile</code>:</p>

<pre><code class="ruby">gem 'active_model_serializers'
</code></pre>

<p>and then run the <code>bundle</code> command.</p>

<p>Now, we&rsquo;ll want to actually create our serializer, which will work with Rails&#8217; ActiveModel functionality to serialize your persisted Ruby objects into the exact JSON format that we&rsquo;ll specify. Luckily, we can just generate our serializer instead of creating those files:</p>

<pre><code class="ruby">rails g serializer wishList
</code></pre>

<p>This will create a <code>serializers</code> directory inside of our top-level <code>/app</code> directory since this is the first serializer we&rsquo;ve generated. And it&rsquo;ll add both an empty <code>application_serializer</code> and a <code>wish_list_serializer.rb</code> file inside of that new directory, which looks like this:</p>

<pre><code class="ruby">class WishListSerializer &lt; ApplicationSerializer
  attributes :id, :name

  has_many :books
  belongs_to :user
end
</code></pre>

<p>The attributes that we&rsquo;ve listed (<code>id</code> and <code>name</code>) are the ones that are <em>whitelisted</em> to be serialized. This basically means that these are the attributes we are allowing the <code>active_model_serializers</code> gem to serialize and make into JSON. The serializer we generated through Rails also recognized the associations that we set up; it created the <code>has_many</code> and <code>belongs_to</code> relationships that we setup inside of our <code>Book</code>, <code>User</code>, and <code>WishList</code> Rails models.</p>

<p>Cool, but how can we check what our data structure looks like? Well, we can start our server (<code>rails server</code>) and then head over to where our index route lives (<code>http://localhost:3000/wish_list</code>). Our JSON response will be rendered through our <code>index</code> action in our <code>WishListsController</code>:</p>

<pre><code class="json">{
    "wish_lists":
        [
            {
                "id":43,
                "name":"Favorite Shakespeare Plays To Re-Read",
                "user":
                    {
                        "id": 1,
                        "username": "Vaidehi"
                    },
                "books":
                    [
                        {
                            "id": 24,
                            "title": "A Midsummer Night's Dream",
                            "author": "William Shakespeare"
                        },
                        {
                            "id": 48,
                            "title": "The Tempest",
                            "author": "William Shakespeare"
                        },
                        {
                            "id": 13,
                            "title": "Much Ado About Nothing",
                            "author": "William Shakespeare"
                        }
                    ]
            }
        ]
}
</code></pre>

<p>Well, our data looks a <em>little</em> bit better. For one thing, our whitelisted attributes and associations have been put under a <code>wish_lists</code> key, which will have an array of <code>WishList</code> objects for the <code>current_user</code>, just as we wrote out in our <code>WishListsController</code>.</p>

<p>Although it&rsquo;s great that this gem generated all this for us, and for free, we already know that we&rsquo;re going to have to tweak this a bit. First, let&rsquo;s get rid of that <code>belongs_to :user</code> line, and instead just render a <code>user_id</code> attribute:</p>

<pre><code class="ruby">class WishListSerializer &lt; ApplicationSerializer
  attributes :id, :name, :user_id

  has_many :books
end
</code></pre>

<p>Because we&rsquo;ve set up the associations in both models, the <code>active_model_serializer</code> will look directly for an <code>id</code> attribute on a <code>User</code> association, and add that as a key in our JSON object, rather than creating a <code>user</code> key that points to an entire JSON <code>User</code> object. What does our JSON object look like now?</p>

<pre><code class="json">{
    "wish_lists":
        [
            {
                "id":43,
                "name":"Favorite Shakespeare Plays To Re-Read",
                "user_id":1,
                "books":
                    [
                        {
                            "id": 24,
                            "title": "A Midsummer Night's Dream",
                            "author": "William Shakespeare"
                        },
                        {
                            "id": 48,
                            "title": "The Tempest",
                            "author": "William Shakespeare"
                        },
                        {
                            "id": 13,
                            "title": "Much Ado About Nothing",
                            "author": "William Shakespeare"
                        }
                    ]
            }
        ]
}
</code></pre>

<p>Okay, another step in the right direction. But, what about those annoying <code>Book</code> objects &ndash; how do we turn those objects into just an array of <code>book_ids</code>?</p>

<p>The answer is&hellip;through another serializer, of course! And also some snazzy customization.</p>

<h2>Customizing Your Serializer</h2>

<p>Before we can go about spicing up the JSON response generated by our <code>WishList Serializer</code>, we are going to have to generate a new serializer for our <code>Book</code> objects. Thank goodness we already know how to do all that:</p>

<pre><code class="ruby">rails g serializer book
</code></pre>

<p>which will generate a <code>book_serializer.rb</code> file like this:</p>

<pre><code class="ruby">class BookSerializer &lt; ApplicationSerializer
  attributes :id, :title, :author

  belongs_to :wish_list
end
</code></pre>

<p>Step one, successfully accomplished! Now, time to bedazzle our serializer. Let&rsquo;s say that the front end of our application doesn&rsquo;t need all that information &ndash; instead, it needs just an array of <code>book_ids</code>. We can just edit our serializer so that we&rsquo;re only using the information that we want to use:</p>

<pre><code class="ruby">class BookSerializer &lt; ApplicationSerializer
  attributes :id
end
</code></pre>

<p>Now comes step two: telling our <code>WishList Serializer</code> to refer to our <code>BookSerializer</code>, and use <em>that</em> to serialize each book associated with a wish list. If only there was an easy way to do that&hellip;</p>

<pre><code class="ruby">class WishListSerializer &lt; ApplicationSerializer
    attributes :id, :name, :user_id, :books

    private
    def books
        BookSerializer.new(object.books).attributes
    end
end
</code></pre>

<p>Oh, interesting! We&rsquo;ve just created our <em>very own</em> attribute on the <code>WishListSerializer</code>. And what does that method (which is private, because we don&rsquo;t wany any other part of our application to call it) do, exactly? Well, it creates a new instance of our <code>BookSerializer</code>, and runs that serializer for each <code>Book</code> object, returning the attributes that we told it to serializer.</p>

<p>What&rsquo;s really awesome about this is that if we suddenly decide that we now want not just an array of <code>ids</code>, but also the <code>title</code> of each <code>Book</code> object, we can just add that attribute into our <code>BookSerializer</code> by modifying the line to <code>attributes :id, :title</code>, and <em>tada</em>! We have an array of <code>Book</code> objects that have both an <code>id</code> <em>and</em> a <code>title</code>. So easy, right?!</p>

<p>The super cool thing about implementing serializers is that our <code>UsersController</code> hasn&rsquo;t changed at all in this process:</p>

<pre><code class="ruby">class UsersController &lt; ApplicationController
  def index
    @wish_lists = current_user.wish_lists

    render json: @wish_lists
  end
end
</code></pre>

<p>All that&rsquo;s happening now is that Rails is looking for a serializer for our <code>WishList</code> objects on the <code>current_user</code>, and if it finds one (which it will, since we made it!), it uses that to serialize the appropriate data and render it into a JSON format.</p>

<p>Serializers are pretty fantastic because they&rsquo;re easy to generate, customize, and use. In fact, we could even create multiple serializer for the same <em>type</em> of object. We could have a <code>BookDetails Serializer</code>, which might return a ton of information about a book, rather than just its <code>id</code> and <code>title</code>. All we&rsquo;d have to do to use it is specify the serializer within our controller action:</p>

<pre><code class="ruby">render json: @books, each_serializer: BookDetailsSerializer
</code></pre>

<p>Pretty amazing stuff, right? This will make integrating our JavaScript front end with our Rails API so much easier. We can serialize all of the things! And then we should probably teach this doggy how to serialize things, too. He&rsquo;s probably confused because he hasn&rsquo;t read this blog post yet:</p>

<iframe src="//giphy.com/embed/xDQ3Oql1BN54c" width="480" height="332" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>active_model_serializers</code> gem provides a ton of functionality for structuring a JSON response from your Rails API. Read about all the methods it provides in its <a href="https://github.com/rails-api/active_model_serializers">great documenation</a>.</li>
<li>Still curious about serializers? Check out <a href="https://robots.thoughtbot.com/better-serialization-less-as-json">this cool post</a> and <a href="https://blog.engineyard.com/2015/active-model-serializers">this one</a>, too!</li>
<li>Serializers are also great for caching. To learn more about why they matter, read this <a href="https://robots.thoughtbot.com/fast-json-apis-in-rails-with-key-based-caches-and">more advanced</a> blog post!</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Baby's First Conference: Recapping RedDotRubyConf]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/06/16/babys-first-conference-recapping-reddotrubyconf/"/>
    <updated>2015-06-16T08:29:28-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/06/16/babys-first-conference-recapping-reddotrubyconf</id>
    <content type="html"><![CDATA[<iframe src="https://www.flickr.com/photos/reddotrubyconf/18777106586/in/photostream/player/" width="500" height="333" frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>A week ago, I was on a code overload in Singapore. What was I doing on the other side of the world? Why, giving (and attending!) my very first talk at a Ruby conference, of course!</p>

<p>I was lucky enough to join some serious Ruby powerhouses at the <a href="reddotrubyconf.com">Red Dot Ruby Conference</a> earlier this month. And it was such a cool first conference experience. But, because I had to give a talk, I was pretty preoccupied with writing my speech and creating some fun slides to accompany it. What I forgot in the process was that I would be an audience member at the conference, too! (Pretty silly, I know).</p>

<p>My lightning talk was <a href="http://confreaks.tv/videos/rdrc2015-lightning-talk-refactoring-of-self">just a few minutes</a>, which meant that for the majority of the two-day conference, I had the unique opportunity to listen to some really fantastic talks. And I learned <em>so much</em>. I also got to meet some interesting, talented, and creative people who have made some very significant and core contributions to the Ruby and Rails communities and codebases. Summing up everything that happened in those two days is a bit difficult since every talk was informative in many ways. But I&rsquo;ll recap at least some of the dopest things I learned about while I was there. But if you want the full effect, you should probably <a href="http://i.ytimg.com/vi/_kRtkrBumBw/maxresdefault.jpg">eat a durian</a> while reading this post &ndash; just sayin&#8217;.</p>

<!--more-->


<h2>Your Code Is Not Just Yours</h2>

<p>One of the first talks of the conference focused on something I pretty much knew nothing about: security. André Arko&rsquo;s talk, <em>Security Is Hard, But We Can&rsquo;t Go Shopping</em> was an eye-opening look at why Ruby developers don&rsquo;t think (or talk) about security vulnerabilities in their codebases &ndash; and why we all <em>should</em> be having that conversation.</p>

<p>André&rsquo;s talk definitely caught my attention when he gave an example of a company that went out of business in a day because they lost <em>all</em> of their data because their severs were hacked. Yes, you read that right: lost all their data, shut down in a day. Pretty terrifying, right?</p>

<div style="text-align:center">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/eHmXar6TNUo?showinfo=0" frameborder="0" allowfullscreen></iframe><br>
</div>


<p>There were three big takeaways for me from this talk:</p>

<h4><strong>1. Updating is insurance</strong></h4>

<p>We&rsquo;ve all looked at our code and seen deprecation warnings, or things that are out of date and need to be updated to the latest version. And, we&rsquo;ve all, at some point, ignored those warnings. It&rsquo;s really easy to think about shipping your code quickly and iterating fast, particularly because updating things is <em>not</em> fun. And no one wants to do it.</p>

<p>But, you know what&rsquo;s worse? Your entire app blowing up because you had a vulnerability exposed in your code because you didn&rsquo;t update! If we all started thinking about updating as <em>insurance</em>, we&rsquo;d be more willing to sit down and put in the time to make sure all aspects of our applications were updated and thus, at the lowest possible level of security risk. This shift in perspective also seems like the best way to pitch &ldquo;updating&rdquo; as a task to project managers who might not see the time value in something like upgrading an already-functioning application.</p>

<h4>2. <strong>Responsible disclosure</strong></h4>

<p>If you find a security vulnerability, be nice about it. Don&rsquo;t be a jerk, man. Sometimes, you can even get a reward for disclosing! Figure out what the process is for disclosing a security issue to a company, and be empathetic to the developers who wrote that code which you&rsquo;re using &ndash; who knows, maybe one day there&rsquo;ll be a vulnerability in your code, and you&rsquo;ll wish you had been nicer to <em>those</em> developers.</p>

<h4>3. <strong>There are users, there are abusers</strong></h4>

<p>As a young developer, you can think about who is using your code. Many junior developers write code to get it to work or to make it fast, but it&rsquo;s also important to think about who is or could potentially be using your code. It&rsquo;s helpful to start thinking about those things, even as a new programmer. Consider things like strong params and <code>csrf</code> tokens to start, and then work your way up to more complex security measures in your Rails applications. At the end of the day, you probably have some gaping holes in your codebase that is allowing someone to be malicious to your code base, which means that <em>your</em> code isn&rsquo;t actually yours anymore.</p>

<h2>All About That Efficiency</h2>

<p>My favorite talk of the entire conference came from Sam Saffron, the co-founder of Discourse and one of the first employees at StackExchange. To be honest, this talk was less an exercise is learning new things and more a revelation in all the things that I <em>didn&rsquo;t</em> know. And all the things that I knew nothing about centered around one thing: <strong>efficiency</strong>.</p>

<div style="text-align:center">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/aP5NNkzb4og?showinfo=0" frameborder="0" allowfullscreen></iframe><br>
</div>


<p>Sam&rsquo;s talk piqued my interested in particular because I&rsquo;ve been trying to think about the efficiency of my own applications for a few weeks now. I&rsquo;ve been trying to use more efficient methods in my own code &ndash; like <code>pluck</code> in last week&rsquo;s post, for example, or my post on the ActiveRecord <code>includes</code> <a href="http://vaidehijoshi.github.io/blog/2015/04/07/querying-at-warp-drive-using-activerecord-includes/">method</a> a few months ago.</p>

<p>Yet there&rsquo;s a lot more to efficiency than that, it turns out! And that&rsquo;s exactly what Sam&rsquo;s talk aimed to explore. One of the things I learned pretty early on was that ActiveRecord is inefficient &ndash; yes, really! For those of us writing smaller applications, it may not be all that obvious. But for something much larger, such as Discourse, which has tons and tons of assets that have to compile on page load&hellip;well, it&rsquo;s pretty obvious how even just <em>one</em> n+1 query could throw the whole thing to hell in a handbasket!</p>

<p>What I loved the most about Sam&rsquo;s talk was the live demo. He actually ran his server in showed us the different technologies he used to track things like server calls, method invocations, and raw SQL queries. He didn&rsquo;t just tell us what he used &ndash; he showed us what they looked like in development! And here&rsquo;s the icing on the cake: everything is open source. Which means that we can all use the same technologies and fork them and add/modify them for our own projects!</p>

<p>Here are a few of the gems that Sam uses and recommends, which I&rsquo;ve looked into. Lookout for some upcoming #TechnicalTuesdays posts on these soon:</p>

<h4>1. <code>lru_redux</code></h4>

<p>This gem allows for efficient caching by using ordered arrays. It provides you with some pretty fantastic methods to write, read, and clear your cache. The most important thing here is that arrays are quick and efficient when it comes to looking up an item by index, which makes it ideal for something like storing a cache. Check out more on the <code>lru_redux</code> <a href="https://github.com/SamSaffron/lru_redux">Github page</a>.</p>

<h4>2. <code>dapper</code></h4>

<p>The <code>dapper</code> gem is a lightweight Object Relational Mapper that was created by developers at StackExchange who wanted to solve an n+1 problem. What&rsquo;s pretty cool about this gem is that it allows you to execute raw SQL queries and map your results. A major benefit of this is that you no longer have to rely on the Object-Relational Mapper that comes for free with Rails: ActiveRecord. We&rsquo;ve all encountered ActiveRecord&rsquo;s flaws &ndash; particularly when it comes to calls to the server and queries to the database &ndash; and thanks to this gem, you don&rsquo;t have to deal with those things again. Instead, you can just write your own queries to execute! Find out more over on their <a href="https://github.com/StackExchange/dapper-dot-net">ReadMe</a>.</p>

<h4>3. <code>fast_pluck</code></h4>

<p>I&rsquo;m really curious about how this &ldquo;freedom patch&rdquo; actually works, and I need to take the time to sit down and read through it with a good cup of coffee. But, I really like the idea of speeding up ActiveRecord&rsquo;s <code>pluck</code> method, which I am already pretty comfortable with. Check it out over on <a href="https://gist.github.com/SamSaffron/bd593751668e5e5c4afc">this Gist</a>.</p>

<h4>4. <code>memory_profiler</code></h4>

<p>The <code>memory_profiler</code> gem measures how many objects you&rsquo;re allocating to memory on boot of your application, and how many are being retained (how much memory they&rsquo;re taking up) in your app. I haven&rsquo;t explored this gem too much, but I hope to play with it more in the future. You can play with it <a href="
https://github.com/SamSaffron/memory_profiler">over here</a>.</p>

<h2>Language Design Is Hard</h2>

<p>This realization is probably neither prophetic nor profound, but it&rsquo;s still worth repeating nonetheless: languages are hard. They&rsquo;re hard to read, learn, and, most of all, <em>write</em>.</p>

<p>Matz&rsquo;s <a href="https://www.youtube.com/watch?v=bqWBB8-iEac">keynote presentation</a> on the new and upcoming features in the next Ruby release was the first time I started thinking about how difficult it must be to actually create the language that we use everyday, and love so dearly. After his presentation, I asked him how he goes about actually designing new features, long before they are implemented. His answer, in short, was incredibly empathetic: he said that he thinks about what it&rsquo;s like to actually use the Ruby language with the feature he has in mind, and he considers the user experience before handing off a feature for someone to actually implement and include in the next release.</p>

<p>I thought about the difficult problem of language design yet again during Paolo Perrotta&rsquo;s awesome talk about refinements. If you&rsquo;re not familiar with the concept (I wasn&rsquo;t before this talk!), the short version is that <strong>refinements</strong> showed up in Ruby 2, and were used to make &ldquo;local&rdquo; monkeypatches, which are a much safer and preferable alternative to global monkeypatching. An interesting issue with refinements is that they rely on dynamic scoping, which means that you can close and reopen the scope of a class and redefine things in different ways.</p>

<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/_27-4-dbnA8?rel=0&amp;showinfo=0" frameborder="0" allowfullscreen></iframe><br>
</div>


<p>In a way, it was great that Paolo&rsquo;s talk was towards the end of the conference, because it tied up things together nicely. I learned that a simple thing like Ruby refinements &ndash; which boils down to two keywords, <code>refine</code> and <code>using</code> &ndash; were a perfect example of the first two things I learned during the conference: security and efficiency!</p>

<p>The issue with refinements is that you can&rsquo;t always tell what&rsquo;s going in your code, or what exactly your code will execute. And that&rsquo;s pretty scary! You know what else it is? A security threat and a huge vulnerability. Refinements  also slow your code down, because the Ruby interpreter has to go through all of your code and check if a refinement is being used or not. Not exactly the most optimized way of doing things, amirite?</p>

<p>All of this got me thinking about the people who write the languages that we use. They have to have a deep understanding of the language architecture and syntax, and think about how a developer might use (or <em>abuse</em>) a language feature. All of this is to say: language design is hard. And maybe we should all be a bit more grateful for the people who think about these complex problems on a daily basis.</p>

<p>Compared to things like security, optimization, and language design, a smelly durian doesn&rsquo;t seem nearly as bad. In fact, I&rsquo;d say that as far as developers go, we as a Ruby community have got it pretty good. But probably not as good as this dog right here:</p>

<iframe src="//giphy.com/embed/Ps3UNgJew0H7y" width="480" height="347" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>Think about the two types of people who use your code: the users, who should have a seamless experience, which will make you optimize your code, and the abusers (or a better term that I can&rsquo;t think of), or those people who will be looking for security vulnerabilities in <em>your</em> code.</li>
<li>Language design is hard. Refinements are a pretty good example of how a programming language can blow your mind with a single feature</li>
<li>I also met Matz! It was <a href="https://twitter.com/vaidehijoshi/status/606684141506076673">incredibly awesome</a>. And he really is as nice as they say.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactoring to Reveal Rails Group_by]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/06/09/refactoring-to-reveal-rails-group-by/"/>
    <updated>2015-06-09T08:43:24-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/06/09/refactoring-to-reveal-rails-group-by</id>
    <content type="html"><![CDATA[<p><img src="http://img.pandawhale.com/post-10513-Code-Refactoring-Cat-in-Bathtu-U295.gif" style="display: block; margin-left: auto; margin-right: auto;"/></p>

<p>There are a lot of opportunities in programming to feel pretty silly about yourself. I&rsquo;m sure that the more coding experience you have, the less often these moments actually occur. But early on in your career, they seem to happen quite often &ndash; or they do to <em>me</em>, at least.</p>

<p>I had one of those moments a couple weeks ago, when I wrote a super long method and then asked a senior developer to take a look at it. While I was writing it, something seemed inherently wrong. I was sure there was a better way to do it, but I guess my Googling skills aren&rsquo;t quite superb yet, because I couldn&rsquo;t find quite the right answer anywhere. It was then that I decided to ask someone who would know exactly which tool to reach for.</p>

<p>What happened next was pretty awesome, albeit slightly depressing. I watched my code be refactored from ten lines down to a single line. It blew my mind &ndash; and not just because I didn&rsquo;t know that this method even <em>existed</em>, but because I wanted to know how it worked! So, I did some digging and learned a bit about the method that I wrote which, as it turns out, already existed: the Rails <code>group_by</code> method on Enumerables.</p>

<!--more-->


<h2>Data Is For Manipulating</h2>

<p>I started off writing my super long method because I wanted to structure my data in a very specific way. In fact, we&rsquo;ll probably want to structure the data in our Bookstore eCommerce app in a very similar way, too, so let&rsquo;s use that as our working example.</p>

<p>For our admin panel, we want a list of <code>Author</code> objects, categorized by <code>genre</code>. Because our collection of <code>Books</code> is going to grow extensively, it would be helpful for an admin to know which authors are included in a <code>genre</code> or time period. Eventually, this could be used by admins to add new authors by a genre, to filter or sort by a genre, or to calculate an author count per genre, and figure out which authors to add to our collection of books.</p>

<p>Right now, our collection of <code>Author</code> objects isn&rsquo;t very big, but has just enough information for us to start implementing this functionality:</p>

<pre><code class="ruby">&gt; Author.all
=&gt; [{#&lt;Author:0x192ajk21a6d0b0 last_name: "Shakespeare", genre: "Renaissance"&gt;}, 
{#&lt;Author:0w917qwl38f6s8v6 last_name: "Homer", genre: "Classics"&gt;}, 
{#&lt;Author:0x390akd23a5d9m4 last_name: "Faulkner", genre: "Southern Gothic"&gt;}, 
{#&lt;Author:1r103aur58b7c4r2 last_name: "Marlowe", genre: "Renaissance"&gt;}]
</code></pre>

<p>Even though our data is easy to read now, we can be sure that it isn&rsquo;t going to stay that way. But we know that if we structure each of our objects correctly, we could have something simple, like this, in our view:</p>

<pre><code class="ruby">div
  - Author.sort_by_genre.each do |genre, author|
    h2 = genre
    - author.each do |a|
      p = a.last_name
</code></pre>

<p>I&rsquo;m a big fan of slim, which is what I&rsquo;ve used above, but this view would still be pretty minimal when using another templating language such as erb.</p>

<p>Given that this is the view we want to render, we can use this information to structure our data. I&rsquo;m thinking a hash is the tool for the job, with each key being a <code>genre</code> name, and the value being an array of <code>Author</code> objects that we can iterate through for each specific <code>genre</code>.</p>

<p>It would be nice if we could call something like <code>Author.sort_by_genre</code> and have it return a structure like this:</p>

<pre><code class="ruby">=&gt; {"Renaissance": [Shakespeare, Marlowe], 
"Southern Gothic": [Faulkner], 
"Classics": [Homer]}
</code></pre>

<p>So now that we know what we <em>want</em> our data to look like, let&rsquo;s write it the ugly way, just like I did!</p>

<h2>The First Iteration</h2>

<p>To start with, we know that we want to return a hash. So we can start by instantiating a hash, which will be our <code>authors_by_genre</code>. We also know that we&rsquo;ll need all the <code>Author</code> objects in an array; since we&rsquo;re specifically looking for an author&rsquo;s <code>last_name</code> and <code>genre</code>, we can query for those directly. And we can return our empty hash, since that will eventually be filled up:</p>

<pre><code class="ruby">def sort_by_genre
  authors_by_genre = {}
  authors = Author.all.collect { |author| [author.last_name, author.genre] }

  authors_by_genre
end
</code></pre>

<p>Okay, so now we need to fill up our hash. We have our <code>authors</code> variable, which is set to the collection of all <code>Author</code> objects. We will need to iterate through all of them, and put that <code>Author</code> in the correct array for the right <code>genre</code> key. If the right <code>genre</code> key doesn&rsquo;t exist, we&rsquo;ll need to create a key for that author&rsquo;s <code>genre</code>. We can accomplish this with another iteration. Now our method looks like this:</p>

<pre><code class="ruby">class Author
  class &lt;&lt; self
    def sort_by_genre
      authors_by_genre = {}
      authors = Author.all.collect { |author| [author.last_name, author.genre] }

      authors.each do |genre, author|
        if authors_by_genre[genre]
          authors_by_genre[genre] &lt;&lt; author
        else
          authors_by_genre[genre] = [author]
        end
      end

      authors_by_genre
      end
    end
  end
end
</code></pre>

<p>Okay&hellip;so hopefully, by this point, you should be thinking to yourself: <em>This isn&rsquo;t just ugly, it&rsquo;s also <strong>super</strong> inefficient</em>. And you&rsquo;d be right. It&rsquo;s pretty bad.</p>

<iframe src="//giphy.com/embed/asIa0FVaBSQNO" width="480" height="307" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>If you weren&rsquo;t sure how bad it really is, think about all the queries we&rsquo;re making! And how many times we&rsquo;re iterating! As soon as I finished writing this and got it working, I knew it was <em>definitely</em> not the right approach. But the first step is to get it working. Now, we need to seriously consider how we can make it right and make it fast.</p>

<p>You know what what this means, right? Refactoring time.</p>

<h2>Group All The Things</h2>

<p>A quick way to refactor some of the messiness from our first iteration is by first changing how we initialize our hash object, and also modifying how we go about deciding whether to create a new key or add to a key that already exists.</p>

<p>Enter the <code>each_with_object</code> method! This is a pretty rad method I learned about while refactoring my first iteration of this <code>sort_by_genre</code> method. The <code>each_with_object</code> method requires a single argument: the object that you want to pass to it in each iteration. In our case, we&rsquo;ll pass it a hash. And since the items we want to actually &ldquo;categorize&rdquo; are our <code>Author</code> objects, we&rsquo;ll call <code>each_with_object</code> on our collection of <code>Authors</code>:</p>

<pre><code class="ruby">class Author
  class &lt;&lt; self
    def sort_by_genre
      Author.all.each_with_object({}) {  }
    end
  end
end
</code></pre>

<p>Now, what about that block &ndash; what goes inside? Well, we can think about what we want to do with each of our <code>Author</code> objects that we&rsquo;re iterating over. Inside of our hash, which we&rsquo;re passing explicitly as an argument to <code>each_with_object</code>, we want to either find the correct key and put the correct <code>Author</code> into that array, or create a new key based on the current <code>Author</code> object&rsquo;s genre. We can write that quite nicely by using the <code>||=</code> <strong>or equals</strong> operator, which will assign a new object, or whatever is to the right of the operator, equal to the left side of the pipes, or whatever is to the left of the operator:</p>

<pre><code class="ruby">class Author
  class &lt;&lt; self
    def sort_by_genre
      Author.all.each_with_object({}) { 
      |author, hash| (hash[author.genre]
      ||= []) &lt;&lt; author }
    end
  end
end
</code></pre>

<p>Much better, right? In this second iteration, we&rsquo;re passing a hash directly to the <code>each_with_object</code> method, and basically telling it, <em>Find the key in the hash I just passed you that is equal to this author&rsquo;s genre. And if no such key exists, make one, set it equal to an empty array, and then put this current author into that array</em>.</p>

<p>The order of our or equals operator is particularly important, because if it were switched, it would never run what is on the right side of the pipes. The <code>||=</code> operator is exactly like the <code>||</code> operator in that it will run what is to its right <em>only</em> if what is to its left evaluates to <code>false</code>. This is what keeps our method from trying to create multiple keys again and again, and instead forces it to find an existing key first. The super cool thing about the <code>||=</code> operator is that it is actually assigning a new key value to an empty array, which cuts out a lot of extra lines we had in our first iteration!</p>

<p>Okay, so this second iteration has been a vast improvement. But I think it&rsquo;s time for some serious refactoring magic. Are you ready? Okay. This <em>entire</em> method can be rewritten into a single, simple line:</p>

<pre><code class="ruby">class Author
  class &lt;&lt; self
    def sort_by_genre
      Author.all.group_by(&amp;:genre)
    end
  end
end
</code></pre>

<p>Yup. I kid you not.</p>

<iframe src="//giphy.com/embed/sHytgXD2vlNVC" width="480" height="376" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>This is the magic of the Rails <code>group_by</code> method, which collects an enumerable into sets, grouping it by the result of a block. This method takes a proc using the ampersand shortcut as an argument (which we started using last week!). The <code>group_by</code> method is passed the symbol <code>:genre</code>, which is an attribute on each <code>Author</code> object, and corresponds to a <code>genre</code> column in the <code>authors</code> table. So, we are effectively grouping all of our <code>Author</code> objects by the result of calling <code>.genre</code> on each object. In other words, we&rsquo;re grouping by the <code>genre</code> attribute since the attribute corresponds to an <code>attr_accessor</code> method in the class.</p>

<p>And now, if we call our <code>sort_by_genre</code> class method, we get the exact data structure we were hoping for:</p>

<pre><code class="ruby">&gt; Author.sort_by_genre
=&gt; {"Renaissance": [{#&lt;Author:0x192ajk21a6d0b0 last_name: "Shakespeare", genre: "Renaissance"&gt;}, 
{#&lt;Author:1r103aur58b7c4r2 last_name: "Marlowe", genre: "Renaissance"&gt;}], 
"Southern Gothic": [{#&lt;Author:0x390akd23a5d9m4 last_name: "Faulkner", genre: "Southern Gothic"&gt;}], 
"Classics": [{#&lt;Author:0w917qwl38f6s8v6 last_name: "Homer", genre: "Classics"&gt;}]}
</code></pre>

<p>Hooray! Or maybe not hooray. Maybe instead of hooray, you feel like I did when I realized that you could refactor all of this into one line:</p>

<blockquote class="twitter-tweet tw-align-center" lang="en"><p lang="en" dir="ltr">PROGRAMMING:&#10;Write a 10-line method.&#10;Feel proud when it works.&#10;Find out you can write the same thing in a single line.&#10;Cry in the corner.</p>&mdash; Vaidehi Joshi (@vaidehijoshi) <a href="https://twitter.com/vaidehijoshi/status/601156228723642369">May 20, 2015</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p><br></p>

<p>Although it made me feel pretty silly, the actual process of writing the <code>group_by</code> method from scratch was a really great learning experience. I ended up using the examples above in a talk I gave on refactoring at <a href="http://www.twitter.com/reddotrubyconf">Red Dot Ruby Conference</a> in Singapore last week. And I actually recreated the <em>exact same</em> functionality when I had to write my <em>own</em> <code>groupBy</code> function in JavaScript for a React component I had to build! I guess that however deep of a rabbit hole refactoring can be, sometimes it&rsquo;s exactly the right kind of deep dive you need to learn how something works under the hood. I still totally feel like that cat in the bathtub whenever I do it &ndash; but I&rsquo;m kind of okay with that.</p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>group_by</code> method takes a block, which it uses to group a collection of objects. The <code>each_with_object</code> method takes an object as an argument, and a block which tells it how to sort the collection you call the method upon.</li>
<li>Read more on the <code>group_by</code> method in the <a href="http://apidock.com/rails/Enumerable/group_by">Rails docs</a>, which also has a great example!</li>
<li>Looking for another example of how to implement Rails&#8217; <code>group_by</code> in a view? Check out <a href="https://ariejan.net/2007/01/12/rails-group-results-by-week-using-group_by/">this blog post</a>.</li>
<li>Did you know that Ruby also has a similar <code>group_by</code> method? It&rsquo;s great when you want to <a href="http://ruby-doc.org/core-2.2.2/Enumerable.html#method-i-group_by">return a hash</a> where the keys are evaluated by a block!</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Smells and Ruby Shorthand: Unpacking Ampersand + To_proc]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/06/02/code-smells-and-ruby-shorthand-unpacking-ampersand-plus-to-proc/"/>
    <updated>2015-06-02T08:45:24-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/06/02/code-smells-and-ruby-shorthand-unpacking-ampersand-plus-to-proc</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/918rCUjV2XWhi" width="480" height="360" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>There aren&rsquo;t too many things that bring me down when I&rsquo;m deep into programming. But there&rsquo;s always one thing that&rsquo;ll stop me dead in my tracks: a code smell. In the context of programming, a code smell is something that tells you that your code is&hellip;well, a bit <em>off</em>.</p>

<p>Whether you&rsquo;ve been programming for months or for decades, you&rsquo;ll run into &ldquo;code that smells&rdquo; again and again. Except the better that you get, you&rsquo;ll anticipate your code smelling, or before you even write it, you&rsquo;ll know that it&rsquo;s going to stink. For me, a lot of my code that tends to smell are sections where I&rsquo;ve duplicated what I&rsquo;ve written, which is to say that I&rsquo;ve written something that&rsquo;s identical or at least very, very similar to another piece of code in my application. I&rsquo;ve noticed that I&rsquo;ve started catching myself as I write duplicated code, which is a sign that I&rsquo;m getting better as a developer &ndash; hooray!</p>

<p>But, there are a lot of <a href="http://en.wikipedia.org/wiki/Code_smell#Common_code_smells">common code smells</a>, and I definitely still can&rsquo;t catch all of them in my own code. Generally, if any part of your program has a common code smell, it&rsquo;s a sign that you need to rethink how your system is structured on a deeper level, and that it&rsquo;s probably time to start refactoring.</p>

<p>Recently, I&rsquo;ve noticed that I&rsquo;ve been sniffing out the same issue in my code: long methods. So I did a bit of investigating and found that there are some cool ways to shorten up your longer methods. Thanks to Ruby magic, we have easy access to methods like <code>to_proc</code> in the form of &ldquo;ampersand and object&rdquo;, or the <strong>&amp;:</strong> syntax. If you have no clue what those are, don&rsquo;t worry. I didn&rsquo;t either! Until I wrote this post, obvs.</p>

<!--more-->


<h2>A Slim Method Is A Beautiful Method</h2>

<p>In our eCommerce bookstore app, we&rsquo;re storing our <code>Order</code> <code>amount</code> totals as BigDecimals. You might remember why BigDecimals <a href="http://vaidehijoshi.github.io/blog/2015/02/10/money-makes-the-world-go-round-using-money-rails-and-bigdecimal/">are better than floats</a> when it comes to performing accurate monetary calculations. But even though we&rsquo;re using BigDecimal on the backend, there may be times when we want to convert our decimals back into floats. Like what if we want to start integrating a JavaScript frontend? (yes, I went there). The point is, we should be able to do something like that pretty easily, especially if we wanted to serialize and return a JSON object that has the correct object type.</p>

<p>We&rsquo;d probably start by iterating through all of our order amounts and turn them into floats, like this:</p>

<pre><code class="ruby">class Order
    class &lt;&lt; self
        def amounts_to_floats
            Order.all.map do |order|
                order.amount.to_f
            end
        end
    end
end
</code></pre>

<p>Well, it does the job. But&hellip;it doesn&rsquo;t look so great, does it? Let&rsquo;s cut it down:</p>

<pre><code class="ruby">class Order
    class &lt;&lt; self
        def amounts_to_floats
            Order.all.map {|order| order.amount.to_f }
        end
    end
end
</code></pre>

<p>Okay, let&rsquo;s make it a little fancier and throw in the <code>pluck</code> method, which will query for only the to grab <em>only</em> an <code>Order</code>&rsquo;s <code>amount</code>?</p>

<pre><code class="ruby">class Order
    class &lt;&lt; self
        def amounts_to_floats
            Order.pluck(:amount).map {|amount| amount.to_f }
        end
    end
end
</code></pre>

<p>I guess it&rsquo;s better, but still not as good as it could be. Are you thinking what I&rsquo;m thinking? There&rsquo;s <em>gotta</em> be a better way!</p>

<p><img src="http://provensal.com/lbb/wp-content/uploads/2013/03/better_way.jpg" style="display: block; margin-left: auto; margin-right: auto;"></p>

<h2>A Proc And An Object Walk Into A Bar&hellip;</h2>

<p>As is the case with most things in programming, if we wish for a better way to do something, we can generally assume that there is! And in our case, the better way to do it is by using something called <strong>ampersand and object</strong>.</p>

<p>And we can implement it on our <code>amounts_to_floats</code> method like so:</p>

<pre><code class="ruby">class Order
    class &lt;&lt; self
        def amounts_to_floats
            Order.pluck(:amount).map(&amp;:to_f)
        end
    end
end
</code></pre>

<p>The result of this will be the exact same thing as the <code>map</code> we wrote above:</p>

<pre><code class="ruby">&gt; Order.amounts_to_floats
=&gt; [210.99, 150.5, 24.99, 391.99, 120.25]
</code></pre>

<p>So, what happened here? Well, let&rsquo;s just start with what we know for sure.</p>

<ol>
<li><p>We took all the <code>Order</code> objects and queried for just their <code>amounts</code>, which are in <code>BigDecimal</code> format.</p></li>
<li><p>The <code>pluck</code> method returns an array of the attributes that you query for, so, which would mean that our array would look something like this:
<code>[#&lt;BigDecimal:7f87ed12b2f0,'0.21099E3',18(18)&gt;, #&lt;BigDecimal:7f87ed121700,'0.1505E3',18(18)&gt;, #&lt;BigDecimal:7f87ed119348,'0.2499E2',18(18)&gt;...]</code></p></li>
<li><p>Okay, so then we mapped over all of these amounts, right? And somehow we called <code>.to_f</code> on all of them. Which returned the array that we were hoping for:
<code>[210.99, 150.5, 24.99, 391.99, 120.25]</code></p></li>
</ol>


<p>All of this begs one question: how on earth did the <code>&amp;</code> (ampersand) know to call <code>to_f</code> on each of our objects? And how did <code>map</code> know what to do with the ampersand that we passed it?</p>

<p>Time to find out.</p>

<h2>Procs on Procs</h2>

<iframe src="//giphy.com/embed/umwRSMxcXW31m" width="480" height="244" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Whenever something seems super daunting, I go back to the basics. Which is exactly what I think we should do here, too. We can all agree that in Ruby is an object, right? And methods are how we send messages to objects. With that in mind, let&rsquo;s look back at that confusing line of code:</p>

<pre><code class="ruby">Order.pluck(:amount).map(&amp;:to_f)
</code></pre>

<p>We know <code>Order.pluck(:amount)</code> to be an array &ndash; it&rsquo;s an object, which means it&rsquo;s the <em>receiver</em> of our method. That means that <code>.map</code> is our method. And <code>map</code> has been passed <code>&amp;:to_f</code>, which seems to have replaced the usual <code>do end</code> or <code>{}</code> blocks that generally accompany the <code>map</code> iterator.</p>

<p>At this point, if you&rsquo;re thinking that the <code>&amp;</code> ampersand is responsible for executing that <code>to_f</code> method on each of the elements of the array, you&rsquo;re definitely onto something.</p>

<p>In fact, the <code>&amp;</code> calls <em>another</em> method on the object: <code>to_proc</code>. The ampersand calls <code>to_proc</code> on whatever comes after it. In our case, it&rsquo;s the <code>to_f</code>. But it&rsquo;s not just the plain old method <code>to_f</code> &ndash; it&rsquo;s actually the <em>symbol</em>, <code>:to_f</code>.</p>

<p>And we can double check this by looking at <a href="http://ruby-doc.org/core-1.9.3/Symbol.html#method-i-to_proc">the Ruby docs</a>! The <code>to_proc</code> method is defined on the <code>Symbol</code> class:</p>

<blockquote><p><code>to_proc</code> Returns a Proc object which responds to the given method by sym.</p></blockquote>

<p>So all the <code>&amp;</code> is doing is: <code>:to_f.to_proc</code>. It turns the symbol into a proc, and whatever object you pass to it, it&rsquo;ll call that method on that object. You&rsquo;re basically telling the <code>map</code> function, <em>Hey, I already have this method I want to call on every single item you&rsquo;re iterating over. So when you invoke yourself on the receiving object, run this code that I&rsquo;m passing you.</em></p>

<p>Because <code>:to_f</code> isn&rsquo;t actually a block, the ampersand tries to make it a block by calling <code>to_proc</code> on it. This means that you can pass any method to <code>&amp;</code> in symbol form, and it will convert it to and invoke that proc.</p>

<p>But what if you didn&rsquo;t want to pass it a defined method in Ruby as a symbol? What if, instead, you wanted to write your own block and pass it to <code>&amp;</code> explicitly? That would look something like this:</p>

<pre><code class="ruby">half_off_sale = Proc.new { |amount| amount/2 }

Order.pluck(:amount).map &amp;half_off_sale
=&gt; [#&lt;BigDecimal:7f87ec20e4c0,'0.105495E3',18(45)&gt;, #&lt;BigDecimal:7f87ec20e3d0,'0.7525E2',18(45)&gt;, #&lt;BigDecimal:7f87ec20e2e0,'0.12495E2',18(45)&gt;...]
</code></pre>

<p>Pretty cool, right? In this case, we created a <code>half_off_sale</code> proc, that we passed directly to the ampersand. The <code>&amp;</code> didn&rsquo;t have to make it a proc (meaning that it didn&rsquo;t have to invoke <code>to_proc</code>) since we already passed it one. So when <code>map</code> iterated through all the amounts, it yielded to our <code>half_off_sale</code> proc, and ran that code on every single element in our array of amounts.</p>

<p>As you can see, the ampersand and object and <code>to_proc</code> methods can be pretty powerful &ndash; particularly when they&rsquo;re combined into this handy little shortcut! That doesn&rsquo;t mean you have to use them all the time, but if you understand the fundamentals of how they work, they can really help clean up your code, especially when it&rsquo;s pretty smelly.</p>

<p>This is just a primary introduction to the concepts of ampersand and object and <code>to_proc</code>. There&rsquo;s definitely a lot more to them, and they can get quite complicated. I&rsquo;m still learning about them myself! But, I&rsquo;m going to keep reading about how procs work and, hopefully, there&rsquo;ll be a forthcoming Technical Tuesdays post about how to pass methods to procs! Until then, keep sniffin&#8217; out those code smells, my friends!</p>

<iframe src="//giphy.com/embed/LeaMGoMmMGrf2" width="480" height="360" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>&amp;</code> (ampersand) can be used with an iterator like <code>map</code>, and will call <code>to_proc</code> on whatever symbol you pass it, unless you pass it a block explicitly.</li>
<li>More examples and explanations on <a href="http://stackoverflow.com/questions/9429819/what-is-the-functionality-of-operator-in-ruby">these</a> <a href="http://stackoverflow.com/questions/2259775/what-do-you-call-the-operator-in-ruby">two</a> StackOverflow posts.</li>
<li>Here&rsquo;s a <a href="http://www.dan-manges.com/blog/29">great blog post</a> on all the ways you can use <code>&amp;</code> to manipulate ActiveRecord models.</li>
<li>If you&rsquo;re still curious about different ways to pass around procs, check out <a href="http://ablogaboutcode.com/2012/01/04/the-ampersand-operator-in-ruby/">this post</a>, which is what I used when I was learning about them!</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Investigating Ruby's Global Functions + Kernel Module With Puts]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/05/12/investigating-rubys-global-functions-plus-kernel-module-with-puts/"/>
    <updated>2015-05-12T08:09:27-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/05/12/investigating-rubys-global-functions-plus-kernel-module-with-puts</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/10Vy7fN9fr7dD2" width="480" height="361" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>When you&rsquo;re a relatively new developer, it&rsquo;s easy to get caught up in all of the things that you don&rsquo;t know. And boy is <em>that</em> a long, long list of things. But there&rsquo;s also another list that we should probably consider and revisit from time to time: the list of all the things we thought we knew, but didn&rsquo;t <em>really</em> understand when we learned them.</p>

<p>Last week, while developing some curriculum for an Intro to Programming course, my co-teacher and I had one of those moments. We were trying to draw a diagram to explain the concept of an object &ldquo;receiving&rdquo; a method. As I looked back through our code snippets, I noticed that we were using very basic methods like <code>puts</code> and <code>gets</code> quite often, as most Ruby tutorials usually do. And then I realized something: I had no clue what the receiver of the <code>puts</code> method was.</p>

<p>We both just sat there, partly perplexed and partly dumbfounded. How could we not know how <code>puts</code> and <code>gets</code> really worked? We used them all the time when we were learning to code, so perhaps we didn&rsquo;t really think past the flexibility of these methods. But now that we are both more seasoned programmers, it seemed strange that we had never really thought about this before.</p>

<p>So, I did exactly what any good developer would do: I asked Twitter. Well, okay, I asked Twitter&hellip;and then I put on my detective hat and did some investigating of my own.</p>

<!--more-->


<h2>Puts, I love you, but you&rsquo;re bringing me down</h2>

<blockquote class="twitter-tweet tw-align-center" lang="en"><p lang="en" dir="ltr">RUBYISTS, please help: what is the receiver of the puts and gets methods? Is it the main Object? I need to know, it&#39;s driving me crazy</p>&mdash; Vaidehi Joshi (@vaidehijoshi) <a href="https://twitter.com/vaidehijoshi/status/596465002669875201">May 8, 2015</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>I have a bone to pick with the <code>puts</code> method. Well, okay, two bones I guess. First, it has no explicit receiver:</p>

<pre><code>♥ irb
2.2.0 :001 &gt; puts "wat"
wat
 =&gt; nil 
</code></pre>

<p>And second, it&rsquo;s just REALLY hard to figure out what on earth is happening with this method. In fact, the hardest part about understanding <code>puts</code> was figuring out exactly <em>where</em> inside of Ruby it lived.</p>

<p>Apparently though, there&rsquo;s a method for that &ndash; well, two methods, actually. The <code>owner</code> and the <code>receiver</code> methods can be used to ask a method where it lives and who it can be called on. We can just pass it the name of the method we&rsquo;re curious about as a symbol, and then ask it where it belongs:</p>

<pre><code>2.2.0 :002 &gt; method(:puts).receiver
 =&gt; main 

2.2.0 :003 &gt; method(:puts).owner
 =&gt; Kernel 
</code></pre>

<p>WAT. It seemed like <code>main</code> was the receiver of this method, while <code>Kernel</code> was the owner, or the place where this method was actually defined.</p>

<p>But did that mean that <code>main</code> was also self within the context of <code>irb</code>? And what <em>was</em> <code>main</code>, exactly? There was only one way to find out:</p>

<pre><code>2.2.0 :004 &gt; method(:gets).receiver == self
 =&gt; true 

2.2.0 :005 &gt; self
 =&gt; main 

2.2.0 :006 &gt; self.class
 =&gt; Object
</code></pre>

<p>Pretty weird, right? But hang on&hellip;there was a line up there that was pretty new for me. Something about a <code>Kernel</code>? Let&rsquo;s do a bit more detective work.</p>

<h2>Tell Me &lsquo;Bout Them Kernels</h2>

<iframe src="//giphy.com/embed/rambtrormFyWQ" width="480" height="268" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Okay, you&rsquo;re probably wondering: <em>So that <code>Kernel</code> thing &ndash; what&rsquo;s the deal?</em> Well, it turns out that <code>Kernel</code> is a module, and if you&rsquo;re like me, you probably haven&rsquo;t thought about it that much until now.</p>

<p>But what you might remember about modules is that they have to be mixed into a class in order to be included; that is to say, in order for a class or instances of a class to have access to methods in a module, that module has to be included or extended into the class.</p>

<p>Which means that <code>Kernel</code> has to be included into a Ruby class. But&hellip;which one? To figure out, we need to think back to what <code>self</code> was within the context of <code>irb</code>: <code>main</code>. If we try to ask <code>main</code> for its ancestors (so that we can deduce where the <code>Kernel</code> module is coming into play), we get this error:</p>

<pre><code>2.2.0 :007 &gt; main.ancestors
NoMethodError: undefined method `ancestors' for main:Object
  from (irb):75
  from /usr/bin/irb:12:in `&lt;main&gt;'
</code></pre>

<p>Okay, not so great. But hang on a second&hellip;since we know that <code>main</code> is an instance of the <code>Object</code> class, we can just ask the <code>Object</code> class who its ancestors are!</p>

<pre><code>2.2.0 :008 &gt; Object.ancestors
 =&gt; [Object, Kernel, BasicObject] 
</code></pre>

<p>Nice! We found <code>Kernel</code>, and it looks like it&rsquo;s included the <code>Object</code> class. We can figure this out because it appears to the right of <code>Object</code>, which means it has been mixed into the class to its left.</p>

<p>So, if a method like <code>puts</code> is written in the <code>Kernel</code> module, what can it be called on? Who is doing the &ldquo;receiving&rdquo; of this method call? Well, according to <a href="http://ruby-doc.com/docs/ProgrammingRuby/html/ref_m_kernel.html">the Ruby docs</a>, pretty much anything:</p>

<blockquote><p>The Kernel module is included by class Object, so its methods are available in every Ruby object. These methods are called without a receiver and thus can be called in functional form.</p></blockquote>

<p>So, theoretically-speaking, if the Kernel module is included by class Object, and is therefore available to <em>every</em> Ruby object, we should be able to call <code>puts</code> on a <code>String</code> instance, right?</p>

<pre><code>2.2.0 :009 &gt; "".puts('wat')
NoMethodError: private method `puts' called for "":String
  from (irb):79
  from /usr/bin/irb:12:in `&lt;main&gt;'
</code></pre>

<p>Uh oh! Maybe we can&rsquo;t. But&hellip;why not?</p>

<h2>Global Functions</h2>

<p>If you are smart cookie, you probably read that error and guessed that <code>puts</code> is a private method defined on <code>Kernel</code>. We can confirm this by using the <code>private_method_defined?</code> method to double check:</p>

<pre><code>2.2.0 :010 &gt; Kernel.private_method_defined?(:puts)
 =&gt; true
</code></pre>

<p>The fact that <code>puts</code> is a private method is important. It means that it can&rsquo;t be called explicitly by anyone else. But how is it, then, that we use this method so frequently and easily? Well, because its mixed in to class <code>Object</code>, it&rsquo;s accessible to any Ruby object &ndash; but only in the current context. This explains why <code>puts</code> never has to be called explicitly upon any object; instead, it will be called <em>implicitly</em> on whatever <code>self</code> happens to be. In other words, the method will be called on the current context of <code>self</code>.</p>

<p>It&rsquo;s also pretty crucial that a method like <code>puts</code> can be called in the current context of self. In fact, that&rsquo;s exactly what allows us to do this within a Ruby class:</p>

<pre><code class="ruby">Class Duck
  def self.swim
    puts "We're swimming."
  end

  def quack
    puts "Quack quack!"
  end
end
</code></pre>

<p>or something like this in <code>irb</code>:</p>

<pre><code>2.2.0 :011 &gt; puts "Waddle waddle"
Waddle waddle
 =&gt; nil 
</code></pre>

<p>Even though the context of <code>self</code> changes from the Duck Class, to an instance of a Duck, back to <code>main</code> in <code>irb</code>, we have access to <code>puts</code> in all contexts. It&rsquo;s kind of magical, if you think about it: a single private method, defined in a module, trickles down to all Ruby objects that descend from it!</p>

<p>And this magic has a name: <strong>global functions</strong> work. Since methods like <code>puts</code> are defined on the <code>Kernel</code> and mixed into the <code>Object</code> class, they are accessible <em>everywhere</em>. They&rsquo;re private methods, which means they must be invoked without an explicit receiver (also known as a &ldquo;function form&rdquo; of method invocation).</p>

<p>I really liked the way that <a href="https://codequizzes.wordpress.com/2014/04/22/rubys-kernel-module/">this blog post</a> explains the concept:</p>

<blockquote><p>Virtually all Ruby objects inherit from Object and have access to the methods defined in the Kernel module, so Kernel’s private instance methods are accessible virtually anywhere in a Ruby program, regardless of self.</p></blockquote>

<p>And you know what&rsquo;s even cooler? These global functions defined on <code>Kernel</code> are used everywhere! In fact, you probably don&rsquo;t even realize that you use them. Here are some of the ones that surprised me:</p>

<ul>
<li><code>gets</code></li>
<li><code>chomp</code></li>
<li><code>sleep</code></li>
<li><code>require</code></li>
<li><code>gem</code></li>
<li><code>rand</code></li>
<li><code>gsub</code></li>
<li><code>proc</code></li>
<li><code>eval</code></li>
</ul>


<p>Yup. All of these methods are defined on <code>Kernel</code>, available to all objects (including <code>main</code> as <code>self</code> in <code>irb</code>), and don&rsquo;t need a receiver to be called!</p>

<iframe src="//giphy.com/embed/gLRDi5KnA3Fte" width="480" height="374" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Now that you know where all these methods live and where they come from, you probably feel pretty powerful. You also will hopefully feel more purposeful when you write even a simple <code>puts</code> statement in a line of code.</p>

<p>Perhaps the moral of the story here is to never take code for granted: always question how it works and try to understand exactly what&rsquo;s going on in every line that you type.</p>

<p>The second moral is to use other developers on Twitter as resources to help you figure out what to Google, obvs.</p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>Kernel</code> module is mixed into the <code>Object</code> class, which means all methods (including private methods!) defined on this module are accesible to all Ruby objects, making them &ldquo;global&rdquo; functions.</li>
<li>Even though a method&rsquo;s implicit receiver is <code>self</code>, the context of <code>self</code> changes depending on which class you are in; this is particularly important when dealing with &ldquo;global&rdquo; functions.</li>
<li>Curious about <code>main</code> and <code>self</code> in <code>irb</code>? Check out these two great <a href="http://www.sitepoint.com/rubys-top-self-object/">blog</a> <a href="https://banisterfiend.wordpress.com/2010/11/23/what-is-the-ruby-top-level/">posts</a>.</li>
</ul>

]]></content>
  </entry>
  
</feed>
