<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-08-11T08:54:46-04:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rolling Out the Redcarpet for Rendering Markdown]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/08/11/rolling-out-the-redcarpet-for-rendering-markdown/"/>
    <updated>2015-08-11T08:47:54-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/08/11/rolling-out-the-redcarpet-for-rendering-markdown</id>
    <content type="html"><![CDATA[<p><img src="http://cdn.lolbrary.com/2013/12/6/lolbrary.com_45273_1386359887.jpg" style="display: block; margin-left: auto; margin-right: auto; max-width: 400px; max-height: 500px;"/></p>

<p>Sometimes, it&rsquo;s the little things that matter the most. As cool and complex as your giant application might be, small details like a toggleable button, or beautiful-formatted and styled dropdown select can have the biggest impact on the look and feel of the rest of your application.</p>

<p>Once you&rsquo;ve built out the skeleton of your application and filled in the backend functionality, the next step is to connect the all the logic with your frontend framework. And once you&rsquo;ve done that, you start to see all the gaping holes that you need to fix next. One of the applications that I have been working on recently got to that state. Once I ensured that the user-facing page corresponded to the admin panel, it was time to fix all the little things that I had been putting off until we got the application working!</p>

<p>One of those minute details was rendering markdown. While building out the application, we were just using Ruby string primitives in our database to render text. But no one wants to see a long five-paragraph article rendered as a single, huge block of text, right? So, we had to make our text easily editable on the admin panel and renderable &mdash; that&rsquo;s word, right? &mdash; on the user-facing side. At first, I had no idea how to go about doing this. But it turns out that (no surprise here!) this problem has been solved before! All we had to do next was figure out how to implement someone else&rsquo;s solution on our own application. Luckily, the answer to our prayers is as simple as rolling out the <code>redcarpet</code> gem.</p>

<!--more-->


<h2>Markdown: What is it?</h2>

<p><img src="http://kirkstrobeck.github.io/whatismarkdown.com/img/markdown.png" style="display: block; margin-left: auto; margin-right: auto; max-width: 400px; max-height: 300px;"/></p>

<p>The Markdown language didn&rsquo;t exist until 2004, when it was created by John Gruber of <a href="http://daringfireball.net/">Daring Fireball</a> blog fame. Unlike markup languages such as HTML or RTF (Rich Text Format), Markdown was created to not have any tags for formatting &ldquo;instructions&rdquo; when rendered. Instead, it is structured to be <a href="http://whatismarkdown.com/">readable without formatting</a> or any tags. Ultimately, the language converts simple text into structurally valid markup HTML (or XHTML).</p>

<p>We interact with Markdown a lot, even though we might not always realize it. Files that end in <code>.md</code>, for example, are written in Markdown, and a lot of blog generators (including octopress and jekyll) use Markdown as their formatting language. In fact, this language is exactly what allows us to write something like this into a code snippet or CMS parser:</p>

<pre><code># I'm a heading

This is a list:

* thing one
* thing two
* thing three

And here's some *italics* and some **bold**.
</code></pre>

<p>which will then be processed by Markdown to render actually <em>this</em> HTML in our templates:</p>

<p>&#8220;`html</p>

<h1>I&#8217;m a heading</h1>




<p>This is a list:</p>




<ul>
  <li>thing one</li>
  <li>thing two</li>
  <li>thing three</li>
</ul>




<p>And here&#8217;s some <em>italics</em> and some <strong>bold</strong>.</p>


<pre><code>
Not only is that incredibly cool, but it's also a powerful templating tool! There's one slight problem, however: our templates don't look anything like this. We have neither any Markdown, nor any HTML! Instead, we're just rendering long strings (saved in our Postgres database as `text` attributes) that look like this:

`Here's a news article about Harper Lee's new novel, Go Set A Watchman, but it has no formatting at all...`

So, how do we get our text to look like the beautiful markup from above? Why, by using a special Markdown gem, of course!

## HTML All Of The Things

Markdown processig in Ruby is made especially easy thanks to a library called `redcarpet`, created by a Github developer named &lt;a href="https://github.com/vmg"&gt;Vicent Marti&lt;/a&gt; (thanks, Vicent!). The library is available as a gem, and its parser doesn't require any additional installed libraries aside from Ruby itself.

Let's get set up by adding it to our `Gemfile`:

`gem "redcarpet"`

and bundling up this gem:

`$ bundle install`

Great. Now we need figure out how to recarpet our application using this library! The first thing I like to do whenever I'm working with a library or gem that's completely new to me is decipher what exactly I'm working with here. Thankfully, the `redcarpet` documentation is really fantastic, and they answer this question almost immediately:

&gt;"The core of the Redcarpet library is the Redcarpet::Markdown class. Each instance of the class is attached to a Renderer object; the Markdown class performs parsing of a document and uses the attached renderer to generate output."

Okay...what does this mean, exactly? Well, it's actually not *too* complicated. The library has a `Redcarpet::Markdown` class, which --- you guessed it --- is going to be responsible for handling the transforming/parsing of Markdown to markup (we'll be using HTML, in our case). But it's also attached to a Renderer object, it seems.

An example will help us visualize what exactly is going on here:

`markdown = Redcarpet::Markdown.new(renderer, extensions = {})`

Interesting! the new instance of our `Redcarpet::Markdown` class takes two arguments, one of which *is* our Renderer object. It also seems to take a hash of `extensions`, but we'll come back to that in a bit.

We know that we want to pass in a renderer to our `Redcarpet::Markdown` class...but what are our options? It turns out that there are two built-in renderers that the `redcarpet` library uses: `Redcarpet::Render::HTML` and `Redcarpet::Render::XHTML`. 

*Protip: the `redcarpet` renderers are actually implemented in C, which means that they are incredibly performant and so much faster than other Ruby Markdown renderers!*

Since we want our articles to render HTML, we'll stick with the former renderer rather than the latter:

`markdown = Redcarpet::Markdown.new(Redcarpet::Render::HTML)`

It's important to note that what's *actually* happening here is that we are creating a new *instance* of an HTML renderer, and passing that to our `Redcarpet::Markdown` object. This is crucial to remember because our `Redcarpet::Render::HTML` can also take its own set of options! When we initialize our HTML renderer, we have the option of passing some flags to it. And then, we pass our HTML renderer to our `markdown` object, which will actually handle parsing it:
</code></pre>

<p>renderer = Redcarpet::Render::HTML.new(render_options)
markdown = Redcarpet::Markdown.new(renderer, extensions)
&#8220;`</p>

<p>We won&rsquo;t add any options to start, but don&rsquo;t forget that this is what&rsquo;s <em>actually</em> happening! Now it&rsquo;s time for a deep breath; next, we&rsquo;ll need to actually implement this <code>markdown</code> object in our application!</p>

<p><img src="http://g-ecx.images-amazon.com/images/G/01/askville/137733_9521259_mywrite/html_cat.jpg" style="display: block; margin-left: auto; margin-right: auto; max-width: 500px; max-height: 400px;"/><br></p>

<p>The first thing we&rsquo;ll want to do is add our <code>markdown</code> object to the class that will need our Markdown parser. For our Bookstore application, we&rsquo;ll have a set of news articles that will show up on our homepage when a user signs in. This means that we&rsquo;ll want our <code>Article</code> objects to be able to implement markdown. Since this is something our <em>entire</em> class should be able to do, we&rsquo;ll add our <code>markdown</code> object as a class method to our <code>Article</code> model:</p>

<pre><code class="ruby">class Article &lt; ActiveRecord::Base
  class &lt;&lt; self
    def markdown
      Redcarpet::Markdown.new(Redcarpet::Render::HTML)
    end
  end
end
</code></pre>

<p>This method isn&rsquo;t doing anything aside from creating a new instance of a <code>Redcarpet::Markdown</code> parser, with a <code>Redcarpet::Render::HTML</code> renderer. Next, we&rsquo;ll want to add write a migration that will create another column in our database that will save our markdown content:</p>

<pre><code class="ruby">class AddMarkdownContentToArticles &lt; ActiveRecord::Migration
  def change
    add_column :articles, :markdown_content, :text
  end
end
</code></pre>

<p>The reason that we have two different columns for persisting content is simple: we have two different types of content that we&rsquo;re dealing with. The <code>content</code> column in the database is what the admins will edit in the admin panel, while the <code>markdown_content</code> column is what will be rendered to the user.</p>

<p>This will be especially evident when we integrate this with our Ember frontend, which would require us to serialize all the data that Rails is passing to the Ember models. In our <code>ArticleSerializer</code>, we are are only passing our <code>markdown_content</code> through to the frontend:</p>

<pre><code class="ruby">class ArticleSerializer &lt; ApplicationSerializer
    attributes :id, :slug, :title, :markdown_content, :published_at
end
</code></pre>

<p>On the other hand, in our <code>Admin::ArticleSerializer</code>, which is hooked up to our admin panel, we are <em>only</em> passing the raw <code>:content</code>, which is our content <em>before</em> is has been parsed through our <code>markdown</code> object:</p>

<pre><code class="ruby">module Admin
  class ArticleSerializer &lt; ApplicationSerializer
    attributes :id, :slug, :title, :content, :published_at
  end
end
</code></pre>

<p>Nice! We have everything set up, finally. Let&rsquo;s make sure that we&rsquo;re actually parsing our <code>content</code> and assigning our <code>markdown_content</code> when our article is saved. We can do this by adding a <code>before_save</code> hook, which will call whatever method we pass it right before our <code>Article</code> model is saved:</p>

<pre><code class="ruby">class Article &lt; ActiveRecord::Base
  class &lt;&lt; self
    def markdown
      Redcarpet::Markdown.new(Redcarpet::Render::HTML)
    end
  end

  before_save :assign_markdown_content, if: -&gt; { content_changed? }

  def assign_markdown_content
    assign_attributes({
      markdown_content: self.class.markdown.render(content)
    })
  end
end
</code></pre>

<p>Cool! We wrote a <code>assign_markdown_content</code> method that assigns the <code>markdown_content</code> attribute on our <code>Article</code>. And what exactly is it using to assign the <code>markdown_content</code>? Oh, that&rsquo;s right: our <code>markdown</code> object! We&rsquo;re calling the <code>markdown</code> class method, and passing the <code>Article</code>&rsquo;s content to its <code>render</code> method, which means that the <code>Redcarpet::Markdown</code> instance will parse the content into HTML!</p>

<p>We&rsquo;re also doing a pre-check in our <code>before_save</code> by passing a proc to this callback which will only call the <code>assign_markdown_content</code> method if our <code>content</code> column in the database has changed (isn&rsquo;t that <code>content_changed?</code> method is a cool ActiveRecord trick?). This means that we&rsquo;re not assigning attributes on our <code>Article</code> unless we really need to. This is super efficient because it means avoiding unnecessary queries to our database!</p>

<h2>Carpeting Options</h2>

<p>The last part of this <code>redcarpet</code> magic is rendering our content in our views and adding any options we might need. If we wanted to do this in a simple Rails view, we could just ask the <code>Article</code> object for its <code>markdown_content</code>:</p>

<pre><code class="slim">article
  = @article.markdown_content.html_safe
</code></pre>

<p>We might need to call <code>html_safe</code> on this particular column since Rails will try to escape the content automatically. We could do a similar thing in an Ember view as well, using triple handlebars to handle the HTML safe issue:</p>

<p><code>}</code></p>

<p>Now that we finally have everything working, we can add some cool options to our renderer! You&rsquo;ll remember that the <code>Redcarpet::Markdown</code> class takes a hash of options.</p>

<p>In my opinion, the most helpful and important option to pass in is <code>autolink</code>. It&rsquo;s super crucial if you don&rsquo;t know what your content might look like, since it parses links even when they&rsquo;re not enclosed in <code>&lt; &gt;</code> characters. It will detect autolinks for http, https, and ftp protocols, and it also handles email addresses and links that start with <code>www</code>.</p>

<p>We can pass in this option directly as second arguments after we pass in our <code>Redcarpet::Render::HTML</code> object:</p>

<pre><code class="ruby">def markdown
  Redcarpet::Markdown.new(Redcarpet::Render::HTML, autolink: true)
end
</code></pre>

<p>Other helpful options on the <code>Redcarpet::Render::HTML</code> object include <code>tables</code>, <code>space_after_headers</code>, <code>lax_spacing</code>, and <code>highlight</code>. Of course, just as you can pass in options to the markdown object you can do the same for the renderer:</p>

<p><code>Redcarpet::Render::HTML.new(hard_wrap: true, safe_links_only: true, escape_html: true)</code></p>

<p>The <code>escape_html</code> option is particularly interesting because it takes precedence over <code>:no_styles</code>, <code>:no_links</code>, <code>:no_images</code> and <code>:filter_html</code>, which means that any existing html tags will be escaped instead of being removed. I&rsquo;m also pretty sure that it would escape any cats you try to pass in through params as well&hellip;although I haven&rsquo;t tried that one yet.</p>

<p><img src="http://geekandpoke.typepad.com/.a/6a00d8341d3df553ef0120a8b86eae970b-800wi" style="display: block; margin-left: auto; margin-right: auto; max-width: 400px; max-height: 500px;"/><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>redcarpet</code> gem is an awesome way to handle rendering Markdown in Rails. It creates a new instance of a Markdown object, which takes either a HTML or XHTML renderer object. You can also write your own, custom render! Check out the <a href="https://github.com/vmg/redcarpet">documentation</a> to learn more on how to do that.</li>
<li>Want to see a step-by-step Rails tutorial on <code>redcarpet</code>? Check out <a href="http://railscasts.com/episodes/272-markdown-with-redcarpet">this Railscast</a>.</li>
<li>Here&rsquo;s a super <a href="https://richonrails.com/articles/rendering-markdown-with-redcarpet">detailed blog post</a> on implementing <code>redcarpet</code>, with some great code snippets and examples.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Safely Storing Your Assets: Paperclip With AWS + Heroku]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/08/04/safely-storing-your-assets-paperclip-with-aws-plus-heroku/"/>
    <updated>2015-08-04T08:15:32-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/08/04/safely-storing-your-assets-paperclip-with-aws-plus-heroku</id>
    <content type="html"><![CDATA[<p>We all know how this scene plays out: you&rsquo;ve created the first iteration of your application and you&rsquo;re ready to test it out in production. You can&rsquo;t wait to see what it looks like live, and you want people to be able to start playing with it! Everything seems to go smoothly without any glitches while deploying until you go to your app on Heroku and see&hellip;<em>a broken image icon</em>. Tada!</p>

<iframe src="//giphy.com/embed/EVJBgyC41ItfW" width="480" height="208" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>This happened to me recently, and boy was it disheartening. I was all excited because I had used <code>paperclip</code> to get some pretty cool <a href="http://vaidehijoshi.github.io/blog/2015/07/28/clipping-images-for-rails-using-paperclip/">image uploading functionality</a> on my application, but it didn&rsquo;t seem like it was working. It turns out, however, that an application in development is one thing; the same app in production is another game entirely.</p>

<p>While developing an application, our environments are configured in a certain way. It&rsquo;s easy to forget that things will change once we deploy what we&rsquo;ve been working on. Being able to implement something like the <code>paperclip</code> gem in development doesn&rsquo;t easily carry over to your production environment &ndash; unless, of course, you know what tool to use. Luckily, there&rsquo;s a great gem that was created specifically to make the transition from development to production quick and easy: the <code>aws-sdk</code> gem, Amazon Web Services&#8217; Software Development Kit that was created to use with Rails applications for storing your static assets in your AWS Simple Storage bucket. And once you know how to set it up with your Heroku account, you can get rid of that pesky broken image icon once and for all!</p>

<!--more-->


<h2>Street Cred For The Web: S3 Credentials</h2>

<p>Amazon Web Services&#8217; Simple Storage Service (S3) is a one of the most important platform services that a web developer can use. At its most basic level, it&rsquo;s a store that allows us to store important assets that we&rsquo;ll need for our application, including things like media files, pdfs, attachments, and anything that our users may upload.</p>

<p>The <em>really</em> cool thing about AWS is that it allows us to store all those files offsite &ndash; that is to say, <em>not</em> on our Heroku application, and instead using a third-party service. Pretty amazing, right?</p>

<iframe src="//giphy.com/embed/GHTwlFLITq7v2" width="480" height="270" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>This is particularly important as our application starts to grow, and we are forced to scale to size. It also makes our application super fast, since our files aren&rsquo;t being stored within our application itself, which means that we don&rsquo;t need to use our filesystem to retrieve all those assets.</p>

<p>When it comes to integrating your application with AWS S3, however, the most important step is establishing your credentials. In fact, we can&rsquo;t even hook up our <code>paperclip</code> configurations &ndash; or really, <em>any</em> configurations, for that matter &ndash; without our S3 credentials. So, where can we find them?</p>

<p>Well, first we need to know where to look. And in order to know where to look, we have to know how S3 is structured. Thankfully, S3&rsquo;s architecture is pretty simple to understand: everything is just contained in a bucket. We can name our bucket anything that we want, so long as it&rsquo;s a unique name across the Amazon system. A common convention is to name your bucket similarly to your application or repository&rsquo;s name (for example, <code>booklit-website</code>). Once we name our bucket, all of our files sent to S3 will be stored inside and belong to our bucket. An important thing to note is that <a href="http://stackoverflow.com/a/22173939">there are no directories</a> within a bucket; the S3 bucket itself is a top-level container.</p>

<p>Now, how can we access this unique bucket of ours? Using our credentials, of course! In order for us to access the S3 API, we need two things: an <strong>AWS Access Key ID</strong> and an <strong>AWS Secret Access Key</strong>. The access key id identifies our S3 user account, while the secret access key is our &ldquo;password&rdquo; (at least we should think of it as a password, it&rsquo;s a bit more complicated than that) for our account.</p>

<p>We can get these two pieces of information from the &ldquo;Security Credentials&rdquo; section of the AWS console menu when we log into our AWS account. But these keys aren&rsquo;t really helpful until we hook up our S3 bucket with our application. I suppose that&rsquo;s what we should do next!</p>

<h2>Keeping Secrets With <code>.env</code></h2>

<iframe src="//giphy.com/embed/12ROKMe0xvJilW" width="480" height="391" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>There&rsquo;s one golden rule when it comes to our credentials: we should <strong>never, <em>ever</em> store them in a file or commit them to source control</strong>. We never, ever want our credentials to be potentially exposed to anyone via our Github repository, and yet we definitely need our credentials to exist <em>somewhere</em> within our application, don&rsquo;t we? Otherwise we won&rsquo;t be able to tell <code>paperclip</code> where to upload our files and assets. Uh oh&hellip;what do?</p>

<p>Enter <strong>environment variables</strong> to the rescue! There are a few different ways to use environment variables in a Rails application to store our credentials without actually committing them into a file. My favorite way to do this is by creating a <code>.env</code> file in the top-level directory of my application (in our case, <code>booklit-website/.env</code>). Because this file has a <code>.</code> at the beginning, it&rsquo;s actually a hidden file and won&rsquo;t be committed. To double check that this is the case, we can open up our <code>.gitignore</code> file, and make sure that our <code>.env</code> file is included as one of the files that Git should &ldquo;ignore&rdquo; while committing:</p>

<pre><code># See https://help.github.com/articles/ignoring-files for more about ignoring files.

# Ignore Environment Configuration Files
config/database.yml
.env
</code></pre>

<p>This means that we can safely put our important AWS credentials inside of our <code>.env</code> file:</p>

<pre><code>AWS_ACCESS_KEY_ID=our-id-goes-here
AWS_SECRET_ACCESS_KEY=our-access-key-goes-here
AWS_S3_REGION=us-east-1
AWS_S3_BUCKET=booklit-website-bucket
</code></pre>

<p>In addition to the Access Key Id and Secret Access Key that we grabbed from our account information page on the AWS S3 portal, we also put in our S3 Region (the US East Coast), and our S3 Bucket Name (don&rsquo;t try to hack it because it is very much <em>not a real thing</em>).</p>

<p>Okay, this hidden file with our environment variables is cool and all, but how do we actually <em>retrieve</em> these variables? Well, it&rsquo;s actually pretty easy. We can treat the variables in our <code>.env</code> file like items in a hash; if we want to access the value of an item in a hash, we can just reference the value via its key, right? The same applies here. If we want to access our <code>AWS_S3_BUCKET</code> name, we can use <code>ENV['AWS_S3_BUCKET']</code> anywhere in our application in order to access it!</p>

<p>Awesome! We have just one last step before we can finally hook up all of these variables with <code>paperclip</code> and Heroku: we need to create an <code>.env.example</code> file! This is a pretty neat convention that I really liked the first time I saw it, and have since adopted. You&rsquo;ll remember that our <code>.env</code> file is being ignored by our <code>.gitignore</code> file whenever we commit our repository or push it up to Github. This is great, obviously, since we don&rsquo;t want our private credentials to ever be public. There is one downside, however: if someone clones our repository, they&rsquo;ll never know that we even <em>have</em> a <code>.env</code> file, much less what environment variables we have defined inside of it, which means that when they try to run our application or worse, when they try to collaborate with us on it, they&rsquo;ll hit a huge roadblock, and ruby will break and not know where to look while trying to read something like <code>ENV['AWS_S3_BUCKET']</code> from within the application.</p>

<p>There&rsquo;s a quick fix for this: create an &ldquo;example&rdquo; <code>.env</code> file called &ndash; you guessed it &ndash; <code>.env.example</code>. We should make sure that this does <em>not</em> get included in our <code>.gitignore</code> file. Instead, we want it to be committed with our repository. It&rsquo;s also important to note that we&rsquo;re still not going to include <em>our</em> credentials in here; instead, all we&rsquo;ll do is setup our <code>.env.example</code> file as an example of how someone else should create their <code>.env</code> file when they clone or fork our repository:</p>

<pre><code>AWS_ACCESS_KEY_ID=xxxxxx
AWS_SECRET_ACCESS_KEY=xxxxxx
AWS_S3_REGION=xxxxxx
AWS_S3_BUCKET=xxxxxx
</code></pre>

<p>Now that we&rsquo;ve finally got all these variables right where we want them, we can finally get to the good stuff!</p>

<h2>Configuring Paperclip And Heroku</h2>

<p>It may seem like we spent a lot of time setting things up, but it&rsquo;s all about to come together! We initially started off planning to use the <code>aws-sdk</code> gem. Now it&rsquo;s time to implement it in the context of the <code>paperclip</code> gem and configure it to work with our Heroku deploy.</p>

<p>First we&rsquo;ll add it to our <code>Gemfile</code> (<code>gem 'aws-sdk', '~&gt; 2'</code>) and then run <code>bundle install</code>. Now our <code>Gemfile</code> should have both <code>aws-sdk</code> and <code>paperclip</code>.</p>

<p>Next, we&rsquo;ll want to head over to where all the configurations for our <em>production</em> environment are &ndash; namely, our <code>production.rb</code> file, which exists inside of our <code>config/environments</code> directory. It&rsquo;s important to make sure that we&rsquo;re not setting any Heroku configurations inside of our <code>development.rb</code> file, which only runs inside of our development environment. Since we know we&rsquo;ll be deploying only the production environment configurations to Heroku, all of our Heroku setup should always live inside of our production environment.</p>

<p>Inside of our <code>production.rb</code> file, we&rsquo;ll want to add the following configurations:</p>

<pre><code class="ruby">config.paperclip_defaults = {
  storage: :s3,
  s3_credentials: {
    bucket: ENV['AWS_S3_BUCKET'],
    access_key_id: ENV['AWS_ACCESS_KEY_ID'],
    secret_access_key: ENV['AWS_SECRET_ACCESS_KEY']
  }
}
</code></pre>

<p>These lines are how we specify <a href="https://devcenter.heroku.com/articles/paperclip-s3">AWS configuration variables</a> for our production environment. If we wanted to test whether we had set all this up properly, we could copy these lines into our <code>development.rb</code> and test out our S3 uploads on our local server.</p>

<p>Last, but certainly not least, we want to set these configurations up on Heroku. If we don&rsquo;t do this final step in the process, Heroku won&rsquo;t know where to look for our credentials, which means that it won&rsquo;t know where our images are being hosted when it looks inside of our <code>s3_credentials</code> hash!</p>

<p>If we haven&rsquo;t already, we&rsquo;ll want to create an application container on Heroku by running this command in the terminal:</p>

<pre><code>$ heroku create
</code></pre>

<p>And then we&rsquo;ll want to push our code to our Heroku container and run any pending migrations:</p>

<pre><code>$ git push heroku master
$ heroku rake db:migrate
</code></pre>

<p>These first two steps are only necessary if we&rsquo;ve never deployed to Heroku before. If we have, then all we really need to do is set our AWS S3 configuration variables:</p>

<pre><code>$ heroku config:set S3_BUCKET_NAME=our_bucket_name
$ heroku config:set AWS_ACCESS_KEY_ID=our_access_key_id
$ heroku config:set AWS_SECRET_ACCESS_KEY=our_secret_access_key
</code></pre>

<p>Now the moment of truth: we can run <code>heroku open</code> and see&hellip;all of our images live! Next time someone tells us we have to figure out how to safely store our assets, we&rsquo;ll know that it ain&rsquo;t no thing. We got this.</p>

<iframe src="//giphy.com/embed/A4HCrFVdbxZpS" width="480" height="284" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>Environment variables are how we can store our secret credentials; they live inside of the <code>.env</code> file and should never be committed to source control! Want to read more about env variables in Rails? Check out this great <a href="http://bayendor.github.io/blog/2015/01/16/managing-rails-environment-variables/">blog post</a> and this super <a href="http://railsapps.github.io/rails-environment-variables.html">informative tutorial</a>.</li>
<li>The <code>aws-sdk</code> gem is an easy way to integrate <code>paperclip</code> and AWS S3. You can dive into the gem&rsquo;s <a href="https://github.com/aws/aws-sdk-ruby">source code</a> to learn more!</li>
<li>Heroku has some fantastic guides on how to <a href="https://devcenter.heroku.com/articles/s3#s3-setup">set up S3</a> and how to upload files to S3 <a href="https://devcenter.heroku.com/articles/paperclip-s3">using paperclip</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clipping Images for Rails: Using Paperclip]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/07/28/clipping-images-for-rails-using-paperclip/"/>
    <updated>2015-07-28T08:42:36-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/07/28/clipping-images-for-rails-using-paperclip</id>
    <content type="html"><![CDATA[<p><img src="http://www.officemuseum.com/1894_Gem_Paper_Clip_adv_discovered_by_The_Early_Office_Museum.JPG" style="display: block; margin-left: auto; margin-right: auto;"/></p>

<p>They say that a picture is worth a thousand words. How they came up with a such a nice, conveniently specific number number I&rsquo;ll never know. But what I do know is that everything on the web is just data floating around in cyberspace. And when I say everything, I really do mean <em>everything</em> &ndash; including pictures!</p>

<p>I&rsquo;ve worked on a few different projects that have required building out an interface to allow a user or an admin to upload images. The first time that I had to do this, I knew that there were a few different Rails gems out there to help make this magic happen. But I didn&rsquo;t really understand what was going on when I implemented these gems the first time around. To be quite honest, the first time I had to implement file uploading, I just followed the setup steps rather blindly. Now that I&rsquo;ve had to solve the same problem multiple times, however, I feel a bit more comfortable with the process.</p>

<p>There are a few different gems out there for handing file attachment in Rails, but my favorite one to use so far has been <strong>paperclip</strong>. Created by the super cool developers over at <a href="https://github.com/thoughtbot/paperclip">ThoughtBot</a>, the paperclip gem is fairly simple and straightforward to use. The reason that I like this gem in particular is that it fits seamlessly into the Rails framework. Files and attachments are treated just like an attribute on an ActiveRecord object, which makes the setup process both easy and intuitive. However, that doesn&rsquo;t mean that it&rsquo;s not intimidating at first! Luckily, we&rsquo;re going to walk through using the paperclip gem together.</p>

<!--more-->


<h2>How To Start Clipping</h2>

<iframe src="//giphy.com/embed/xXG9gNuwQcN1u" width="480" height="425" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Since <code>paperclip</code> is a gem, the first thing we&rsquo;ll have to do before we really get started on clipping anything is add it to our <code>Gemfile</code>:</p>

<p><code>gem "paperclip", "~&gt; 4.3"</code></p>

<p>and then <code>bundle install</code>, because it&rsquo;s what all the cool kids do. This is also a good time to make sure that we have <code>ImageMagick</code>, which is one of <code>paperclip</code>&rsquo;s dependencies. (We can always run <code>brew install imagemagick</code> to install it if we don&rsquo;t have it already.)</p>

<p>Now it&rsquo;s time to get clipping! And take a look at our schema, obvs. For our Bookstore app, we want each of our authors to have a headshot image uploaded and associated with their work. This is going to be super important from a user experience point of view, and it will be something that will be displayed on the show page of any given author.</p>

<p>There are two ways to go about actually adding an attachment to our model; one of them is is a bit easier because it generates a migration for you. But we&rsquo;ll go ahead and write our own migration to start.</p>

<p>We already have an <code>Author</code> model and migration. What we need to do is add an <code>attachment</code> column that&rsquo;ll handle everything from file uploading to associating a file with a specific <code>Author</code> object. So, we can just write a migration (<code>rails g migration AddProfileMediaToAuthors</code>) that will add an <code>attachment</code> column to our <code>Authors</code> table:</p>

<pre><code class="ruby">class AddProfileMediaToAuthors &lt; ActiveRecord::Migration
  def self.up
    add_attachment :authors, :profile_media
  end

  def self.down
    remove_attachment :authors, :profile_media
  end
end
</code></pre>

<p>We&rsquo;ll call our attachment columns <code>profile_media</code> to preemptively namespace the different types of attachments that we might have on a single <code>Author</code>&rsquo;s page. And just in case you needed a little refresher on the difference between the <code>up</code> and <code>down</code> methods, head <a href="http://vaidehijoshi.github.io/blog/2015/05/19/the-secret-life-of-your-database-part-1-migrations/">over here</a>.</p>

<p>Okay, now we&rsquo;ll run <code>rake db:migrate</code>, and take a look at our <code>schema.rb</code> file. Let&rsquo;s see what happened:</p>

<pre><code class="ruby">create_table "authors", force: :cascade do |t|
    t.string   "firstname"
    t.string   "lastname"
    t.datetime "created_at",         null: false
    t.datetime "updated_at",         null: false
    t.string   "profile_media_file_name"
    t.string   "profile_media_content_type"
    t.integer  "profile_media_file_size"
    t.datetime "profile_media_updated_at"
end
</code></pre>

<p>Interesting! So our <code>add_attachment</code> method actually did a lot of things for us, didn&rsquo;t it? That&rsquo;s because it&rsquo;s actually a helper method does a lot of important things that <code>paperclip</code> relies on:</p>

<ol>
<li>It adds a <code>file_name</code> for our attachment.</li>
<li>It adds a <code>content_type</code> for our attachments, which will be the <em>mime type</em> of our images.</li>
<li>It adds the <code>file_size</code> of our attachments.</li>
<li>It creates a <code>updated_at</code> column, which is particularly useful since we can order and sort our attachments/images by <code>datetime</code> format.</li>
</ol>


<p>Now we need to hook up our database migration with the corresponding model!</p>

<h2>Objects With Attached Files</h2>

<p><img src="http://2.bp.blogspot.com/_khdFP9RCQSw/TSPePSmnscI/AAAAAAAAAK4/My8FyIo8Xuo/s1600/a-jpeg-is-worth-approximately-a-thousand-words.gif" style="display: block; margin-left: auto; margin-right: auto;"/></p>

<p>Inside of our <code>Author</code> class, we need want to add one very important line to our model: <code>has_attached_file</code>. The important thing about this method is that it needs to correspond to whatever we named our attachment in our migrations from earlier. In our case, we called our attachments <code>profile_media</code>, so that&rsquo;s exactly what we&rsquo;ll use inside of our model as well:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
  has_attached_file :profile_media, 
    styles: { 
        large: "500x500", 
        medium: "300x300", 
        thumb: "100x100" 
    }, 
    default_url: "/images/:style/missing_profile_media.png"
end
</code></pre>

<p>This line sets up a few defaults for us and gives us the option of having a few different sizes for our <code>profile_media</code>. The <code>default_url</code> can be helpful if we ever want to give our attachment url a default and avoid an instance of <code>nil</code>. The sizes that we specify here are what we&rsquo;ll use inside of our views:</p>

<pre><code class="ruby">= link_to image_tag(author.profile_media.url(:thumb)), author.profile.url
</code></pre>

<p>But the most important part of making all of this work is, of course, permitting our media to be seen! (I&rsquo;m looking at you, strong params!). All we need to do is add our attachment name (<code>profile_media</code>) to our permitted parameters, which is already being used by our controller actions:</p>

<pre><code class="ruby">class AuthorsController &lt; ApplicationController
    def create
        author = Author.create(author_params)
    end

    private
      def author_params
        params.require(:author).permit(:firstname, :lastname, :profile_media)
      end
end
</code></pre>

<p>Pretty simple, right? But these are just the bare bones of <code>paperclip</code>. We can spice things up a bit, too!</p>

<h2>Validating And Customizing Our Clippings</h2>

<p>Once we have the gem up and working, it&rsquo;s super easy to add some bells and whistles and write it to fit our application&rsquo;s specific standards. The developers at ThoughtBot actually have several different validators that we can implement, including <code>AttachmentContentTypeValidator</code>, <code>AttachmentPresenceValidator</code>, and <code>AttachmentSizeValidator</code>. Personally, however, I prefer the old school helper methods, which function in exactly the same way.</p>

<p>Let&rsquo;s add a <code>validates_attachment_content_type</code> to our <code>Author</code> class, and validate that the content being uploaded is actually an <code>image</code>. We can do that with a nice regular expression:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
    has_attached_file :profile_media, 
        styles: { 
            large: "500x500", 
            medium: "300x300", 
            thumb: "100x100" 
        }, 
        default_url: "/images/:style/missing_profile_media.png"

    validates_attachment_content_type :profile_media, content_type: /\Aimage\/.*\Z/
end
</code></pre>

<p>We can also validate the size and presence of our attachment as well:</p>

<pre><code class="ruby">validates :profile_image, attachment_presence: :true

validates_attachment_size :profile_media, size: { in: 0..100.kilobytes }
</code></pre>

<p>And what about deleting attachments? Well, because <code>paperclip</code> is designed to work so well with ActiveRecord, any attachment we create is treated just like an attribute. As the documentation explains,</p>

<blockquote><p>The intent behind <code>paperclip</code> was to keep setup as easy as possible and to treat files as much like other attributes as possible. This means they aren&rsquo;t saved to their final locations on disk, nor are they deleted if set to nil, until ActiveRecord::Base#save is called. It manages validations based on size and presence, if required.</p></blockquote>

<p>Since the only way to delete an attachment is by setting the attribute to <code>nil</code>, there are a few different ways to actually go about deleting attachments. One implementation that I like to use is writing a custom method that checks whether an <code>Author</code> object has it&rsquo;s <code>profile_media</code> attribute equal to <code>nil</code> before saving it:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
    before_save :delete_profile_media, 
        if: -&gt; { remove_profile_media == '1' &amp;&amp; !profile_media_updated_at_changed? }

    attr_accessor :remove_profile_media

    private
        def delete_profile_media
            self.profile_media = nil
        end
end
</code></pre>

<p>In this structure, I also create an attribute on my <code>Author</code> object called <code>remove_profile_media</code>, which will either be <code>0</code> or <code>1</code>, based on whether a box on a form has been checked or not. If the button is checked, <code>remove_profile_media</code> will be set to <code>1</code>, and I&rsquo;ll call the <code>delete_profile_media</code> method in my <code>before_save</code> hook.</p>

<p>If deleting data is something that scares you (or if you&rsquo;re a fan of the <code>acts_as_paranoid</code> gem) there&rsquo;s also another option. You can just preserve your files along with your &ldquo;soft deleted&rdquo; models:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
    has_attached_file :profile_media, {
        preserve_files: "true",
    }
end
</code></pre>

<p>This extra line prevents any data in our <code>profile_media</code> columns from being completely erased when the model is soft deleted. The good news here is that when the object is restored later on, our images will be too! And that is just as good of a reason as any to celebrate!</p>

<iframe src="//giphy.com/embed/osMIREQbo3s2c" width="480" height="255" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>paperclip</code> gem really needs only two things to function properly: a <code>has_attached_file :attachment</code> in the model and an <code>attachment_file_name</code> column in the database. The <code>attachment_content_type</code> is only required if you&rsquo;re going to use content type validation.</li>
<li>If you want to see some <code>paperclip</code> in action, check out this <a href="http://railscasts.com/episodes/134-paperclip">RailsCast</a> that covers all the basics.</li>
<li>Want to dive into the <code>paperclip</code> source code? Go for it! Perhaps you can start by checking out their well-documented <a href="http://www.rubydoc.info/gems/paperclip/Paperclip/ClassMethods">class methods</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Taskmanaging Your App, Part 2: Service Objects]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/07/07/taskmanaging-your-app-part-2-service-objects/"/>
    <updated>2015-07-07T08:28:40-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/07/07/taskmanaging-your-app-part-2-service-objects</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/xTiTnqpyEF0HbAosfe" width="480" height="480" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Everything seems to perform a service these days. We&rsquo;ve got infrastructure as a service, platforms as a service, and even software as a service. But the servicing doesn&rsquo;t end there: even our software applications often need specific services provided to them. But how, exactly?</p>

<p>Well, if you&rsquo;ve ever opened up a Rails application and peeked inside of the main directories, you can get a good understanding of what exactly the application is doing. Pry into the models directory, and you&rsquo;ll see the kinds of objects the app transforms and manipulates. Open the controllers directory, and you&rsquo;ll see the different <em>CRUD</em> (<em>create, read, update, delete</em>) operations that are permitted by the application, and the various ways of handling requests and responses by the server.</p>

<p>Seems pretty straightforward, right? Except until your application starts to swell in size, and then you&rsquo;re packing a ton of functionality into these two directories. We at least <em>try</em> and keep our models fat, and our controllers skinny. It would be great if just our trying to do that was successful all the time. Yet that&rsquo;s not usually what happens. Instead, things start to get messy, code starts to leak out all over the place, and we all just want to give up and go home. But we don&rsquo;t have to give up just yet! There&rsquo;s one trick that we haven&rsquo;t tried yet, and it&rsquo;s guaranteed to make our lives easier: utilizing <strong>service objects</strong>. Or, in other words, servicing parts of our application and separating our code out into more appropriate places.</p>

<!--more-->


<h2>Separating All Dem Concerns</h2>

<p>Last week, we started off by learning about <a href="http://vaidehijoshi.github.io/blog/2015/06/30/taskmanaging-your-app-part-1-using-rake/">rake tasks</a>, which turned out be an awesome way of encapsulating a specific type of functionality into a single file. But when we started writing a <code>rake data:stage</code> task (which stages our database with some sample <code>Book</code> objects), we noticed that we were making a single rake task responsible for multiple things.</p>

<p>We&rsquo;ve got a similar dilemma on our hands again this week. We have a <code>WishLists Controller</code>, which should be responsible for rendering all of the <code>Wish Lists</code> associated with a <code>User</code>. But here&rsquo;s the kicker: it should work with the Goodreads API to pull in the books that the User wants to read, and add that to their <code>Wish List</code>. Here&rsquo;s our current, clean and beautiful controller:</p>

<pre><code class="ruby">class WishListsController &lt; ApplicationController
    def index
        if user_signed_in?
            render json: current_user.wish_lists
        else
            render json: { wish_lists: [] }
        end
    end
end
</code></pre>

<p>It really pains me to ruin this controller with all the logic we&rsquo;re about to throw in there. Let&rsquo;s start writing it and see how it might look&hellip;</p>

<pre><code class="ruby">class WishListsController &lt; ApplicationController
    def index
        if user_signed_in?
            client = Goodreads::Client.new(api_key: 'OUR_API_KEY', 
            api_secret: 'OUR_SECRET_TOKEN')
            shelf = client.shelf(current_user.id, 'to-read')
            books = shelf.books.each do |book|
                # Creates an ActiveRecord instance
                # for all the books on the shelf 
                # and returns a JSON object.
            end

            render json: books
        else
            render json: { wish_lists: [] }
        end
    end
end
</code></pre>

<p>NOPE. Nope nope nope. This is already way too much for a single controller action. And all the requests between our application and the Goodreads API really shouldn&rsquo;t be up publicly available &ndash; they need to be private methods. And what if something goes wrong during those requests? We aren&rsquo;t handling those errors at all! And honestly, it really shouldn&rsquo;t be the <code>index</code> action&rsquo;s job to send a request, handle the response, create and persist book objects, and then, on top of <em>all</em> of that, render the <code>books</code> of the <code>Wish List</code>! This is not the right path.</p>

<iframe src="//giphy.com/embed/srATnRQXsTfDG" width="480" height="269" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>What we really need to do is <strong>separate our concerns</strong>. Or, in other words, we need to divide and conquer our code. We know that the <code>index</code> action of our <code>WishLists Controller</code> shouldn&rsquo;t be responsible for all this work. So, let&rsquo;s delegate that task to someone else. In fact, let&rsquo;s create an object who&rsquo;s sole concern and single responsibility is going to be dealing importing books from the Goodreads API, persisting them to the database, and then returning an array of books to read in the form of a wish list.</p>

<p>This object doesn&rsquo;t need to do anything more than that. It&rsquo;s existence is purely to help us &ndash; and help the rest of our application &ndash; out. This object is just going to provide a service. In fact, we might even go so far as to call it a <em>service object</em> (see what I did there?).</p>

<h2>Servicing Our Application</h2>

<p>So, if this service object doesn&rsquo;t have any other responsibilities except for getting, creating, and persisting <code>books</code> to a <code>wish_list</code>, we have to ask ourselves: do we really need this object to stay around? Well, not really, no. All we really want is for this object to show up when we need it to, do it&rsquo;s job, and then conveniently disappear. This means that we don&rsquo;t need to make it an ActiveRecord object; instead, let&rsquo;s make it a Plain Old Ruby Object (remember those?).</p>

<p>We can start by either creating a <code>/services</code> directory on the top level and saving our <code>goodreads_importer.rb</code> service in there, or we can namespace it inside of our <code>/models</code> directory as <code>/goodreads/importer.rb</code>. Once we&rsquo;ve made our file, we can pretty much use the same code we started writing before, and abstract it out into this service object:</p>

<pre><code class="ruby">class GoodreadsImporter
    def initialize(options = {})
        @options = options
    end

    private 
    def client
        @client ||= Goodreads::Client.new(api_key: 
        'OUR_API_KEY', api_secret: 'OUR_SECRET_TOKEN')
    end

    def shelf(id, shelf_name)
        @shelf ||= client.shelf(current_user.id, shelf_name)
    end

    def books
        @books ||= shelf.books.each do |book|
            # Creates an ActiveRecord instance
            # for all the books on the shelf 
            # and returns a JSON object.
        end
    end
end
</code></pre>

<p>So far, we&rsquo;re just initializing our <code>Importer</code> with some options. Notice that we&rsquo;re <em>not</em> inheriting from <code>ActiveRecord::Base</code>! This is just a plain Ruby class, like the ones we used to make when we were first learning about things like <a href="http://vaidehijoshi.github.io/blog/2014/10/16/class-inheritance-part-1/">inheritance</a>.</p>

<p>We&rsquo;ve also abstracted out those API calls (<code>Client.new</code>) and the methods provided to us by the Goodreads API (<code>client.shelf</code>, <code>shelf.books</code>) into private methods that are only going to be accessible by this service object. Not only is this important because we don&rsquo;t want any other person or part of this application to be able to <em>access</em> these endpoints, but this is also going to be super helpful to us down the road. Now, if something goes wrong, we can narrow down exactly <em>where</em> in the process our application broke. And, we can write tests for specific parts of this service object, just to double and triple check that everything is working exactly as we expect it to.</p>

<p>Next, we&rsquo;ll want to actually have some point of entry for this object. In other words, we need a way to actually use this object &ndash; some way to access all those private methods that we wrote just above. A pretty cool convention for a service object&rsquo;s point of entry is a <code>call</code> method. The idea here is that you &ldquo;call&rdquo; upon the service object to show up, perform its job, and then don&rsquo;t worry about it after it&rsquo;s done.</p>

<p>This is what ours might look like:</p>

<pre><code class="ruby">class GoodreadsImporter
    def initialize(options = {})
        @options = options
    end

    def call
        books.each do |b|
            book = Book.where(id: b[:id]).first_or_initialize
            book.update(b)
      end
    end

    private 
    def client
        @client ||= Goodreads::Client.new(api_key: 
        'OUR_API_KEY', api_secret: 'OUR_SECRET_TOKEN')
    end

    def shelf(id, shelf_name)
        @shelf ||= client.shelf(current_user.id, shelf_name)
    end

    def books
        @books ||= shelf.books.each do |book|
            # Creates an ActiveRecord instance
            # for all the books on the shelf 
            # and returns a JSON object.
        end
    end
end
</code></pre>

<p>Pretty simple, right? Okay, so now we have this fantastic little service object. But it doesn&rsquo;t actually exist in our application yet. At no point are we &ldquo;calling&rdquo; upon our service! Time to fix that.</p>

<h2>Objects To Make Our Lives Easier</h2>

<p>Now that we have a service that we can rely upon, all we need to do is plug it into our application. We could do this inside of our <code>WishLists Controller</code>, just as we originally planned:</p>

<pre><code class="ruby">class WishListsController &lt; ApplicationController
    def index
        if user_signed_in?
            render json: current_user.wish_lists 
            if GoodreadsImporter.new.call(current_user.id, 'to-read')
        else
            render json: { wish_lists: [] }
        end
    end
end
</code></pre>

<p>Or we could also stick it into the rake task we were writing last week:</p>

<pre><code class="ruby">namespace :data do
    desc "Stages the environment with data from Goodreads."
    task "goodreads:import" =&gt; "environment" do
      options = {}
      GoodreadsImporter.new(options).call
    end
end
</code></pre>

<p>And now in development, we can just run <code>rake data:goodreads:import</code> to call upon our service object. Writing tests for this would be super easy as well, since we&rsquo;d literally only have to test this one Ruby class to make sure that the service object wasn&rsquo;t broken.</p>

<p>The coolest thing about service objects is that they exist on their own. They don&rsquo;t really need to know about what&rsquo;s going on around them (or even that they exist in the context of a giant framework called Rails!) You can just rely on pure Ruby code to make them work, and they&rsquo;ll do whatever they&rsquo;re supposed to do, whenever you need them to do it. I really liked <a href="http://blog.arkency.com/2013/09/services-what-they-are-and-why-we-need-them/">this blog post&rsquo;s</a> explanation of how they should work:</p>

<blockquote><p>Rails has multiple entry points. Every controller action in Rails is the entry point! Additionally, it handles a lot of responsibilities (parsing user input, routing logic [like redirects], logging, rendering… ouch!). That’s where service objects comes to play. Service objects encapsulates single process of our business. They take all collaborators (database, logging, external adapters like Facebook, user parameters) and performs a given process. Services belongs to our domain - They shouldn’t know they’re within Rails or web app!</p></blockquote>

<p>Even though it might seem like a lot of extra work in the moment, service objects can save you so much time and pain in the long run. And if you think about it, just like we need software as a service, our own code sometimes needs a service to do things for it. Cut your code some slack and help it out by creating a service object. You&rsquo;ll probably thank yourself down the road.</p>

<p><img src="https://imgs.xkcd.com/comics/the_general_problem.png" style="display: block; margin-left: auto; margin-right: auto;"></p>

<h2>tl;dr?</h2>

<ul>
<li>Service objects are POROs that you can use to encapsulate a specific piece of functionality, and can help you separate concerns in your application.</li>
<li>Still curious about the theory behind service objects in Rails applications? Check out <a href="https://blog.engineyard.com/2014/keeping-your-rails-controllers-dry-with-services">this tutorial</a> and this super helpful <a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">post</a>, which unpacks service objects in the context of refactoring.</li>
<li>Where else can you use a service object? Well, a lot of places! This <a href="http://brewhouse.io/blog/2014/04/30/gourmet-service-objects.html">blog post</a> has a ton of examples of how to use them throughout your application.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Taskmanaging Your App, Part 1: Using Rake]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/06/30/taskmanaging-your-app-part-1-using-rake/"/>
    <updated>2015-06-30T08:49:58-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/06/30/taskmanaging-your-app-part-1-using-rake</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/uRziFAtdD6H60" width="480" height="362" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Rake tasks: we&rsquo;ve all used &lsquo;em. From migrating our database to seeding it, we run commands using <code>rake</code> all of the time! But what actually happens when you run a rake task? And where is all this stuff defined, exactly? And how do you write a customized rake task of your very own?</p>

<p>These were the questions I was asking myself last week, when I had to write a rake task to stage some data for an application I was working on. I knew exactly what my rake task was supposed to accomplish, and I had a general idea of the code that had to live inside of it. I didn&rsquo;t quite know how to write my rake task, however. And I definitely didn&rsquo;t know what was going on inside of the Ruby interpreter when it would read my yet-to-exist task.</p>

<p>So, I set out to answer some of those questions, and learned a bit about how rake works in the process. It was an interesting rabbit hole to dive down, particularly since I had never before questioned what was happening when I ran a rake command in my command line. When you&rsquo;re first starting out with code, it&rsquo;s okay to accept some of the obfuscation that is inherently a part of the abstraction of larger applications. But you should never go too long without questioning why and how a certain thing works the way that it does. And that&rsquo;s exactly what we&rsquo;ll do with our beloved rake commands.</p>

<!--more-->


<h2>Form And Function</h2>

<p>We use the <code>rake</code> command so often that it might be easy to forget that it&rsquo;s <em>actually</em> part of a gem! Most everything we use &ndash; including that little gem called <code>rails</code> &ndash; relies on the <code>rake</code> gem as a dependency. And everything we could ever want to know about <code>rake</code>&rsquo;s form and function can be found in a single place: the <code>Rakefile</code>, a top-level file that exists in any application that uses this gem to manage and run tasks of all kinds.</p>

<p>So what&rsquo;s inside of our <code>Rakefile</code> after we generate a brand new Rails application? Something that looks like this:</p>

<pre><code class="ruby"># Add your own tasks in files placed in lib/tasks ending in .rake,
# for example lib/tasks/capistrano.rake, and they will automatically be available to Rake.

require File.expand_path('../config/application', __FILE__)

Rails.application.load_tasks
</code></pre>

<p>Pretty empty, right? Except that there&rsquo;s a pretty important line in there at the end which invokes a <code>load_tasks</code> method on our application object, which is what allows rake to load tasks into our application itself. But how do we fill up this Rakefile with some awesome rake tasks? Well, if we read carefully, it seems like <code>rake</code> is telling us exactly what we need to do.</p>

<p>Let&rsquo;s start by creating a data staging task that will load some initial data into our application so that we have something to work with while in development. We&rsquo;ll create a <code>stage_data.rake</code> file nested inside of our <code>lib/tasks</code> directories. But that&rsquo;s empty too! You know what that means, don&rsquo;t you? Time to write some tasks.</p>

<h2>Managing Our Task Management</h2>

<iframe src="//giphy.com/embed/gw3woz6oWXK48iE8" width="480" height="432" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Since we&rsquo;re working within the context of a mid-size Rails application, the first thing we probably want to do is namespace our rake tasks. We can do that a namespace block:</p>

<pre><code class="ruby">namespace :data do
end
</code></pre>

<p>This is how we can break up all the tasks that are concerned with managing data. But for now, let&rsquo;s just work on writing a single task, which will stage our development environment with some sample data to help us while we&rsquo;re building out the front end later on.</p>

<p>In order to write our rake task, we really just need two things: a description and then a <code>task</code> block. We know what we want our task to do, so that&rsquo;s what we&rsquo;ll put in our description. What we write here will be mostly to help us later on, when we want to know what tasks are available to us, and what exactly they do.</p>

<p>We&rsquo;ll also want to specify any dependencies that this task might have.</p>

<p>After the <code>desc</code> term, we&rsquo;re describing what our task will do, and then setting the command that we&rsquo;ll use to run the task itself. We&rsquo;re also specifying any dependencies that this task might have. In our case, the only thing that this task <em>depends upon</em> is the application itself. So, we want to make sure that our entire Rails application is loaded before running this task:</p>

<pre><code class="ruby">namespace :data do
    desc "Stage environment with sample data."
    task stage: :environment do
    end
end
</code></pre>

<p>Interestingly, all that&rsquo;s happening here is that a method called <code>task</code> is being invoked, and the key-value pair that we provided it (<code>stage: :environment</code>) is telling <code>task</code> exactly which other methods to execute before running the subsequent task we have defined inside of the block. I like how <a href="http://tutorials.jumpstartlab.com/topics/systems/automation.html">this tutorial</a> explains what&rsquo;s going on behind the scenes:</p>

<blockquote><p>It starts with the task method which takes a hash parameter. The key will be the name of the task. The value stored under that key, here <code>:environment</code>, indicates which other Rake tasks should be run before this task is run. Think of them like dependencies. When your task depends on <code>:environment</code>, it will load your entire Rails application. If your task doesn’t actually need Rails, don’t depend on :environment and you can greatly increase startup time and decrease memory usage.</p></blockquote>

<p>Another cool thing to keep in mind is the description. We know that our task description (after the <code>desc</code>) will show up again at some point. But when, exactly? Well, it comes into play when we run the <code>rake -T</code> command, which lists out all the tasks available to our specific application:</p>

<pre><code class="ruby">♥ rake -T
rake data:stage          # Stage environment with sample data.
</code></pre>

<p>Cool! Whatever we write in our description is exactly what will be output if and when this command is run in the future. Now, how do we get this task to create some sample data every time it&rsquo;s run? Well, we&rsquo;ll want to use ActiveRecord in order to actually persist some objects to our database. There&rsquo;s a handy block method on <code>ActiveRecord::Base</code> that does exactly this:</p>

<pre><code class="ruby">namespace :data do
    desc "Stage environment with sample data."
    task stage: :environment do
        ActiveRecord::Base.transaction do
            poetry = Genre.create!(name: 'Poetry')

            POETRY_SUBGENRES = ['lyric', 'drama', 'epic']

            POETRY_SUBGENRES.each do |genre|
                SubGenre.create!(sub_genre: genre, parent_genre: poetry)
            end
        end
    end
end
</code></pre>

<p>Nice! We&rsquo;re creating a genre and some sub genres, and associating them together. We could also add in authors and books to make this task a bit more robust. And to get really fancy, we could import a csv of all this information if it lived somewhere else!</p>

<h2>Extending Our Tasks Further</h2>

<p>Now that we know how to structure our rake tasks, we can add more tasks into the very same file. In fact, we can take advantage of the namespacing that we set up early on right now! Let&rsquo;s create a <code>rake data:reset</code> task that will work almost the same as the task we wrote above. The only difference being that this task will destroy any data that was staged (or any that might be hanging around, for some strange reason).</p>

<p>We can write that task inside of our same file, inside of our namespace:</p>

<pre><code class="ruby">namespace :data do
    desc "Stage environment with sample data."
    task stage: :environment do
        # the task we just wrote lives here!
    end

    desc "Resets and clears all the sample data."
    task reset: :environment do
      ActiveRecord::Base.transaction do
        Genre.destroy_all
        SubGenre.destroy_all
      end
    end
end
</code></pre>

<p>All we&rsquo;re doing is using the handy methods that ActiveRecord gives us for free inside of the blocks we&rsquo;ve defined in our task. And now when we run <code>rake -T</code>, we&rsquo;ll see this:</p>

<pre><code class="ruby">♥ rake -T
rake data:stage          # Stage environment with sample data.
rake data:reset          # Resets and clears all the sample data.
</code></pre>

<p>Look at us! We&rsquo;re rake task writing masters! We could get even fancier and make one task <em>depend upon</em> the other. Remember how the block syntax with the <code>task</code> method works? We can use the form of that syntax to make our task function the way we want to:</p>

<pre><code class="ruby">namespace :data do
    desc "Resets and stages the environment with sample data."
    task stage: [:environment, :reset] do
        # the task we wrote lives here!
    end
end
</code></pre>

<p>Now, we&rsquo;re specifying that not only should the <code>task</code> method load the environment, but it should also run the <code>rake data:reset</code> task before running the <code>rake data:stage</code> task! This could be super useful in development, when you don&rsquo;t want to have your database filled with duplicate data.</p>

<p>Another fun thing we could do is pass in parameters to our rake task:</p>

<pre><code class="ruby">namespace :data do
  desc "Stages the environment with specific amount of sample book data."
  task create_books: [:books_to_create] :environment do
    number_of_books = args[:books_to_create]
    # Uses the books_to_create variable to
    # create the number of books we want.
  end
end
</code></pre>

<p>Now, when we call the <code>rake data:create_books[100]</code> method, we could have our rake task generate 100 books for us based on the input argument we provided it.</p>

<p>This is pretty fun, right? We could put a ton of tasks that do all sorts of application management for us, and it would be no problem. Except that it would be, and here&rsquo;s why: we never want too much logic in one single part of our application. In other words, we want to separate out what different sections of application are concerned with. We probably could abstract out a lot of what these tasks into something else (another object?), which would help keep our rake tasks nice and lean.</p>

<p>It turns out that this is a pretty common situation to run into, and not just with rake tasks! There&rsquo;s a really cool pattern that implements a special kind of object that performs a service for you so that your code can stay simple, without too much logic in it. These objects are called <em>service objects</em>, and until I saw them in some production-level code, I had never really thought about their purpose. Tune in again next week, when I&rsquo;ll dive into service objects and how they help us serparate concerns in our code. Until then, here&rsquo;s a rake-themed gif to tide you over:</p>

<iframe src="//giphy.com/embed/5xtDarAX9eDPODdPMoo" width="480" height="480" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>Rake tasks are just Ruby code written inside of a either a <code>.rake</code> file in the <code>/app/tasks</code> directory, or sometimes within a <code>Rakefile</code> itself.</li>
<li>A rake task needs a description and a <code>task</code> block. The description is what will be seen when you run <code>rake -T</code>, and the <code>task</code> block is where you&rsquo;ll write what the task actually has to do, and specify any dependencies.</li>
<li>Need to see another example of how to make a rake task? Check out this awesome <a href="http://jasonseifer.com/2010/04/06/rake-tutorial">tutorial on rake</a>, or watch <a href="http://railscasts.com/episodes/66-custom-rake-tasks">this RailsCast</a>.</li>
</ul>

]]></content>
  </entry>
  
</feed>
