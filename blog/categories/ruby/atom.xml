<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-07-27T21:33:17-04:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clipping Images for Rails: Using Paperclip]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/07/28/clipping-images-for-rails-using-paperclip/"/>
    <updated>2015-07-28T08:42:36-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/07/28/clipping-images-for-rails-using-paperclip</id>
    <content type="html"><![CDATA[<p><img src="http://www.officemuseum.com/1894_Gem_Paper_Clip_adv_discovered_by_The_Early_Office_Museum.JPG" style="display: block; margin-left: auto; margin-right: auto;"/></p>

<p>They say that a picture is worth a thousand words. How they came up with a such a nice, conveniently specific number number I&rsquo;ll never know. But what I do know is that everything on the web is just data floating around in cyberspace. And when I say everything, I really do mean <em>everything</em> &ndash; including pictures!</p>

<p>I&rsquo;ve worked on a few different projects that have required building out an interface to allow a user or an admin to upload images. The first time that I had to do this, I knew that there were a few different Rails gems out there to help make this magic happen. But I didn&rsquo;t really understand what was going on when I implemented these gems the first time around. To be quite honest, the first time I had to implement file uploading, I just followed the setup steps rather blindly. Now that I&rsquo;ve had to solve the same problem multiple times, however, I feel a bit more comfortable with the process.</p>

<p>There are a few different gems out there for handing file attachment in Rails, but my favorite one to use so far has been <strong>paperclip</strong>. Created by the super cool developers over at <a href="https://github.com/thoughtbot/paperclip">ThoughtBot</a>, the paperclip gem is fairly simple and straightforward to use. The reason that I like this gem in particular is that it fits seamlessly into the Rails framework. Files and attachments are treated just like an attribute on an ActiveRecord object, which makes the setup process both easy and intuitive. However, that doesn&rsquo;t mean that it&rsquo;s not intimidating at first! Luckily, we&rsquo;re going to walk through using the paperclip gem together.</p>

<!--more-->


<h2>How To Start Clipping</h2>

<iframe src="//giphy.com/embed/xXG9gNuwQcN1u" width="480" height="425" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Since <code>paperclip</code> is a gem, the first thing we&rsquo;ll have to do before we really get started on clipping anything is add it to our <code>Gemfile</code>:</p>

<p><code>gem "paperclip", "~&gt; 4.3"</code></p>

<p>and then <code>bundle install</code>, because it&rsquo;s what all the cool kids do. This is also a good time to make sure that we have <code>ImageMagick</code>, which is one of <code>paperclip</code>&rsquo;s dependencies. (We can always run <code>brew install imagemagick</code> to install it if we don&rsquo;t have it already.)</p>

<p>Now it&rsquo;s time to get clipping! And take a look at our schema, obvs. For our Bookstore app, we want each of our authors to have a headshot image uploaded and associated with their work. This is going to be super important from a user experience point of view, and it will be something that will be displayed on the show page of any given author.</p>

<p>There are two ways to go about actually adding an attachment to our model; one of them is is a bit easier because it generates a migration for you. But we&rsquo;ll go ahead and write our own migration to start.</p>

<p>We already have an <code>Author</code> model and migration. What we need to do is add an <code>attachment</code> column that&rsquo;ll handle everything from file uploading to associating a file with a specific <code>Author</code> object. So, we can just write a migration (<code>rails g migration AddProfileMediaToAuthors</code>) that will add an <code>attachment</code> column to our <code>Authors</code> table:</p>

<pre><code class="ruby">class AddProfileMediaToAuthors &lt; ActiveRecord::Migration
  def self.up
    add_attachment :authors, :profile_media
  end

  def self.down
    remove_attachment :authors, :profile_media
  end
end
</code></pre>

<p>We&rsquo;ll call our attachment columns <code>profile_media</code> to preemptively namespace the different types of attachments that we might have on a single <code>Author</code>&rsquo;s page. And just in case you needed a little refresher on the difference between the <code>up</code> and <code>down</code> methods, head <a href="http://vaidehijoshi.github.io/blog/2015/05/19/the-secret-life-of-your-database-part-1-migrations/">over here</a>.</p>

<p>Okay, now we&rsquo;ll run <code>rake db:migrate</code>, and take a look at our <code>schema.rb</code> file. Let&rsquo;s see what happened:</p>

<pre><code class="ruby">create_table "authors", force: :cascade do |t|
    t.string   "firstname"
    t.string   "lastname"
    t.datetime "created_at",         null: false
    t.datetime "updated_at",         null: false
    t.string   "profile_media_file_name"
    t.string   "profile_media_content_type"
    t.integer  "profile_media_file_size"
    t.datetime "profile_media_updated_at"
end
</code></pre>

<p>Interesting! So our <code>add_attachment</code> method actually did a lot of things for us, didn&rsquo;t it? That&rsquo;s because it&rsquo;s actually a helper method does a lot of important things that <code>paperclip</code> relies on:</p>

<ol>
<li>It adds a <code>file_name</code> for our attachment.</li>
<li>It adds a <code>content_type</code> for our attachments, which will be the <em>mime type</em> of our images.</li>
<li>It adds the <code>file_size</code> of our attachments.</li>
<li>It creates a <code>updated_at</code> column, which is particularly useful since we can order and sort our attachments/images by <code>datetime</code> format.</li>
</ol>


<p>Now we need to hook up our database migration with the corresponding model!</p>

<h2>Objects With Attached Files</h2>

<p><img src="http://2.bp.blogspot.com/_khdFP9RCQSw/TSPePSmnscI/AAAAAAAAAK4/My8FyIo8Xuo/s1600/a-jpeg-is-worth-approximately-a-thousand-words.gif" style="display: block; margin-left: auto; margin-right: auto;"/></p>

<p>Inside of our <code>Author</code> class, we need want to add one very important line to our model: <code>has_attached_file</code>. The important thing about this method is that it needs to correspond to whatever we named our attachment in our migrations from earlier. In our case, we called our attachments <code>profile_media</code>, so that&rsquo;s exactly what we&rsquo;ll use inside of our model as well:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
  has_attached_file :profile_media, 
    styles: { 
        large: "500x500", 
        medium: "300x300", 
        thumb: "100x100" 
    }, 
    default_url: "/images/:style/missing_profile_media.png"
end
</code></pre>

<p>This line sets up a few defaults for us and gives us the option of having a few different sizes for our <code>profile_media</code>. The <code>default_url</code> can be helpful if we ever want to give our attachment url a default and avoid an instance of <code>nil</code>. The sizes that we specify here are what we&rsquo;ll use inside of our views:</p>

<pre><code class="ruby">= link_to image_tag(author.profile_media.url(:thumb)), author.profile.url
</code></pre>

<p>But the most important part of making all of this work is, of course, permitting our media to be seen! (I&rsquo;m looking at you, strong params!). All we need to do is add our attachment name (<code>profile_media</code>) to our permitted parameters, which is already being used by our controller actions:</p>

<pre><code class="ruby">class AuthorsController &lt; ApplicationController
    def create
        author = Author.create(author_params)
    end

    private
      def author_params
        params.require(:author).permit(:firstname, :lastname, :profile_media)
      end
end
</code></pre>

<p>Pretty simple, right? But these are just the bare bones of <code>paperclip</code>. We can spice things up a bit, too!</p>

<h2>Validating And Customizing Our Clippings</h2>

<p>Once we have the gem up and working, it&rsquo;s super easy to add some bells and whistles and write it to fit our application&rsquo;s specific standards. The developers at ThoughtBot actually have several different validators that we can implement, including <code>AttachmentContentTypeValidator</code>, <code>AttachmentPresenceValidator</code>, and <code>AttachmentSizeValidator</code>. Personally, however, I prefer the old school helper methods, which function in exactly the same way.</p>

<p>Let&rsquo;s add a <code>validates_attachment_content_type</code> to our <code>Author</code> class, and validate that the content being uploaded is actually an <code>image</code>. We can do that with a nice regular expression:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
    has_attached_file :profile_media, 
        styles: { 
            large: "500x500", 
            medium: "300x300", 
            thumb: "100x100" 
        }, 
        default_url: "/images/:style/missing_profile_media.png"

    validates_attachment_content_type :profile_media, content_type: /\Aimage\/.*\Z/
end
</code></pre>

<p>We can also validate the size and presence of our attachment as well:</p>

<pre><code class="ruby">validates :profile_image, attachment_presence: :true

validates_attachment_size :profile_media, size: { in: 0..100.kilobytes }
</code></pre>

<p>And what about deleting attachments? Well, because <code>paperclip</code> is designed to work so well with ActiveRecord, any attachment we create is treated just like an attribute. As the documentation explains,</p>

<blockquote><p>The intent behind <code>paperclip</code> was to keep setup as easy as possible and to treat files as much like other attributes as possible. This means they aren&rsquo;t saved to their final locations on disk, nor are they deleted if set to nil, until ActiveRecord::Base#save is called. It manages validations based on size and presence, if required.</p></blockquote>

<p>Since the only way to delete an attachment is by setting the attribute to <code>nil</code>, there are a few different ways to actually go about deleting attachments. One implementation that I like to use is writing a custom method that checks whether an <code>Author</code> object has it&rsquo;s <code>profile_media</code> attribute equal to <code>nil</code> before saving it:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
    before_save :delete_profile_media, 
        if: -&gt; { remove_profile_media == '1' &amp;&amp; !profile_media_updated_at_changed? }

    attr_accessor :remove_profile_media

    private
        def delete_profile_media
            self.profile_media = nil
        end
end
</code></pre>

<p>In this structure, I also create an attribute on my <code>Author</code> object called <code>remove_profile_media</code>, which will either be <code>0</code> or <code>1</code>, based on whether a box on a form has been checked or not. If the button is checked, <code>remove_profile_media</code> will be set to <code>1</code>, and I&rsquo;ll call the <code>delete_profile_media</code> method in my <code>before_save</code> hook.</p>

<p>If deleting data is something that scares you (or if you&rsquo;re a fan of the <code>acts_as_paranoid</code> gem) there&rsquo;s also another option. You can just preserve your files along with your &ldquo;soft deleted&rdquo; models:</p>

<pre><code class="ruby">class Author &lt; ActiveRecord::Base
    has_attached_file :profile_media, {
        preserve_files: "true",
    }
end
</code></pre>

<p>This extra line prevents any data in our <code>profile_media</code> columns from being completely erased when the model is soft deleted. The good news here is that when the object is restored later on, our images will be too! And that is just as good of a reason as any to celebrate!</p>

<iframe src="//giphy.com/embed/osMIREQbo3s2c" width="480" height="255" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>paperclip</code> gem really needs only two things to function properly: a <code>has_attached_file :attachment</code> in the model and an <code>attachment_file_name</code> column in the database. The <code>attachment_content_type</code> is only required if you&rsquo;re going to use content type validation.</li>
<li>If you want to see some <code>paperclip</code> in action, check out this <a href="http://railscasts.com/episodes/134-paperclip">RailsCast</a> that covers all the basics.</li>
<li>Want to dive into the <code>paperclip</code> source code? Go for it! Perhaps you can start by checking out their well-documented <a href="http://www.rubydoc.info/gems/paperclip/Paperclip/ClassMethods">class methods</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Taskmanaging Your App, Part 2: Service Objects]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/07/07/taskmanaging-your-app-part-2-service-objects/"/>
    <updated>2015-07-07T08:28:40-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/07/07/taskmanaging-your-app-part-2-service-objects</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/xTiTnqpyEF0HbAosfe" width="480" height="480" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Everything seems to perform a service these days. We&rsquo;ve got infrastructure as a service, platforms as a service, and even software as a service. But the servicing doesn&rsquo;t end there: even our software applications often need specific services provided to them. But how, exactly?</p>

<p>Well, if you&rsquo;ve ever opened up a Rails application and peeked inside of the main directories, you can get a good understanding of what exactly the application is doing. Pry into the models directory, and you&rsquo;ll see the kinds of objects the app transforms and manipulates. Open the controllers directory, and you&rsquo;ll see the different <em>CRUD</em> (<em>create, read, update, delete</em>) operations that are permitted by the application, and the various ways of handling requests and responses by the server.</p>

<p>Seems pretty straightforward, right? Except until your application starts to swell in size, and then you&rsquo;re packing a ton of functionality into these two directories. We at least <em>try</em> and keep our models fat, and our controllers skinny. It would be great if just our trying to do that was successful all the time. Yet that&rsquo;s not usually what happens. Instead, things start to get messy, code starts to leak out all over the place, and we all just want to give up and go home. But we don&rsquo;t have to give up just yet! There&rsquo;s one trick that we haven&rsquo;t tried yet, and it&rsquo;s guaranteed to make our lives easier: utilizing <strong>service objects</strong>. Or, in other words, servicing parts of our application and separating our code out into more appropriate places.</p>

<!--more-->


<h2>Separating All Dem Concerns</h2>

<p>Last week, we started off by learning about <a href="http://vaidehijoshi.github.io/blog/2015/06/30/taskmanaging-your-app-part-1-using-rake/">rake tasks</a>, which turned out be an awesome way of encapsulating a specific type of functionality into a single file. But when we started writing a <code>rake data:stage</code> task (which stages our database with some sample <code>Book</code> objects), we noticed that we were making a single rake task responsible for multiple things.</p>

<p>We&rsquo;ve got a similar dilemma on our hands again this week. We have a <code>WishLists Controller</code>, which should be responsible for rendering all of the <code>Wish Lists</code> associated with a <code>User</code>. But here&rsquo;s the kicker: it should work with the Goodreads API to pull in the books that the User wants to read, and add that to their <code>Wish List</code>. Here&rsquo;s our current, clean and beautiful controller:</p>

<pre><code class="ruby">class WishListsController &lt; ApplicationController
    def index
        if user_signed_in?
            render json: current_user.wish_lists
        else
            render json: { wish_lists: [] }
        end
    end
end
</code></pre>

<p>It really pains me to ruin this controller with all the logic we&rsquo;re about to throw in there. Let&rsquo;s start writing it and see how it might look&hellip;</p>

<pre><code class="ruby">class WishListsController &lt; ApplicationController
    def index
        if user_signed_in?
            client = Goodreads::Client.new(api_key: 'OUR_API_KEY', 
            api_secret: 'OUR_SECRET_TOKEN')
            shelf = client.shelf(current_user.id, 'to-read')
            books = shelf.books.each do |book|
                # Creates an ActiveRecord instance
                # for all the books on the shelf 
                # and returns a JSON object.
            end

            render json: books
        else
            render json: { wish_lists: [] }
        end
    end
end
</code></pre>

<p>NOPE. Nope nope nope. This is already way too much for a single controller action. And all the requests between our application and the Goodreads API really shouldn&rsquo;t be up publicly available &ndash; they need to be private methods. And what if something goes wrong during those requests? We aren&rsquo;t handling those errors at all! And honestly, it really shouldn&rsquo;t be the <code>index</code> action&rsquo;s job to send a request, handle the response, create and persist book objects, and then, on top of <em>all</em> of that, render the <code>books</code> of the <code>Wish List</code>! This is not the right path.</p>

<iframe src="//giphy.com/embed/srATnRQXsTfDG" width="480" height="269" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>What we really need to do is <strong>separate our concerns</strong>. Or, in other words, we need to divide and conquer our code. We know that the <code>index</code> action of our <code>WishLists Controller</code> shouldn&rsquo;t be responsible for all this work. So, let&rsquo;s delegate that task to someone else. In fact, let&rsquo;s create an object who&rsquo;s sole concern and single responsibility is going to be dealing importing books from the Goodreads API, persisting them to the database, and then returning an array of books to read in the form of a wish list.</p>

<p>This object doesn&rsquo;t need to do anything more than that. It&rsquo;s existence is purely to help us &ndash; and help the rest of our application &ndash; out. This object is just going to provide a service. In fact, we might even go so far as to call it a <em>service object</em> (see what I did there?).</p>

<h2>Servicing Our Application</h2>

<p>So, if this service object doesn&rsquo;t have any other responsibilities except for getting, creating, and persisting <code>books</code> to a <code>wish_list</code>, we have to ask ourselves: do we really need this object to stay around? Well, not really, no. All we really want is for this object to show up when we need it to, do it&rsquo;s job, and then conveniently disappear. This means that we don&rsquo;t need to make it an ActiveRecord object; instead, let&rsquo;s make it a Plain Old Ruby Object (remember those?).</p>

<p>We can start by either creating a <code>/services</code> directory on the top level and saving our <code>goodreads_importer.rb</code> service in there, or we can namespace it inside of our <code>/models</code> directory as <code>/goodreads/importer.rb</code>. Once we&rsquo;ve made our file, we can pretty much use the same code we started writing before, and abstract it out into this service object:</p>

<pre><code class="ruby">class GoodreadsImporter
    def initialize(options = {})
        @options = options
    end

    private 
    def client
        @client ||= Goodreads::Client.new(api_key: 
        'OUR_API_KEY', api_secret: 'OUR_SECRET_TOKEN')
    end

    def shelf(id, shelf_name)
        @shelf ||= client.shelf(current_user.id, shelf_name)
    end

    def books
        @books ||= shelf.books.each do |book|
            # Creates an ActiveRecord instance
            # for all the books on the shelf 
            # and returns a JSON object.
        end
    end
end
</code></pre>

<p>So far, we&rsquo;re just initializing our <code>Importer</code> with some options. Notice that we&rsquo;re <em>not</em> inheriting from <code>ActiveRecord::Base</code>! This is just a plain Ruby class, like the ones we used to make when we were first learning about things like <a href="http://vaidehijoshi.github.io/blog/2014/10/16/class-inheritance-part-1/">inheritance</a>.</p>

<p>We&rsquo;ve also abstracted out those API calls (<code>Client.new</code>) and the methods provided to us by the Goodreads API (<code>client.shelf</code>, <code>shelf.books</code>) into private methods that are only going to be accessible by this service object. Not only is this important because we don&rsquo;t want any other person or part of this application to be able to <em>access</em> these endpoints, but this is also going to be super helpful to us down the road. Now, if something goes wrong, we can narrow down exactly <em>where</em> in the process our application broke. And, we can write tests for specific parts of this service object, just to double and triple check that everything is working exactly as we expect it to.</p>

<p>Next, we&rsquo;ll want to actually have some point of entry for this object. In other words, we need a way to actually use this object &ndash; some way to access all those private methods that we wrote just above. A pretty cool convention for a service object&rsquo;s point of entry is a <code>call</code> method. The idea here is that you &ldquo;call&rdquo; upon the service object to show up, perform its job, and then don&rsquo;t worry about it after it&rsquo;s done.</p>

<p>This is what ours might look like:</p>

<pre><code class="ruby">class GoodreadsImporter
    def initialize(options = {})
        @options = options
    end

    def call
        books.each do |b|
            book = Book.where(id: b[:id]).first_or_initialize
            book.update(b)
      end
    end

    private 
    def client
        @client ||= Goodreads::Client.new(api_key: 
        'OUR_API_KEY', api_secret: 'OUR_SECRET_TOKEN')
    end

    def shelf(id, shelf_name)
        @shelf ||= client.shelf(current_user.id, shelf_name)
    end

    def books
        @books ||= shelf.books.each do |book|
            # Creates an ActiveRecord instance
            # for all the books on the shelf 
            # and returns a JSON object.
        end
    end
end
</code></pre>

<p>Pretty simple, right? Okay, so now we have this fantastic little service object. But it doesn&rsquo;t actually exist in our application yet. At no point are we &ldquo;calling&rdquo; upon our service! Time to fix that.</p>

<h2>Objects To Make Our Lives Easier</h2>

<p>Now that we have a service that we can rely upon, all we need to do is plug it into our application. We could do this inside of our <code>WishLists Controller</code>, just as we originally planned:</p>

<pre><code class="ruby">class WishListsController &lt; ApplicationController
    def index
        if user_signed_in?
            render json: current_user.wish_lists 
            if GoodreadsImporter.new.call(current_user.id, 'to-read')
        else
            render json: { wish_lists: [] }
        end
    end
end
</code></pre>

<p>Or we could also stick it into the rake task we were writing last week:</p>

<pre><code class="ruby">namespace :data do
    desc "Stages the environment with data from Goodreads."
    task "goodreads:import" =&gt; "environment" do
      options = {}
      GoodreadsImporter.new(options).call
    end
end
</code></pre>

<p>And now in development, we can just run <code>rake data:goodreads:import</code> to call upon our service object. Writing tests for this would be super easy as well, since we&rsquo;d literally only have to test this one Ruby class to make sure that the service object wasn&rsquo;t broken.</p>

<p>The coolest thing about service objects is that they exist on their own. They don&rsquo;t really need to know about what&rsquo;s going on around them (or even that they exist in the context of a giant framework called Rails!) You can just rely on pure Ruby code to make them work, and they&rsquo;ll do whatever they&rsquo;re supposed to do, whenever you need them to do it. I really liked <a href="http://blog.arkency.com/2013/09/services-what-they-are-and-why-we-need-them/">this blog post&rsquo;s</a> explanation of how they should work:</p>

<blockquote><p>Rails has multiple entry points. Every controller action in Rails is the entry point! Additionally, it handles a lot of responsibilities (parsing user input, routing logic [like redirects], logging, rendering… ouch!). That’s where service objects comes to play. Service objects encapsulates single process of our business. They take all collaborators (database, logging, external adapters like Facebook, user parameters) and performs a given process. Services belongs to our domain - They shouldn’t know they’re within Rails or web app!</p></blockquote>

<p>Even though it might seem like a lot of extra work in the moment, service objects can save you so much time and pain in the long run. And if you think about it, just like we need software as a service, our own code sometimes needs a service to do things for it. Cut your code some slack and help it out by creating a service object. You&rsquo;ll probably thank yourself down the road.</p>

<p><img src="https://imgs.xkcd.com/comics/the_general_problem.png" style="display: block; margin-left: auto; margin-right: auto;"></p>

<h2>tl;dr?</h2>

<ul>
<li>Service objects are POROs that you can use to encapsulate a specific piece of functionality, and can help you separate concerns in your application.</li>
<li>Still curious about the theory behind service objects in Rails applications? Check out <a href="https://blog.engineyard.com/2014/keeping-your-rails-controllers-dry-with-services">this tutorial</a> and this super helpful <a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">post</a>, which unpacks service objects in the context of refactoring.</li>
<li>Where else can you use a service object? Well, a lot of places! This <a href="http://brewhouse.io/blog/2014/04/30/gourmet-service-objects.html">blog post</a> has a ton of examples of how to use them throughout your application.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Taskmanaging Your App, Part 1: Using Rake]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/06/30/taskmanaging-your-app-part-1-using-rake/"/>
    <updated>2015-06-30T08:49:58-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/06/30/taskmanaging-your-app-part-1-using-rake</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/uRziFAtdD6H60" width="480" height="362" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Rake tasks: we&rsquo;ve all used &lsquo;em. From migrating our database to seeding it, we run commands using <code>rake</code> all of the time! But what actually happens when you run a rake task? And where is all this stuff defined, exactly? And how do you write a customized rake task of your very own?</p>

<p>These were the questions I was asking myself last week, when I had to write a rake task to stage some data for an application I was working on. I knew exactly what my rake task was supposed to accomplish, and I had a general idea of the code that had to live inside of it. I didn&rsquo;t quite know how to write my rake task, however. And I definitely didn&rsquo;t know what was going on inside of the Ruby interpreter when it would read my yet-to-exist task.</p>

<p>So, I set out to answer some of those questions, and learned a bit about how rake works in the process. It was an interesting rabbit hole to dive down, particularly since I had never before questioned what was happening when I ran a rake command in my command line. When you&rsquo;re first starting out with code, it&rsquo;s okay to accept some of the obfuscation that is inherently a part of the abstraction of larger applications. But you should never go too long without questioning why and how a certain thing works the way that it does. And that&rsquo;s exactly what we&rsquo;ll do with our beloved rake commands.</p>

<!--more-->


<h2>Form And Function</h2>

<p>We use the <code>rake</code> command so often that it might be easy to forget that it&rsquo;s <em>actually</em> part of a gem! Most everything we use &ndash; including that little gem called <code>rails</code> &ndash; relies on the <code>rake</code> gem as a dependency. And everything we could ever want to know about <code>rake</code>&rsquo;s form and function can be found in a single place: the <code>Rakefile</code>, a top-level file that exists in any application that uses this gem to manage and run tasks of all kinds.</p>

<p>So what&rsquo;s inside of our <code>Rakefile</code> after we generate a brand new Rails application? Something that looks like this:</p>

<pre><code class="ruby"># Add your own tasks in files placed in lib/tasks ending in .rake,
# for example lib/tasks/capistrano.rake, and they will automatically be available to Rake.

require File.expand_path('../config/application', __FILE__)

Rails.application.load_tasks
</code></pre>

<p>Pretty empty, right? Except that there&rsquo;s a pretty important line in there at the end which invokes a <code>load_tasks</code> method on our application object, which is what allows rake to load tasks into our application itself. But how do we fill up this Rakefile with some awesome rake tasks? Well, if we read carefully, it seems like <code>rake</code> is telling us exactly what we need to do.</p>

<p>Let&rsquo;s start by creating a data staging task that will load some initial data into our application so that we have something to work with while in development. We&rsquo;ll create a <code>stage_data.rake</code> file nested inside of our <code>lib/tasks</code> directories. But that&rsquo;s empty too! You know what that means, don&rsquo;t you? Time to write some tasks.</p>

<h2>Managing Our Task Management</h2>

<iframe src="//giphy.com/embed/gw3woz6oWXK48iE8" width="480" height="432" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Since we&rsquo;re working within the context of a mid-size Rails application, the first thing we probably want to do is namespace our rake tasks. We can do that a namespace block:</p>

<pre><code class="ruby">namespace :data do
end
</code></pre>

<p>This is how we can break up all the tasks that are concerned with managing data. But for now, let&rsquo;s just work on writing a single task, which will stage our development environment with some sample data to help us while we&rsquo;re building out the front end later on.</p>

<p>In order to write our rake task, we really just need two things: a description and then a <code>task</code> block. We know what we want our task to do, so that&rsquo;s what we&rsquo;ll put in our description. What we write here will be mostly to help us later on, when we want to know what tasks are available to us, and what exactly they do.</p>

<p>We&rsquo;ll also want to specify any dependencies that this task might have.</p>

<p>After the <code>desc</code> term, we&rsquo;re describing what our task will do, and then setting the command that we&rsquo;ll use to run the task itself. We&rsquo;re also specifying any dependencies that this task might have. In our case, the only thing that this task <em>depends upon</em> is the application itself. So, we want to make sure that our entire Rails application is loaded before running this task:</p>

<pre><code class="ruby">namespace :data do
    desc "Stage environment with sample data."
    task stage: :environment do
    end
end
</code></pre>

<p>Interestingly, all that&rsquo;s happening here is that a method called <code>task</code> is being invoked, and the key-value pair that we provided it (<code>stage: :environment</code>) is telling <code>task</code> exactly which other methods to execute before running the subsequent task we have defined inside of the block. I like how <a href="http://tutorials.jumpstartlab.com/topics/systems/automation.html">this tutorial</a> explains what&rsquo;s going on behind the scenes:</p>

<blockquote><p>It starts with the task method which takes a hash parameter. The key will be the name of the task. The value stored under that key, here <code>:environment</code>, indicates which other Rake tasks should be run before this task is run. Think of them like dependencies. When your task depends on <code>:environment</code>, it will load your entire Rails application. If your task doesn’t actually need Rails, don’t depend on :environment and you can greatly increase startup time and decrease memory usage.</p></blockquote>

<p>Another cool thing to keep in mind is the description. We know that our task description (after the <code>desc</code>) will show up again at some point. But when, exactly? Well, it comes into play when we run the <code>rake -T</code> command, which lists out all the tasks available to our specific application:</p>

<pre><code class="ruby">♥ rake -T
rake data:stage          # Stage environment with sample data.
</code></pre>

<p>Cool! Whatever we write in our description is exactly what will be output if and when this command is run in the future. Now, how do we get this task to create some sample data every time it&rsquo;s run? Well, we&rsquo;ll want to use ActiveRecord in order to actually persist some objects to our database. There&rsquo;s a handy block method on <code>ActiveRecord::Base</code> that does exactly this:</p>

<pre><code class="ruby">namespace :data do
    desc "Stage environment with sample data."
    task stage: :environment do
        ActiveRecord::Base.transaction do
            poetry = Genre.create!(name: 'Poetry')

            POETRY_SUBGENRES = ['lyric', 'drama', 'epic']

            POETRY_SUBGENRES.each do |genre|
                SubGenre.create!(sub_genre: genre, parent_genre: poetry)
            end
        end
    end
end
</code></pre>

<p>Nice! We&rsquo;re creating a genre and some sub genres, and associating them together. We could also add in authors and books to make this task a bit more robust. And to get really fancy, we could import a csv of all this information if it lived somewhere else!</p>

<h2>Extending Our Tasks Further</h2>

<p>Now that we know how to structure our rake tasks, we can add more tasks into the very same file. In fact, we can take advantage of the namespacing that we set up early on right now! Let&rsquo;s create a <code>rake data:reset</code> task that will work almost the same as the task we wrote above. The only difference being that this task will destroy any data that was staged (or any that might be hanging around, for some strange reason).</p>

<p>We can write that task inside of our same file, inside of our namespace:</p>

<pre><code class="ruby">namespace :data do
    desc "Stage environment with sample data."
    task stage: :environment do
        # the task we just wrote lives here!
    end

    desc "Resets and clears all the sample data."
    task reset: :environment do
      ActiveRecord::Base.transaction do
        Genre.destroy_all
        SubGenre.destroy_all
      end
    end
end
</code></pre>

<p>All we&rsquo;re doing is using the handy methods that ActiveRecord gives us for free inside of the blocks we&rsquo;ve defined in our task. And now when we run <code>rake -T</code>, we&rsquo;ll see this:</p>

<pre><code class="ruby">♥ rake -T
rake data:stage          # Stage environment with sample data.
rake data:reset          # Resets and clears all the sample data.
</code></pre>

<p>Look at us! We&rsquo;re rake task writing masters! We could get even fancier and make one task <em>depend upon</em> the other. Remember how the block syntax with the <code>task</code> method works? We can use the form of that syntax to make our task function the way we want to:</p>

<pre><code class="ruby">namespace :data do
    desc "Resets and stages the environment with sample data."
    task stage: [:environment, :reset] do
        # the task we wrote lives here!
    end
end
</code></pre>

<p>Now, we&rsquo;re specifying that not only should the <code>task</code> method load the environment, but it should also run the <code>rake data:reset</code> task before running the <code>rake data:stage</code> task! This could be super useful in development, when you don&rsquo;t want to have your database filled with duplicate data.</p>

<p>Another fun thing we could do is pass in parameters to our rake task:</p>

<pre><code class="ruby">namespace :data do
  desc "Stages the environment with specific amount of sample book data."
  task create_books: [:books_to_create] :environment do
    number_of_books = args[:books_to_create]
    # Uses the books_to_create variable to
    # create the number of books we want.
  end
end
</code></pre>

<p>Now, when we call the <code>rake data:create_books[100]</code> method, we could have our rake task generate 100 books for us based on the input argument we provided it.</p>

<p>This is pretty fun, right? We could put a ton of tasks that do all sorts of application management for us, and it would be no problem. Except that it would be, and here&rsquo;s why: we never want too much logic in one single part of our application. In other words, we want to separate out what different sections of application are concerned with. We probably could abstract out a lot of what these tasks into something else (another object?), which would help keep our rake tasks nice and lean.</p>

<p>It turns out that this is a pretty common situation to run into, and not just with rake tasks! There&rsquo;s a really cool pattern that implements a special kind of object that performs a service for you so that your code can stay simple, without too much logic in it. These objects are called <em>service objects</em>, and until I saw them in some production-level code, I had never really thought about their purpose. Tune in again next week, when I&rsquo;ll dive into service objects and how they help us serparate concerns in our code. Until then, here&rsquo;s a rake-themed gif to tide you over:</p>

<iframe src="//giphy.com/embed/5xtDarAX9eDPODdPMoo" width="480" height="480" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>Rake tasks are just Ruby code written inside of a either a <code>.rake</code> file in the <code>/app/tasks</code> directory, or sometimes within a <code>Rakefile</code> itself.</li>
<li>A rake task needs a description and a <code>task</code> block. The description is what will be seen when you run <code>rake -T</code>, and the <code>task</code> block is where you&rsquo;ll write what the task actually has to do, and specify any dependencies.</li>
<li>Need to see another example of how to make a rake task? Check out this awesome <a href="http://jasonseifer.com/2010/04/06/rake-tutorial">tutorial on rake</a>, or watch <a href="http://railscasts.com/episodes/66-custom-rake-tasks">this RailsCast</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[To Serialize or Not to Serialize: ActiveModel Serializers]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/06/23/to-serialize-or-not-to-serialize-activemodel-serializers/"/>
    <updated>2015-06-23T08:10:05-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/06/23/to-serialize-or-not-to-serialize-activemodel-serializers</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/WgTf8fPTjJZAI" width="480" height="270" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Lesson number one when it comes to developing for the web: everything is just data. When you send something to the server in a request, or when you get something back from the server as a response, all you&rsquo;re really dealing with is data. Simple enough to remember, right? Wrong. Because data can be complicated. Especially when you consider the fact that it has to be passed back and forth in very specific ways. And if you don&rsquo;t format your data correctly, your computer is going to be very, very mad at you (or probably just throw a really unhelpful error message).</p>

<p>I encountered the complications of data formatting the hard way, while trying to pass data between two parts of my application. I wanted to send some data to update a Ruby object in my Postgres database on the server-side, and then I wanted the Rails side to send back an updated response. As if that wasn&rsquo;t enough, I then needed the Ember front end to grab the updated data and immediately render it to the user on the client-side. Data formatting can already be complex when you have only one framework or language; throw in another framework and language, and, well&hellip;you might feel like you&rsquo;re having a little bit of a meltdown.</p>

<p>But fear not! Because here&rsquo;s one awesome thing about data: once you understand the way that it&rsquo;s structured, it&rsquo;s pretty simple to use. And when it comes to working on a more intricate Rails + JavaScript application (like the one I was building recently), there&rsquo;s one kind of data manipulation you&rsquo;re probably going to have to do at some point or another: data serialization. When working with a JavaScript front end, you&rsquo;ll probably have to serialize your data into a <strong>JSON format</strong>, which is short for <em>JavaScript Object Notation</em>. Thankfully, there&rsquo;s a handy gem that makes this so easy that you&rsquo;ll never again question whether or not to serialize your data.</p>

<!--more-->


<h2>Why Serialize?</h2>

<p>The time has finally come: it&rsquo;s time for us to spiff up our Bookstore application with some JavaScript. (I know, I know, it sounds horrible &ndash; but it&rsquo;ll be so good for our users, I promise). But let&rsquo;s start off simple and keep working with the Rails API we&rsquo;ve been building out.</p>

<p>Let&rsquo;s pretend for a second that we&rsquo;ve already implemented authentication in our application, which means we have access to the <code>current_user</code> who is logged in at the highest controller level of our application: the <code>ApplicationController</code>. In our <code>UsersController</code>, we want an <code>index</code> action that will be invoked when the <code>current_user</code> logs into their account page. On that page, we&rsquo;ll want to show the user&rsquo;s &ldquo;wish lists&rdquo;, or the list of books that they want to read. Each <code>WishList</code> object belongs to a <code>User</code> and has many <code>Books</code>, and a <code>Book</code> can belong to a <code>WishList</code>. Right now in our controller, we are rendering all the <code>WishLists</code> that are associated with the <code>current_user</code> as JSON:</p>

<pre><code class="ruby">class UsersController &lt; ApplicationController
  def index
    @wish_lists = current_user.wish_lists

    render json: @wish_lists
  end
end
</code></pre>

<p>Cool, we have our <code>WishLists</code> already rendered as JSON. Why serialize anything in that case? I&rsquo;m sure our JSON is structured perfectly well, and that we can convert our Ruby object data into Ember models seamlessly!</p>

<pre><code class="json">[
   {
      "id":43,
      "user":
        {
            "id": 1,
            "username": "Vaidehi"
        },
      "name":"Favorite Shakespeare Plays To Re-Read",
      "created_at":"2015-06-23T21:07:30.108Z",
      "updated_at":"2015-06-23T21:07:30.108Z",
      "books": 
        [
            {
                "id": 24,
                "title": "A Midsummer Night's Dream",
                "author": "William Shakespeare"
            },
            {
                "id": 48,
                "title": "The Tempest",
                "author": "William Shakespeare"
            },
            {
                "id": 13,
                "title": "Much Ado About Nothing",
                "author": "William Shakespeare"
            }
        ]
   }
]
</code></pre>

<p>Oh my. That is <em>definitely</em> not how we want our JSON to look!</p>

<iframe src="//giphy.com/embed/12mPcp41D9a1i0" width="480" height="274" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>For one thing, if we give this JSON to Ember, it won&rsquo;t know how to turn it into an Ember model. But there are also some other issues with exactly how this data is structured.</p>

<p>For now, we don&rsquo;t need to render anything to our user about when the created or updated their list, so that&rsquo;s some superfluous data that we shouldn&rsquo;t be requesting from the server.</p>

<p>We also don&rsquo;t want to render anything about our actual <code>User</code> object &ndash; we probably just want to include the <code>user_id</code>, and nothing else. And because we can load the correct <code>Book</code> models via Ember itself, let&rsquo;s not bother with requesting all the details of every <code>Book</code> in our <code>WishList</code>. Instead, let&rsquo;s just get an array of associated <code>book_ids</code>, and then have Ember render the appropriate ones for us from its data store.</p>

<p>So, to serialize or not to serialize? That is the question. And I think you and I both know the answer.</p>

<h2>ActiveModel Serializers</h2>

<p>Before we can get our serializing on, we&rsquo;ll need to add our new favorite gem to our <code>Gemfile</code>:</p>

<pre><code class="ruby">gem 'active_model_serializers'
</code></pre>

<p>and then run the <code>bundle</code> command.</p>

<p>Now, we&rsquo;ll want to actually create our serializer, which will work with Rails&#8217; ActiveModel functionality to serialize your persisted Ruby objects into the exact JSON format that we&rsquo;ll specify. Luckily, we can just generate our serializer instead of creating those files:</p>

<pre><code class="ruby">rails g serializer wishList
</code></pre>

<p>This will create a <code>serializers</code> directory inside of our top-level <code>/app</code> directory since this is the first serializer we&rsquo;ve generated. And it&rsquo;ll add both an empty <code>application_serializer</code> and a <code>wish_list_serializer.rb</code> file inside of that new directory, which looks like this:</p>

<pre><code class="ruby">class WishListSerializer &lt; ApplicationSerializer
  attributes :id, :name

  has_many :books
  belongs_to :user
end
</code></pre>

<p>The attributes that we&rsquo;ve listed (<code>id</code> and <code>name</code>) are the ones that are <em>whitelisted</em> to be serialized. This basically means that these are the attributes we are allowing the <code>active_model_serializers</code> gem to serialize and make into JSON. The serializer we generated through Rails also recognized the associations that we set up; it created the <code>has_many</code> and <code>belongs_to</code> relationships that we setup inside of our <code>Book</code>, <code>User</code>, and <code>WishList</code> Rails models.</p>

<p>Cool, but how can we check what our data structure looks like? Well, we can start our server (<code>rails server</code>) and then head over to where our index route lives (<code>http://localhost:3000/wish_list</code>). Our JSON response will be rendered through our <code>index</code> action in our <code>WishListsController</code>:</p>

<pre><code class="json">{
    "wish_lists":
        [
            {
                "id":43,
                "name":"Favorite Shakespeare Plays To Re-Read",
                "user":
                    {
                        "id": 1,
                        "username": "Vaidehi"
                    },
                "books":
                    [
                        {
                            "id": 24,
                            "title": "A Midsummer Night's Dream",
                            "author": "William Shakespeare"
                        },
                        {
                            "id": 48,
                            "title": "The Tempest",
                            "author": "William Shakespeare"
                        },
                        {
                            "id": 13,
                            "title": "Much Ado About Nothing",
                            "author": "William Shakespeare"
                        }
                    ]
            }
        ]
}
</code></pre>

<p>Well, our data looks a <em>little</em> bit better. For one thing, our whitelisted attributes and associations have been put under a <code>wish_lists</code> key, which will have an array of <code>WishList</code> objects for the <code>current_user</code>, just as we wrote out in our <code>WishListsController</code>.</p>

<p>Although it&rsquo;s great that this gem generated all this for us, and for free, we already know that we&rsquo;re going to have to tweak this a bit. First, let&rsquo;s get rid of that <code>belongs_to :user</code> line, and instead just render a <code>user_id</code> attribute:</p>

<pre><code class="ruby">class WishListSerializer &lt; ApplicationSerializer
  attributes :id, :name, :user_id

  has_many :books
end
</code></pre>

<p>Because we&rsquo;ve set up the associations in both models, the <code>active_model_serializer</code> will look directly for an <code>id</code> attribute on a <code>User</code> association, and add that as a key in our JSON object, rather than creating a <code>user</code> key that points to an entire JSON <code>User</code> object. What does our JSON object look like now?</p>

<pre><code class="json">{
    "wish_lists":
        [
            {
                "id":43,
                "name":"Favorite Shakespeare Plays To Re-Read",
                "user_id":1,
                "books":
                    [
                        {
                            "id": 24,
                            "title": "A Midsummer Night's Dream",
                            "author": "William Shakespeare"
                        },
                        {
                            "id": 48,
                            "title": "The Tempest",
                            "author": "William Shakespeare"
                        },
                        {
                            "id": 13,
                            "title": "Much Ado About Nothing",
                            "author": "William Shakespeare"
                        }
                    ]
            }
        ]
}
</code></pre>

<p>Okay, another step in the right direction. But, what about those annoying <code>Book</code> objects &ndash; how do we turn those objects into just an array of <code>book_ids</code>?</p>

<p>The answer is&hellip;through another serializer, of course! And also some snazzy customization.</p>

<h2>Customizing Your Serializer</h2>

<p>Before we can go about spicing up the JSON response generated by our <code>WishList Serializer</code>, we are going to have to generate a new serializer for our <code>Book</code> objects. Thank goodness we already know how to do all that:</p>

<pre><code class="ruby">rails g serializer book
</code></pre>

<p>which will generate a <code>book_serializer.rb</code> file like this:</p>

<pre><code class="ruby">class BookSerializer &lt; ApplicationSerializer
  attributes :id, :title, :author

  belongs_to :wish_list
end
</code></pre>

<p>Step one, successfully accomplished! Now, time to bedazzle our serializer. Let&rsquo;s say that the front end of our application doesn&rsquo;t need all that information &ndash; instead, it needs just an array of <code>book_ids</code>. We can just edit our serializer so that we&rsquo;re only using the information that we want to use:</p>

<pre><code class="ruby">class BookSerializer &lt; ApplicationSerializer
  attributes :id
end
</code></pre>

<p>Now comes step two: telling our <code>WishList Serializer</code> to refer to our <code>BookSerializer</code>, and use <em>that</em> to serialize each book associated with a wish list. If only there was an easy way to do that&hellip;</p>

<pre><code class="ruby">class WishListSerializer &lt; ApplicationSerializer
    attributes :id, :name, :user_id, :books

    private
    def books
        BookSerializer.new(object.books).attributes
    end
end
</code></pre>

<p>Oh, interesting! We&rsquo;ve just created our <em>very own</em> attribute on the <code>WishListSerializer</code>. And what does that method (which is private, because we don&rsquo;t wany any other part of our application to call it) do, exactly? Well, it creates a new instance of our <code>BookSerializer</code>, and runs that serializer for each <code>Book</code> object, returning the attributes that we told it to serializer.</p>

<p>What&rsquo;s really awesome about this is that if we suddenly decide that we now want not just an array of <code>ids</code>, but also the <code>title</code> of each <code>Book</code> object, we can just add that attribute into our <code>BookSerializer</code> by modifying the line to <code>attributes :id, :title</code>, and <em>tada</em>! We have an array of <code>Book</code> objects that have both an <code>id</code> <em>and</em> a <code>title</code>. So easy, right?!</p>

<p>The super cool thing about implementing serializers is that our <code>UsersController</code> hasn&rsquo;t changed at all in this process:</p>

<pre><code class="ruby">class UsersController &lt; ApplicationController
  def index
    @wish_lists = current_user.wish_lists

    render json: @wish_lists
  end
end
</code></pre>

<p>All that&rsquo;s happening now is that Rails is looking for a serializer for our <code>WishList</code> objects on the <code>current_user</code>, and if it finds one (which it will, since we made it!), it uses that to serialize the appropriate data and render it into a JSON format.</p>

<p>Serializers are pretty fantastic because they&rsquo;re easy to generate, customize, and use. In fact, we could even create multiple serializer for the same <em>type</em> of object. We could have a <code>BookDetails Serializer</code>, which might return a ton of information about a book, rather than just its <code>id</code> and <code>title</code>. All we&rsquo;d have to do to use it is specify the serializer within our controller action:</p>

<pre><code class="ruby">render json: @books, each_serializer: BookDetailsSerializer
</code></pre>

<p>Pretty amazing stuff, right? This will make integrating our JavaScript front end with our Rails API so much easier. We can serialize all of the things! And then we should probably teach this doggy how to serialize things, too. He&rsquo;s probably confused because he hasn&rsquo;t read this blog post yet:</p>

<iframe src="//giphy.com/embed/xDQ3Oql1BN54c" width="480" height="332" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>active_model_serializers</code> gem provides a ton of functionality for structuring a JSON response from your Rails API. Read about all the methods it provides in its <a href="https://github.com/rails-api/active_model_serializers">great documenation</a>.</li>
<li>Still curious about serializers? Check out <a href="https://robots.thoughtbot.com/better-serialization-less-as-json">this cool post</a> and <a href="https://blog.engineyard.com/2015/active-model-serializers">this one</a>, too!</li>
<li>Serializers are also great for caching. To learn more about why they matter, read this <a href="https://robots.thoughtbot.com/fast-json-apis-in-rails-with-key-based-caches-and">more advanced</a> blog post!</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Baby's First Conference: Recapping RedDotRubyConf]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/06/16/babys-first-conference-recapping-reddotrubyconf/"/>
    <updated>2015-06-16T08:29:28-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/06/16/babys-first-conference-recapping-reddotrubyconf</id>
    <content type="html"><![CDATA[<iframe src="https://www.flickr.com/photos/reddotrubyconf/18777106586/in/photostream/player/" width="500" height="333" frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>A week ago, I was on a code overload in Singapore. What was I doing on the other side of the world? Why, giving (and attending!) my very first talk at a Ruby conference, of course!</p>

<p>I was lucky enough to join some serious Ruby powerhouses at the <a href="reddotrubyconf.com">Red Dot Ruby Conference</a> earlier this month. And it was such a cool first conference experience. But, because I had to give a talk, I was pretty preoccupied with writing my speech and creating some fun slides to accompany it. What I forgot in the process was that I would be an audience member at the conference, too! (Pretty silly, I know).</p>

<p>My lightning talk was <a href="http://confreaks.tv/videos/rdrc2015-lightning-talk-refactoring-of-self">just a few minutes</a>, which meant that for the majority of the two-day conference, I had the unique opportunity to listen to some really fantastic talks. And I learned <em>so much</em>. I also got to meet some interesting, talented, and creative people who have made some very significant and core contributions to the Ruby and Rails communities and codebases. Summing up everything that happened in those two days is a bit difficult since every talk was informative in many ways. But I&rsquo;ll recap at least some of the dopest things I learned about while I was there. But if you want the full effect, you should probably <a href="http://i.ytimg.com/vi/_kRtkrBumBw/maxresdefault.jpg">eat a durian</a> while reading this post &ndash; just sayin&#8217;.</p>

<!--more-->


<h2>Your Code Is Not Just Yours</h2>

<p>One of the first talks of the conference focused on something I pretty much knew nothing about: security. André Arko&rsquo;s talk, <em>Security Is Hard, But We Can&rsquo;t Go Shopping</em> was an eye-opening look at why Ruby developers don&rsquo;t think (or talk) about security vulnerabilities in their codebases &ndash; and why we all <em>should</em> be having that conversation.</p>

<p>André&rsquo;s talk definitely caught my attention when he gave an example of a company that went out of business in a day because they lost <em>all</em> of their data because their severs were hacked. Yes, you read that right: lost all their data, shut down in a day. Pretty terrifying, right?</p>

<div style="text-align:center">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/eHmXar6TNUo?showinfo=0" frameborder="0" allowfullscreen></iframe><br>
</div>


<p>There were three big takeaways for me from this talk:</p>

<h4><strong>1. Updating is insurance</strong></h4>

<p>We&rsquo;ve all looked at our code and seen deprecation warnings, or things that are out of date and need to be updated to the latest version. And, we&rsquo;ve all, at some point, ignored those warnings. It&rsquo;s really easy to think about shipping your code quickly and iterating fast, particularly because updating things is <em>not</em> fun. And no one wants to do it.</p>

<p>But, you know what&rsquo;s worse? Your entire app blowing up because you had a vulnerability exposed in your code because you didn&rsquo;t update! If we all started thinking about updating as <em>insurance</em>, we&rsquo;d be more willing to sit down and put in the time to make sure all aspects of our applications were updated and thus, at the lowest possible level of security risk. This shift in perspective also seems like the best way to pitch &ldquo;updating&rdquo; as a task to project managers who might not see the time value in something like upgrading an already-functioning application.</p>

<h4>2. <strong>Responsible disclosure</strong></h4>

<p>If you find a security vulnerability, be nice about it. Don&rsquo;t be a jerk, man. Sometimes, you can even get a reward for disclosing! Figure out what the process is for disclosing a security issue to a company, and be empathetic to the developers who wrote that code which you&rsquo;re using &ndash; who knows, maybe one day there&rsquo;ll be a vulnerability in your code, and you&rsquo;ll wish you had been nicer to <em>those</em> developers.</p>

<h4>3. <strong>There are users, there are abusers</strong></h4>

<p>As a young developer, you can think about who is using your code. Many junior developers write code to get it to work or to make it fast, but it&rsquo;s also important to think about who is or could potentially be using your code. It&rsquo;s helpful to start thinking about those things, even as a new programmer. Consider things like strong params and <code>csrf</code> tokens to start, and then work your way up to more complex security measures in your Rails applications. At the end of the day, you probably have some gaping holes in your codebase that is allowing someone to be malicious to your code base, which means that <em>your</em> code isn&rsquo;t actually yours anymore.</p>

<h2>All About That Efficiency</h2>

<p>My favorite talk of the entire conference came from Sam Saffron, the co-founder of Discourse and one of the first employees at StackExchange. To be honest, this talk was less an exercise is learning new things and more a revelation in all the things that I <em>didn&rsquo;t</em> know. And all the things that I knew nothing about centered around one thing: <strong>efficiency</strong>.</p>

<div style="text-align:center">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/aP5NNkzb4og?showinfo=0" frameborder="0" allowfullscreen></iframe><br>
</div>


<p>Sam&rsquo;s talk piqued my interested in particular because I&rsquo;ve been trying to think about the efficiency of my own applications for a few weeks now. I&rsquo;ve been trying to use more efficient methods in my own code &ndash; like <code>pluck</code> in last week&rsquo;s post, for example, or my post on the ActiveRecord <code>includes</code> <a href="http://vaidehijoshi.github.io/blog/2015/04/07/querying-at-warp-drive-using-activerecord-includes/">method</a> a few months ago.</p>

<p>Yet there&rsquo;s a lot more to efficiency than that, it turns out! And that&rsquo;s exactly what Sam&rsquo;s talk aimed to explore. One of the things I learned pretty early on was that ActiveRecord is inefficient &ndash; yes, really! For those of us writing smaller applications, it may not be all that obvious. But for something much larger, such as Discourse, which has tons and tons of assets that have to compile on page load&hellip;well, it&rsquo;s pretty obvious how even just <em>one</em> n+1 query could throw the whole thing to hell in a handbasket!</p>

<p>What I loved the most about Sam&rsquo;s talk was the live demo. He actually ran his server in showed us the different technologies he used to track things like server calls, method invocations, and raw SQL queries. He didn&rsquo;t just tell us what he used &ndash; he showed us what they looked like in development! And here&rsquo;s the icing on the cake: everything is open source. Which means that we can all use the same technologies and fork them and add/modify them for our own projects!</p>

<p>Here are a few of the gems that Sam uses and recommends, which I&rsquo;ve looked into. Lookout for some upcoming #TechnicalTuesdays posts on these soon:</p>

<h4>1. <code>lru_redux</code></h4>

<p>This gem allows for efficient caching by using ordered arrays. It provides you with some pretty fantastic methods to write, read, and clear your cache. The most important thing here is that arrays are quick and efficient when it comes to looking up an item by index, which makes it ideal for something like storing a cache. Check out more on the <code>lru_redux</code> <a href="https://github.com/SamSaffron/lru_redux">Github page</a>.</p>

<h4>2. <code>dapper</code></h4>

<p>The <code>dapper</code> gem is a lightweight Object Relational Mapper that was created by developers at StackExchange who wanted to solve an n+1 problem. What&rsquo;s pretty cool about this gem is that it allows you to execute raw SQL queries and map your results. A major benefit of this is that you no longer have to rely on the Object-Relational Mapper that comes for free with Rails: ActiveRecord. We&rsquo;ve all encountered ActiveRecord&rsquo;s flaws &ndash; particularly when it comes to calls to the server and queries to the database &ndash; and thanks to this gem, you don&rsquo;t have to deal with those things again. Instead, you can just write your own queries to execute! Find out more over on their <a href="https://github.com/StackExchange/dapper-dot-net">ReadMe</a>.</p>

<h4>3. <code>fast_pluck</code></h4>

<p>I&rsquo;m really curious about how this &ldquo;freedom patch&rdquo; actually works, and I need to take the time to sit down and read through it with a good cup of coffee. But, I really like the idea of speeding up ActiveRecord&rsquo;s <code>pluck</code> method, which I am already pretty comfortable with. Check it out over on <a href="https://gist.github.com/SamSaffron/bd593751668e5e5c4afc">this Gist</a>.</p>

<h4>4. <code>memory_profiler</code></h4>

<p>The <code>memory_profiler</code> gem measures how many objects you&rsquo;re allocating to memory on boot of your application, and how many are being retained (how much memory they&rsquo;re taking up) in your app. I haven&rsquo;t explored this gem too much, but I hope to play with it more in the future. You can play with it <a href="
https://github.com/SamSaffron/memory_profiler">over here</a>.</p>

<h2>Language Design Is Hard</h2>

<p>This realization is probably neither prophetic nor profound, but it&rsquo;s still worth repeating nonetheless: languages are hard. They&rsquo;re hard to read, learn, and, most of all, <em>write</em>.</p>

<p>Matz&rsquo;s <a href="https://www.youtube.com/watch?v=bqWBB8-iEac">keynote presentation</a> on the new and upcoming features in the next Ruby release was the first time I started thinking about how difficult it must be to actually create the language that we use everyday, and love so dearly. After his presentation, I asked him how he goes about actually designing new features, long before they are implemented. His answer, in short, was incredibly empathetic: he said that he thinks about what it&rsquo;s like to actually use the Ruby language with the feature he has in mind, and he considers the user experience before handing off a feature for someone to actually implement and include in the next release.</p>

<p>I thought about the difficult problem of language design yet again during Paolo Perrotta&rsquo;s awesome talk about refinements. If you&rsquo;re not familiar with the concept (I wasn&rsquo;t before this talk!), the short version is that <strong>refinements</strong> showed up in Ruby 2, and were used to make &ldquo;local&rdquo; monkeypatches, which are a much safer and preferable alternative to global monkeypatching. An interesting issue with refinements is that they rely on dynamic scoping, which means that you can close and reopen the scope of a class and redefine things in different ways.</p>

<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/_27-4-dbnA8?rel=0&amp;showinfo=0" frameborder="0" allowfullscreen></iframe><br>
</div>


<p>In a way, it was great that Paolo&rsquo;s talk was towards the end of the conference, because it tied up things together nicely. I learned that a simple thing like Ruby refinements &ndash; which boils down to two keywords, <code>refine</code> and <code>using</code> &ndash; were a perfect example of the first two things I learned during the conference: security and efficiency!</p>

<p>The issue with refinements is that you can&rsquo;t always tell what&rsquo;s going in your code, or what exactly your code will execute. And that&rsquo;s pretty scary! You know what else it is? A security threat and a huge vulnerability. Refinements  also slow your code down, because the Ruby interpreter has to go through all of your code and check if a refinement is being used or not. Not exactly the most optimized way of doing things, amirite?</p>

<p>All of this got me thinking about the people who write the languages that we use. They have to have a deep understanding of the language architecture and syntax, and think about how a developer might use (or <em>abuse</em>) a language feature. All of this is to say: language design is hard. And maybe we should all be a bit more grateful for the people who think about these complex problems on a daily basis.</p>

<p>Compared to things like security, optimization, and language design, a smelly durian doesn&rsquo;t seem nearly as bad. In fact, I&rsquo;d say that as far as developers go, we as a Ruby community have got it pretty good. But probably not as good as this dog right here:</p>

<iframe src="//giphy.com/embed/Ps3UNgJew0H7y" width="480" height="347" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>Think about the two types of people who use your code: the users, who should have a seamless experience, which will make you optimize your code, and the abusers (or a better term that I can&rsquo;t think of), or those people who will be looking for security vulnerabilities in <em>your</em> code.</li>
<li>Language design is hard. Refinements are a pretty good example of how a programming language can blow your mind with a single feature</li>
<li>I also met Matz! It was <a href="https://twitter.com/vaidehijoshi/status/606684141506076673">incredibly awesome</a>. And he really is as nice as they say.</li>
</ul>

]]></content>
  </entry>
  
</feed>
