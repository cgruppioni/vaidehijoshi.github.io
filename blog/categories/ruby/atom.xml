<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-09-22T17:49:04-04:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Working Hard or Hardly Working, Part 2: Custom Jobs]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/09/22/working-hard-or-hardly-working-part-2-custom-jobs/"/>
    <updated>2015-09-22T08:59:45-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/09/22/working-hard-or-hardly-working-part-2-custom-jobs</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/XgE4LlECZjw6k" width="480" height="218" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>With the advent of Rails 4.2, one thing is definitely for sure: there is now one background job to rule them all: Active Job. Last week, I learned about Active Job&rsquo;s <a href="http://vaidehijoshi.github.io/blog/2015/09/15/working-hard-or-hardly-working-part-1-active-job/">easy integration</a> with ActionMailer. But, as nice as it is to have those simple <code>deliver_now</code> and <code>deliver_later</code> methods, there will inevitably be a time that we want to do something more &mdash; something that requires writing our own custom job.</p>

<p>Active Job is, thankfully, very good at letting us do this. Since my ActionMailer post last week, I&rsquo;ve written a few jobs using Active Job&rsquo;s framework. And each time that I&rsquo;ve done it, it&rsquo;s gotten easier and easier. Of course, not all of my jobs have been super complex, but once I understood the basics, I could look at other people&rsquo;s code and understand how it was structure and what exactly was going on.</p>

<p>The only way to get comfortable writing my own custom jobs was by &ndash; wait for it &ndash; actually <em>writing</em> one! So that&rsquo;s exactly what we&rsquo;ll do together. Let&rsquo;s turn our ActionMailer method from last week into its own job that will be able to run asychronously. Hold on to your hats, because we&rsquo;re about to leave the shire.</p>

<!--more-->


<h2>Job Generating</h2>

<iframe src="//giphy.com/embed/qxWJDbOnrNOAU" width="480" height="264" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>The most important first step before even generating a job is to make sure that we have our queue adapter set up for Active Job. The default queue adapter for Active Job is to run inline (or, within the <em>same</em> request-response cycle), which means that it will not run in the background. One of the lovely things about Active Job is that we can use any queueing backend that we prefer, as long as we follow the documentation to set it up. Last week, we did this by adding <code>delayed_job</code> to our <code>Gemfile</code>, and setting our queueing configurations inside of <code>config/application.rb</code>:</p>

<p><code>config.active_job.queue_adapter = :delayed_job</code></p>

<p>The <code>delayed_job</code> backend also requires us to run a migration, which adds <code>Delayed::Job</code> objects to our database:</p>

<pre><code class="ruby">♥ rails generate delayed_job:active_record
♥ rake db:migrate
</code></pre>

<p>This will be important later on, because the only way for us to see any jobs that are enqueued or that have failed is by calling <code>Delayed::Job.all</code> in the console or from within the context of a controller. This migration also adds helpful columns to our <code>delayed_jobs</code> table, including <code>priority</code>, <code>attempts</code>, <code>run_at</code>, <code>failed_at</code>, and <code>last_error</code>. This data would be particularly relevant if we wanted to allow a job to be re-run, or for a job&rsquo;s errors to be displayed within an admin panel.</p>

<p>Now that we have all of our queueing backend setup taken care of, we can start to <em>write</em> our job. At the moment, we have an instance method called <code>send_confirmation_email</code> on our <code>Order</code> class, which uses <code>deliver_now</code> to send an email. You&rsquo;ll remember that we&rsquo;re calling this method from within a state machine:</p>

<pre><code class="ruby">class Order &lt; ActiveRecord::Base
    include AASM

    aasm column: 'state', whiny_transitions: false do
        # state machine truncated for brevity!
        state :complete

        event :completed, after: :send_confirmation_email
    end


    def send_confirmation_email
        OrderMailer.confirmation_email(self).deliver_now
    end
end
</code></pre>

<p>We still want to use our <code>OrderMailer</code>, but it would be nice to be able to do that within the context of a background job that exists in its own file, so that we can customize it. Let&rsquo;s generate our job and text unit for our order confirmation emailer, with a nice namespace to boot:</p>

<pre><code class="ruby">♥ bin/rails generate job order/confirmation_emailer
</code></pre>

<p>Now, inside of <code>app/jobs/order/confirmation_emailer.rb</code>, we have a simple little file that looks like this:</p>

<pre><code class="ruby">module Order
    class ConfirmationEmailerJob &lt; ActiveJob::Base
        queue_as :default

        def perform()
            # Do something later
        end
    end
end
</code></pre>

<p>It doesn&rsquo;t look like much, does it? But, it&rsquo;s honestly almost all that we need. The most important thing to know about ActiveJob when it comes to writing a job is this: you must have a <code>perform</code> method. And, as you might expect, the <code>perform</code> method should be, well, responsible for actually <em>performing</em> the job. However, our job doesn&rsquo;t do anything yet. And we&rsquo;re not even calling it anywhere! You know what that means, right? It&rsquo;s time for us to set off on our custom job adventure and start writing!</p>

<h2>Job Writing</h2>

<iframe src="//giphy.com/embed/g7SFZQGzS4HwQ" width="480" height="235" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Since we already know that our <code>perform</code> method is going to be responsible for performing our job, we know that this is where all of our logic should go. It would be nice if we could just pass this background job an <code>order</code> instance, and then tell it what to do with that order. Our <code>OrderMailer</code> has a <code>confirmation_email</code> method that accepts an <code>order</code> object, so we can really just use the mailer inside of our job.</p>

<p>Let&rsquo;s pass an <code>order</code> to our job, and then have the job be responsible for delivering the confirmation email:</p>

<pre><code class="ruby">module Order
    class ConfirmationEmailerJob &lt; ActiveJob::Base
        def perform(order)
          OrderMailer.confirmation_email(order).deliver
        end
    end
end
</code></pre>

<p>Nice! That was easy enough, right? You&rsquo;ll notice that our <code>ConfirmationEmailerJob</code> inherits from <code>ActiveJob::Base</code>. This is very important, because without inherting from this module, our job would have no idea what to do with its <code>perform</code> method! It&rsquo;s crucial to keep this in mind particularly if we are manually creating our jobs and not using the rails generator; in that case, we need to add the <code>ActiveJob::Base</code> inheritance on our own. (I was bit by this recently, so don&rsquo;t make the same mistake that I did!)</p>

<p>Honestly though, this isn&rsquo;t doing that much more than what our <code>OrderMailer</code> did initially. We&rsquo;re writing a <em>custom</em> job, so let&rsquo;s customize what this job can do. In addition to delivering our confirmation email, it would be cool if this job could also update an attribute on our <code>order</code> called <code>confirmation_sent_at</code>. This is just a datetime format attribute that will probably end up in an admin panel or dashboard. And there&rsquo;s a really elegant way that we can update this attribute from within the job:</p>

<pre><code class="ruby">module Order
    class ConfirmationEmailerJob &lt; ActiveJob::Base
        def perform(order)
          OrderMailer.confirmation_email(order).deliver

          order.touch(:confirmation_sent_at)
        end
    end
end
</code></pre>

<p>The <code>touch</code> method is part of ActiveRecord, and allows us to save an ActiveRecord object with the <code>updated_at</code> and <code>updated_on</code> attributes set to the current date and time. It&rsquo;s important to note that there are no validations that are performed by this method, and it&rsquo;s actually only the <code>after_touch</code>, <code>after_commit</code>, and <code>after_rollback</code> ActiveRecord callbacks that are ever executed.</p>

<p>If we called <code>order.touch</code>, we would only update <code>order.updated_at</code>. But, since we have a specific attribute called <code>confirmation_sent_at</code> in order to specifically keep track of our confirmation emails, we can tell the <code>touch</code> method to update that attribute by passing it in as an parameter: <code>order.touch(:confirmation_sent_at)</code>. This is a pretty awesome method, but don&rsquo;t make the mistake of trying to call it on a plain old Ruby object, or on an unsaved ActiveRecord object! The object <em>must</em> be persisted, since the <code>touch</code> method is defined in the <code>ActiveRecord::Persistence</code> module. Otherwise, you&rsquo;ll get an ActiveRecordError, and we don&rsquo;t have time for that silliness!</p>

<p>However, what we <em>do</em> need to do next is call our background job and have it&hellip;well, do it&rsquo;s job!</p>

<h2>Job Winning</h2>

<p>Now that we have our <code>Order::ConfirmationEmailerJob</code> class ready to get to work, it&rsquo;s time for us to actually get to work and start performing. Since we already have our state machine in place, let&rsquo;s just call our job from within our <code>Order</code> class:</p>

<pre><code class="ruby">class Order &lt; ActiveRecord::Base
    include AASM

    aasm column: 'state', whiny_transitions: false do
        state :complete

        event :completed, after do
            Order::ConfirmationEmailerJob.perform_later(self)
        end
    end
end
</code></pre>

<p>Nice! The <code>perform_later</code> method on our <code>Order::ConfirmationEmailerJob</code> will instantiate our job and call <code>perform</code> on it. Since we&rsquo;re already in the context of the <code>Order</code> model, we can simply pass in <code>self</code>, which is just the <code>order</code> instance, into our job, which will know exactly what to do with it. We&rsquo;re also taking advantage of the <code>after</code> callback in our state machine, and invoking our job directly inside of our <code>completed</code> event. Alternatively, we could have abstracted this out into a method for a more granular separation of concerns. But since our job is pretty simple, it also makes sense to put it directly into the <code>after</code> block.</p>

<p>Now, when we call <code>order.completed!</code>, our state machine will transition our <code>order</code> object to the state <code>'complete'</code>, and after the event, it will create a new instance of our <code>Order::ConfirmationEmailerJob</code>, which will call the <code>perform</code> method asychronously, and will use <code>delayed_job</code> to enqueue the job in the background. The emailer job would then send our order confirmation email using ActionMailer, and then it would update the <code>confirmation_sent_at</code> attribute on our <code>order</code> instance. And, if we wanted to see what the job looked like while it was being running asychronously, we could open up the rails console and run <code>Delayed::Job.last</code>, which would show us all the details about the most recent job that we had called.</p>

<p>Wow, that&rsquo;s a <em>lot</em> of things happening in a pretty complex sequence! That tiny little <code>perform</code> method isn&rsquo;t looking so tiny after all, is it?</p>

<p>Interestingly, the job that we wrote is still a lot simpler than how Rails jobs used to be written. Before Active Job was integrated into Rails 4.2, we weren&rsquo;t able to pass in an <code>order</code> instance into the <code>perform</code> method of our job. Instead, we had to pass in the <code>id</code> of an object, and then look it up inside of our job:</p>

<pre><code class="ruby">module Order
    class ConfirmationEmailerJob &lt; ActiveJob::Base
        attr_reader :order_id

        def initialize(order_id:)
            @order_id = order_id
        end

        def perform
          OrderMailer.confirmation_email(order).deliver

          order.touch(:confirmation_sent_at)
        end

        private
        def order
            Order.find(order_id)
        end
    end
end
</code></pre>

<p>Not as nice as clean as what we wrote initially, right? But still, despite all the extra lines of code, it&rsquo;s pretty amazing that all of these actions can be performed asynchronously, and within different request-response cycles. Rails&#8217; ActiveJob truly does rule all.</p>

<iframe src="//giphy.com/embed/zGnnFpOB1OjMQ" width="480" height="215" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<h2>tl;dr?</h2>

<ul>
<li>The most important part about setting up a job through ActiveJob is inheriting from <code>ActiveJob::Base</code>, and implementing a <code>perform</code> method. Now, we can actually pass in instances of objects to the <code>perform</code> method, rather than ids, which is all thanks to <a href="http://dev.mikamai.com/post/96343027199/rails-42-new-gems-active-job-and-global-id">global ids</a>.</li>
<li>Curious how the <code>touch</code> method works? Check out <a href="http://apidock.com/rails/ActiveRecord/Persistence/touch">the documentation</a> on this amazing little function.</li>
<li>Here&rsquo;s a <a href="http://railscasts.com/episodes/171-delayed-job?autoplay=true">great railscast</a> on setting up a job &ndash; keep in mind though, it&rsquo;s pre-Rails 4.2 and ActiveJob!</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Working Hard or Hardly Working, Part 1: Active Job]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/09/15/working-hard-or-hardly-working-part-1-active-job/"/>
    <updated>2015-09-15T08:53:51-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/09/15/working-hard-or-hardly-working-part-1-active-job</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/79JlUHyiSzYBi" width="480" height="249" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>Last week, I sent a lot of emails &mdash; after all, I was working on creating my <a href="http://vaidehijoshi.github.io/blog/2015/09/08/youve-got-mail-action-mailer-plus-letter-opener/">very first mailer</a>. But in the process, I also realized something else: waiting for an email to send is <em>not</em> fun. Especially if you can&rsquo;t do anything else while you&rsquo;re waiting.</p>

<p>This problem pretty much encapsculates the reason for the existence and invention of background jobs. I&rsquo;ve actually been playing around with creating and running jobs in different applications for the past few months now, yet I never really felt comfortable with them. I knew that having jobs run certain processes was clearly very important since they kept popping up all over the place. However, I was having trouble wrapping my head around what exactly a background job <em>was</em>, and when and why I would ever need to use one.</p>

<p>Working with ActionMailer turned out to be the perfect stepping-stone to Active Job, which helped me to better understand inline processes, asychronous requests, and how all of these things fit into running a job. Since we already know how to create mailers, that will be the perfect introduction to running our very first job! Integrating ActionMailer and Active Job is a piece of cake, so we&rsquo;ll start with that first. Baby steps, my friends!</p>

<!--more-->


<h2>Jobs: Inline Or Background?</h2>

<iframe src="//giphy.com/embed/jfiHMHRyARhf2" width="480" height="285" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>Background jobs existed far before ActiveJob came into being in December of 2014. In fact, if we take a look at one of our more complex, pre-Rails 4.2 projects, it&rsquo;s likely that we&rsquo;ll see a some classes that are suffixed with <code>Worker</code>. These classes are a little bit like service objects in that they are responsible for taking in an object as a parameter and performing a certain action with or <em>on</em> that object, sometimes implementing a service class in the process of doing so. The &ldquo;worker&rdquo; term really just refers to classes that we use in the background of our application.</p>

<p>But, why would we ever need to run a class in the background of our application? And honestly, what does that even <em>mean</em>? Well, we can start by defining what exactly makes a background job, beginning by peeking inside of our <code>config/application.rb</code> file. There are a lot of things happening inside of here, all of which are setting different configurations inside of our application. But there&rsquo;s one line in particular that we should pay more attention to:</p>

<p><code>Rails.application.config.active_job.queue_adapter = :inline</code></p>

<p>Without even worrying about what <code>queue_adapter</code> is doing for now, we know one thing for sure: our current <code>active_job</code> configuration is set to run <code>inline</code>. Okay, let&rsquo;s try to deduce what <code>inline</code> means, exactly. A quick search in the Rails guides leads us to <a href="http://api.rubyonrails.org/classes/ActiveJob/QueueAdapters/InlineAdapter.html">the documentation</a> for something called the <code>InlineAdapter</code>, which explains:</p>

<blockquote><p>&ldquo;When enqueueing jobs with the Inline adapter, the job will be executed immediately. To use the Inline set the queue_adapter config to <code>:inline</code>.&rdquo;</p></blockquote>

<p>Interesting! So, if running a job <code>inline</code> means that it happens right away, running a job that is <em>not</em> inline means that it will be delayed in its execution &ndash; that is to say, it won&rsquo;t happen immediately, but it&rsquo;ll happen later on. So the next logical question, then, is <em>why</em>?</p>

<p>After doing some digging, the best explanation I&rsquo;ve found for why we&rsquo;d want to run a process <em>not</em> inline but rather in the background, at a later point, comes from <a href="http://ryanselk.com/2014/09/25/using-background-jobs-in-rails-42-with-active-job/">Ryan Selk</a>. I really like the way that he explains the thought-processes behind choosing when to use a background job:</p>

<blockquote><p>&ldquo;One common situation for needing background jobs is consuming external APIs. It is unrealistic to think that all of your external APIs will have 100% uptime. By allowing API interaction to happen in a background job we can manage failures more effectively. Instead of having the user wait for a task to end, we send that task to the background queue. The User can then continue interacting with the app. Background jobs also give us the opportunity to prioritize jobs which are waiting in out background job queue. In many cases using background jobs can significantly reduce the required resources of the app.&rdquo;</p></blockquote>

<p>Ultimately, <strong>it all comes down to waiting</strong>. If there is ever a situation where your application would have to wait for a process &ndash; an email to send, a request to complete, or a response to be received &ndash; that&rsquo;s a sign that you probably should be using a background job, rather than an inline process. In his blog post, Ryan talks about using 3rd party APIs, or performing some form of &ldquo;computation intensive work, such as solving equations or image processing&rdquo;; basically, anything that would require enough time or effort to make our application lag or to keep our user waiting would be a prime candidate for a background job.</p>

<p>So, let&rsquo;s implement a job using Active Job&hellip;that&rsquo;ll be easy, right?</p>

<h2>A Round of Applause for Active Job</h2>

<iframe src="//giphy.com/embed/QOfrQpuGMa9Pi" width="480" height="278" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>When Active Job was <a href="http://weblog.rubyonrails.org/2014/12/19/Rails-4-2-final/">first introduced</a>, one of its most impressive aspects was the fact that you could easily create a job and then later specify the job runner that you wanted to use. Active Job was essentially built to be its own mini-framework, which made it incredibly useful for declaring a job, and then making it run on any backend that you wanted (for example, <code>delayed_job</code> or <code>resque</code>). This also meant that it became super easy (think changing a single line in our application) to switch between different queuing backends. An important thing to remember is that Rails itself doesn&rsquo;t have a job runner; by default, it comes with an &ldquo;immediate runner&rdquo; queuing implementation, which means that each job that is enqueued will run immediately (in other words, it will run <code>inline</code>).</p>

<p>Setting up Active Job is incredibly easy, which is another thing that makes it so beautiful. It comes with a generator, which means that we can run a simple command like this to create a job that would send a newsletter to new users of our application:</p>

<p><code>♥ bin/rails g job new_user_newsletter</code></p>

<p>Of course, we could also just create our own file inside of <code>app/jobs</code>, as long as it inherited from <code>ActiveJob::Base</code>. But let&rsquo;s hold off on writing a complex job for now. Let&rsquo;s try to first get Active Job to work with ActionMailer and send our order confirmation email via our <code>OrderMailer</code> for today.</p>

<p>The first thing we need to do is to choose a queuing backend. I&rsquo;ve found <code>delayed_job_active_record</code> to be a pretty good starting point, so we can add that to our <code>Gemfile</code> and run <code>bundle install</code>. This backend also requires two additional forms of setup: first, a migration that sets up <code>Job</code> objects in Active Record. We can run these commands easily in our terminal:</p>

<pre><code class="ruby">♥ rails generate delayed_job:active_record
♥ rake db:migrate
</code></pre>

<p>And secondly, inside of our <code>config/application.rb</code>, we&rsquo;ll need to set our <code>queue_adapter</code> configuration to use <code>delayed_job</code> rather than be set to <code>inline</code> processes:</p>

<p><code>config.active_job.queue_adapter = :delayed_job</code></p>

<p>This last part is very important, as the documentation explains that Rails doesn&rsquo;t have it&rsquo;s own queuing adapter:</p>

<blockquote><p>&ldquo;Rails itself does not provide a sophisticated queuing system and just executes the job immediately if no adapter is set.&rdquo;</p></blockquote>

<p>Without setting up our queuing backend, Active Job won&rsquo;t know what to use to send our email. And speaking of emails, it&rsquo;s finally time to integrate Active Job with ActionMailer!</p>

<h2>BFFS 4EVA: Active Job + ActionMailer</h2>

<p>Active Job is neatly integrated with ActionMailer so that we can easily send emails outside of a single request-response cycle (in other words, asynchronously). There are two methods that exist on the ActionMailer module that we can use. In fact, we already started using one last week: <code>deliver_now</code>.</p>

<p>Inside of our <code>Order</code> class, we were using <code>deliver_now</code> to send a confirmation email that was written inside of our <code>OrderMailer</code>. We probably both need a refresher, so here&rsquo;s the code that uses our favorite thing ever: a state machine!</p>

<pre><code class="ruby">class Order &lt; ActiveRecord::Base
    include AASM

    aasm column: 'state', whiny_transitions: false do
        state :complete

        event :completed, after: :send_confirmation_email
    end


    def send_confirmation_email
        OrderMailer.confirmation_email(self).deliver_now
    end
end
</code></pre>

<p>If we instead change our <code>send_confirmation_email</code> to use <code>deliver_later</code>, we can send our order confirmation email through Active Job, rather than sending it inline, within the same request-response cycle. All of this magic is built into the <code>deliver_later</code> method. In fact, if we take a look at <a href="http://api.rubyonrails.org/classes/ActionMailer/MessageDelivery.html#method-i-deliver_later">the source code</a> for Action Mailer, we&rsquo;ll learn that there are actually two different types of <code>deliver_later</code> methods: <code>deliver_later</code> and <code>deliver_later!</code>. They&rsquo;re both similar in that they both enqueue our email to be delievered through Active Job.</p>

<p>However, when <code>deliver_later!</code> is invoked, it relies on <code>deliver_now!</code>, which delivers an email without checking <code>perform_deliveries</code> and <code>raise_delivery_errors</code>. But, because <code>deliever_later!</code> depends on <code>deliver_now!</code>, which in turn bypasses these two important methods, <code>deliver_later!</code> it will never, ever raise any errors. The documentation suggests that we use this particular method with caution, so if you&rsquo;re unsure, it&rsquo;s probably best to stick with plain old <code>deliver_later</code>.</p>

<p>Integrating ActionMailer with Active Job is probably the easiest way to start using background jobs. But there are a <em>lot</em> of other ways to implement Active Job in our applications! Now we know enough to start writing our own custom jobs that will run asynchronously! In fact, that&rsquo;s exactly what we&rsquo;ll do next week, in part 2 of this series. Get ready to become an Active Job boss and walk around like this:</p>

<iframe src="//giphy.com/embed/a93sBAElVcuNq" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>Active Job requires you to set up a queuing backend and use the <code>deliver_later</code> method in order to integrate with ActionMailer.</li>
<li>The Rails Guides for cover all the basics for Active Job; head <a href="http://edgeguides.rubyonrails.org/active_job_basics.html">over here</a> to read more.</li>
<li>Even though Active Job is a relatively new feature of Rails, there are a lot of great blog posts that walk through how to use it. Check out <a href="http://www.gotealeaf.com/blog/handling-emails-in-rails">this one</a>, <a href="http://ryanselk.com/2014/09/25/using-background-jobs-in-rails-42-with-active-job/">another one</a>, and <a href="http://www.jetthoughts.com/blog/tech/2015/04/17/time-for-active-job.html">one more</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[You've Got Mail: Action Mailer + Letter_Opener]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/09/08/youve-got-mail-action-mailer-plus-letter-opener/"/>
    <updated>2015-09-08T21:45:34-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/09/08/youve-got-mail-action-mailer-plus-letter-opener</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/9xfgwmsfIaSYg" width="480" height="265" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>There&rsquo;s one thing that everyone loves: getting mail! But there&rsquo;s one thing that all developers would rather avoid: sending mail. Unfortunately, this paradox perfectly describes the joys and horrors of getting your application to send a single email.</p>

<p>I recently worked on building out a password reset feature for one of our applications. In order for this feature to work, I had to figure out how to get my Rails application to send an email to our user with a password reset token in case they had forgotten their password. I thought that handling the authentication and token aspect of this would be complicated, but it turned out that learning about mailers was the more fun part. I had never actually worked with Rails mailers before, and honestly, I thought that I was in over my head (this also might be partly attributed to the fact that I had just come back from a two-week vacation and felt like I had completely forgotten how to code).</p>

<p>So, I did what any developer would do: I cried and went home. Okay, okay, I&rsquo;m just kidding! What I <em>actually</em> did was read through the documentation, play around with my application and, in the process, taught myself how to use Rails Action Mailer. I never thought that I&rsquo;d say this but, getting that feature to work and seeing that email pop up was incredibly exciting. In fact, I don&rsquo;t think I&rsquo;ve ever been more excited about sending and receiving an email. But don&rsquo;t let me tell you how thrilling it was &mdash; let&rsquo;s create our own mailer and experience it together!</p>

<!--more-->


<h2>Generating Some Mail(ers)</h2>

<iframe src="//giphy.com/embed/izxswKdmqmQrS" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>Rails has a wonderful built-in mailing system called Action Mailer, which allows us to send email from our application as long as we have a <strong>mailer model</strong>. Mailers are actually a lot like controllers: they have their own <code>app/mailers</code> directory, and each mailer has its own associated view as well. Each mailer also inherits from <code>ActionMailer::Base</code>, and just like controllers, can be generated really easily.</p>

<p>For our bookstore app, we won&rsquo;t start off with anything <em>too</em> fancy just yet. Instead, let&rsquo;s stick with a simple mailer that will be responsible for one little thing: sending an order confirmation email whenever a user successfully places an order (did your mind immediately jump to using a <a href="http://vaidehijoshi.github.io/blog/2015/03/24/a-machine-state-of-mind-part-2-implementing-state-machines/">state machine</a>? I hope so!)</p>

<p>To start, we&rsquo;ll use Rails to generate a mailer:</p>

<p><code>♥ bin/rails generate mailer Order</code></p>

<p>Running this command in the terminal generates a few different files for us. We now have an <code>app/mailers</code> directory, with an <code>order_mailer.rb</code> and <code>application_mailer.rb</code> file. It also generates three files inside of <code>app/views</code>: <code>order_mailer</code>, <code>layouts/mailer.text.erb</code>, and <code>layouts/mailer.html.erb</code>, as well as test units for our order mailer (<code>order_mailer_test.rb</code>).</p>

<p>Depending on how many mailers this application will have, it might not makes sense to generate all of these files. If we decided to manually create our mailer rather than generating it, we&rsquo;d need to keep one thing in mind: our mailer <em>must</em> be a file inside of the <code>mailers</code> directory, and it <em>must</em> inherit from <code>ActionMailer::Base</code> (unless, of course, we wanted to use a mailer from another library, such as the <code>Devise::Mailer</code> from the <code>devise</code> gem).</p>

<p>The mailer model has methods defined on it that allows us to actually specify how and where an email is sent. Right now, however, our mailer models look pretty empty! Inside of our generated <code>ApplicationMailer</code>, the only setup we have is our layout configuration and our <code>from</code> address:</p>

<pre><code class="ruby">class ApplicationMailer &lt; ActionMailer::Base
  default from: "help@vaidehisbookstore.com"
  layout 'mailer'
end
</code></pre>

<p>While our <code>order_mailer.rb</code> is completely empty:</p>

<pre><code class="ruby">class OrderMailer &lt; ApplicationMailer
end
</code></pre>

<p>Since mailers are so much like controllers, we can approach writing them in a similar way. The first thing we&rsquo;ll do is write some actions. Just like with controllers, we want our methods to adhere to the single-responsiblity principle, which means that they should be handling only one thing at a time. We&rsquo;ll start by writing a <code>confirmation_email</code> method, which will take an <code>Order</code> object as its parameter.</p>

<pre><code class="ruby">class OrderMailer &lt; ApplicationMailer
  def confirmation_email(order)
    @order = order
  end
end
</code></pre>

<p>Just like in controllers, any instance variables that we define in our method &mdash; in this case, <code>@order</code> &mdash; become available for us to use inside of our views. This will be important when we want to render the user&rsquo;s information via our <code>@order</code> instance. But&hellip;we&rsquo;re not actually <em>mailing</em> anything right now, are we? Of course not! In order to actually create our message and render our email templates, we need to use the <code>mail</code> method.</p>

<p>The <code>mail</code> method is defined on <code>ActionMailer::Base</code> (hence why every mailer should always inherit from it so that it has access to this very crucial method). If we look at <a href="http://apidock.com/rails/ActionMailer/Base/mail">the documentation</a> for this method, we can see that it accepts a headers hash, which is where we can specify the most-used headers in an email message. Some of the options we can pass in include <code>subject</code>, <code>to</code>, <code>from</code>, <code>cc</code>, and <code>date</code>, among others. For now, we&rsquo;ll just pass in a <code>to</code> option and a <code>subject</code> option:</p>

<pre><code class="ruby">class OrderMailer &lt; ApplicationMailer
  def confirmation_email(order)
    @order = order

    mail(to: order.user.email, subject: "Your Order #{@order.number}")
  end
end
</code></pre>

<p>If we wanted to get <em>really</em> fancy, we could specify <code>default</code> values for any of these headers (except for <code>date</code>) inside of our <code>OrderMailer</code> class. Alternatively, we could also write our <code>mail</code> method as a block, which would allow us to render specific templates &mdash; a piece of functionality that might be nice as we add more methods to this mailer over time. We could also use the block syntax in order to render plain text directly without using a template, which would look something like this:</p>

<pre><code class="ruby">mail(to: order.user.email) do |format|
    format.text { render plain: "Hi, #{order.user.email}!" }
    format.html { render html: "&lt;h1&gt;Hi, #{order.user.email}!&lt;/h1&gt;".html_safe }
end
</code></pre>

<p>But let&rsquo;s hold off on all these bells and whistles. Let&rsquo;s just get this method into our state machine and actually <em>send</em> this bad boy.</p>

<h2>Send Me Some Mail</h2>

<p>Now for the fun part: sending and receiving our mail! There are two methods we can use to send an email: <code>deliver_now</code> and <code>deliver_later</code>. The former sends our email inline (in the same request-response cycle), while the latter sends emails in the background by integrating with Active Job.</p>

<p>We already wrote our <code>confirmation_email</code> method, so now we just need to invoke it. But, we defined it on our mailer class. However, we don&rsquo;t need to instantiate a new instance of our <code>OrderMailer</code> class (like we would have to do with a service object, for example). Instead, we can just call our <code>confirmation_email</code> method on our mailer class directly. Since brevity is the soul of wit, here&rsquo;s a truncated version of the state machine in our <code>order.rb</code> file, which is where we&rsquo;ll invoke this method:</p>

<pre><code class="ruby">class Order &lt; ActiveRecord::Base
    include AASM

    aasm column: 'state', whiny_transitions: false do
        state :complete

        event :completed, after: :send_confirmation_email
    end


    def send_confirmation_email
        OrderMailer.confirmation_email(self).deliver_now
    end
end
</code></pre>

<p>You&rsquo;ll remember that our <code>confirmation_email</code> method takes an <code>Order</code> as a parameter, which is why we&rsquo;re passing in <code>self</code>, the <code>Order</code> object, into the method, before chaining on <code>deliver_now</code> at the end of it. Now, after our <code>completed</code> event is called, this email will be sent. But how do we know what our email will say, exactly? Well, we can head over to our email templates to find out.</p>

<iframe src="//giphy.com/embed/eRIrROHUPJvgs" width="480" height="348" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>When we generated our mailer, one of the files that was generated was <code>app/views/layouts/mailer.html.erb</code>. If we take a look inside of this file, we&rsquo;ll see that it&rsquo;s pretty simple; in fact, all it&rsquo;s going to do for now is <code>yield</code> to whatever template needs to be rendered. If we wanted to add styles or formatting that would apply to <em>all</em> of our mailers, this is where it would go:</p>

<pre><code class="erb">&lt;html&gt;
  &lt;body&gt;
    &lt;%= yield %&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>For things pertaining specifically to our <code>OrderMailer</code> template, we&rsquo;ll need to visit the view for that mailer, which will live inside of <code>app/views/order_mailer/confirmation_email.html.erb</code>. We can again think of how controllers work with their associated views (for example, an <code>index</code> action corresponds to an <code>index.html.erb</code> file). Similarly, our <code>OrderMailer</code> class knows about its own specific view because its name is the same as the mailer&rsquo;s method (<code>confirmation_email</code>). This is where we can put the text for our email template; for now, it won&rsquo;t be anything too special and will just use our <code>@order</code> instance from the <code>confirmation_email</code> method we wrote in the <code>OrderMailer</code> to retrieve and render the order number and user&rsquo;s email:</p>

<pre><code class="erb">Hello &lt;%= @order.user.email %&gt;,

This email confirms your order &lt;%= @order.number %&gt;.
</code></pre>

<p>Awesome! Now, in development, we can test this out by placing an order, triggering the <code>send_confirmation_email</code> method in our state machine, and using our <code>OrderMailer</code> to send an email in a sychronous request to our user&rsquo;s email address. That&rsquo;s a <em>lot</em> to do, but we made it happen!</p>

<h2>Letter Opener + Instant Delivery</h2>

<p>Before we get too email-happy, here&rsquo;s a thought: how much do you really <em>like</em> email? I don&rsquo;t know about you, but I would really rather not get an email every single time I test out my mailer in development. Thankfully, there&rsquo;s a gem that was created to solve precisely this very problem: <code>letter_opener</code>.</p>

<p>This gem intercepts our mailer and allows us to preview an email from within our browser instead of actually sending the email to an email address. One of the great benefits of this &mdash; in addition to both saving space in our inbox and not having to set up email delivery in our development environment &mdash; is us not having to worry about sending test emails by accident to someone else&rsquo;s email address!</p>

<p>Adding <code>letter_opener</code> to our application is pretty easy, and the documentation is <a href="https://github.com/ryanb/letter_opener">easy to follow</a>. First, we&rsquo;ll add the gem to the <code>:development</code> group in our <code>Gemfile</code>:</p>

<p><code>gem "letter_opener", group: :development</code></p>

<p>After we run <code>bundle install</code> in our terminal, we&rsquo;ll need to do one last step: setting up our mailer configurations. Basically, all this means is that we need to specifically set up our development environment such that it will use our <code>letter_opener</code> gem as its <em>delivery method</em>. In fact, that&rsquo;s pretty much the only line we need to add in our <code>config/environments/development.rb</code> file:</p>

<p><code>config.action_mailer.delivery_method = :letter_opener</code></p>

<p>The <code>delivery_method</code> acepts a delivery method object and defaults to <code>:smtp</code>. Since we want <code>letter_opener</code> to handle our mail deliveries, we&rsquo;ll just set our delivery method on Action Mailer to the gem that we want to use.</p>

<p>Now that we&rsquo;ve set this up, any email that is sent by Action Mailer will be intercepted and open up in a new tab in our browser, rather than actually being sent to an email address. These files will be stored temporarily in <code>tmp/letter_opener</code>.</p>

<p>But as <em>lovely</em> and helpful as it is to have all these test emails popping up in our browser, there&rsquo;s one thing that would be even nicer to have: all of these emails being triggered <em>outside</em> of the request-response cycle. In other words, what we want to do is to run these requests asychronously. Well, what does the documentation say about making this happen?</p>

<blockquote><p>&ldquo;Active Job&rsquo;s default behavior is to execute jobs <code>:inline</code>. So, you can use
<code>deliver_later</code> now to send emails, and when you later decide to start sending
them from a background job, you&rsquo;ll only need to set up Active Job to use a queueing
backend (Sidekiq, Resque, etc).&rdquo;</p></blockquote>

<p>Okay, it sounds like we need to learn a little bit about Active Job and set up a queueing backend to send our emails in a job. But let&rsquo;s save that for another blog post. Tune in again next week, when I&rsquo;ll delve into the basics of Active Job and asychronous processes. Until then, have fun opening those emails!</p>

<iframe src="//giphy.com/embed/u8IJtQ7dfZhn2" width="480" height="433" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>Rails mailers inherit from <code>ActionMailer::Base</code>, and work just like controllers, with actions and corresponding views. Check out this <a href="http://www.gotealeaf.com/blog/handling-emails-in-rails">fantastic post</a> on sending emails using Action Mailer to dive into the details.</li>
<li>There are a lot of different header options that you can pass to <code>ActionMailer::Base</code>. Read more about them <a href="http://apidock.com/rails/ActionMailer/Base/headers">over here</a>.</li>
<li>Curious about how to go about configuring Action Mailer to make the mailing magic happen? The <a href="http://guides.rubyonrails.org/configuring.html#configuring-action-mailer">Rails Guides</a> have a great tutorial on how to do that.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inflections Everywhere: Using ActiveSupport Inflector]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/09/01/inflections-everywhere-using-activesupport-inflector/"/>
    <updated>2015-09-01T08:45:22-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/09/01/inflections-everywhere-using-activesupport-inflector</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/JEIRAmTTfUgYE" width="480" height="264" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p><br></p>

<p>Words are pretty important. But do you know what&rsquo;s more important than words? <em>Grammar</em>. (Can you tell that I was an English major?) Despite how big of a book nerd I am, there&rsquo;s acually a crucial reason as to why we should keep things like grammar in consideration: convention.</p>

<p>At it&rsquo;s very core &mdash; pun totally intended &mdash; the Rails framework is based in conventions. We rely on the framework to create our models, controllers, and views in a specific file structure, and for them to be named in a certain way. But what we often forget is that we also rely on Rails to be smart enough to handle strange edge cases, like knowing that a <code>mice</code> table should store the <code>Mouse</code> model objects, and that the <code>MiceController</code> should be responsible for passing those objects back and forth!</p>

<p>It all seems pretty automagical. But we have to keep in mind that it was the Rails core team that created and established these conventions, which means that they&rsquo;re not magic &mdash; they&rsquo;re just code! And as much as we can rely on preexisting Rails conventions, there might be times that we need to tweak our code to abide by those conventions. And because computers are not people (and because English is a crazy language with so many strange exceptions), we&rsquo;re probably going to run into a roadblock when dealing with grammar naming conventions. Thankfully, there&rsquo;s a great tool to help with this problem: the Rails <strong>Inflector</strong>, also known as every grammar nerd&rsquo;s dream.</p>

<!--more-->


<h2>Meet The Inflector</h2>

<iframe src="//giphy.com/embed/yLV9y5wb0Qb1m" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>The Rails Inflector is actually a part of the ActiveSupport module, which is truly a beast of a module, and probably warrants a few blog posts of its own. The tl;dr version of ActiveSupport is this: it provides a bunch of different patterns to transform simple Ruby strings. The inflector library in particular is responsible for handling the pluralization of different strings.</p>

<p>An important thing to note about the inflections library is that it&rsquo;s pretty much set in stone. According to <a href="http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html">the documentation</a>, these rules are never going to change so that Rails can remain backwards-compatible for older applications:</p>

<blockquote><p>&ldquo;The Rails core team has stated patches for the inflections library will not be accepted in order to avoid breaking legacy applications which may be relying on errant inflections. If you discover an incorrect inflection and require it for your application or wish to define rules for languages other than English, please correct or add them yourself.&rdquo;</p></blockquote>

<p>Basically, what this means is that Rails provides us with some basic inflections; however, if we want to create our own custom grammar rules (or if we notice something that&rsquo;s incorrect), we have to write our own inflections for our application. It&rsquo;s also worth noting that if we want to create models that are <em>not</em> English words, we&rsquo;d need to write our own pluralize rules for those as well. But before we go about writing completely new inflections, let&rsquo;s first see what inflector methods we have available to us!</p>

<h2>Inflector Methods</h2>

<iframe src="//giphy.com/embed/l41lS9B8KYJ9dYZck" width="480" height="283" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>The <code>ActiveSupport::Inflector</code> module has a handful of public instance methods that are available for us to use. In fact, when I was first learning Rails, I played around with these methods in irb, but didn&rsquo;t really know (much less <em>understand</em>) where they were coming from. But it turns out that the Inflector methods can be super useful! Here are some of my favorites:</p>

<h3><code>humanize</code></h3>

<p>This method is great for displaying an attribute name to end users. It deletes any leading underscores, replaces underscores with spaces, downcase all words (except acronyms), and capitalizes the first word. Basically, it makes your attributes human-readable, which can be helpful for displaying an error message to your user:</p>

<pre><code class="ruby">♥ rails console
Loading development environment (Rails 4.1.4)
irb(main):001:0&gt; humanize(author.first_name) 
=&gt; "First name"
</code></pre>

<h3><code>titleize</code></h3>

<p>The <code>titleize</code> method is pretty perfect for our bookstore application. It capitalizes all the words and replaces underscores with spaces:</p>

<pre><code class="ruby">irb(main):002:0&gt; 'of_mice_and_men'.titleize
=&gt; "Of Mice And Men"
</code></pre>

<p><em>Protip: this method is also aliased as <code>titlecase</code>.</em></p>

<h3><code>parameterize</code></h3>

<p>This method replaces special characters in a string so that it can be used in a URL (think sluggable names with hyphens):</p>

<pre><code class="ruby">irb(main):003:0&gt; 'Of Mice And Men'.parameterize
=&gt; "of-mice-and-men"
</code></pre>

<h3><code>singularize</code></h3>

<p>The <code>singularize</code> method does exactly what you think it would do: it returns the singular form of a word in a string:</p>

<pre><code class="ruby">irb(main):004:0&gt; 'mice'.singularize
=&gt; "mouse"
irb(main):005:0&gt; 'men'.singularize
=&gt; "man"
</code></pre>

<h3><code>pluralize</code></h3>

<p>And the <code>pluralize</code> method does the opposite things: returns the plural form of a word in string format:</p>

<pre><code class="ruby">irb(main):006:0&gt; "mouse".pluralize
=&gt; "mice"
irb(main):007:0&gt; "man".pluralize
=&gt; "men"
</code></pre>

<p>There are tons more Inflector methods that are very <a href="http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html">well-documented</a>. In fact, there are so many great methods that you might be thinking to yourself, <em>why would I ever have to write my own methods?</em></p>

<p>Well, what if we wanted <code>Specimen</code> objects, which needed to be pluralized as <code>Specimens</code>. We could assume that Rails will handle that for us&hellip;or we could double-check:</p>

<pre><code class="ruby">irb(main):008:0&gt; "specimen".pluralize
=&gt; "specimen"
</code></pre>

<p>Oops! It seems like the predefined inflections are taking hold here and parsing &ldquo;men&rdquo; as the plural form of &ldquo;man&rdquo;, like we saw earlier. You know what this means&hellip;time to write our <em>own</em> inflections!</p>

<h2>New Inflection Rules</h2>

<p>One of the coolest public instance methods of the <code>`ActiveSupport::Inflector</code> module is the method that allows us to specify our own inflector rules. This method is appropiately named <code>inflections</code>, and it does some interesting things.</p>

<p>The <code>inflections</code> method yields to a singleton instance of <code>ActiveSupport::Inflector::Inflections</code>. It can be passed an optional locale, which is how we could write inflection rules for other languages; the default locale is English (specified as the argument <code>:en</code>).</p>

<p>We can write our own inflections inside of the <code>config/initializers/inflections.rb</code> file. This file actually already exists and will look like this when we first open it:</p>

<pre><code class="ruby"># Be sure to restart your server when you modify this file.

# Add new inflection rules using the following format. Inflections
# are locale specific, and you may define rules for as many different
# locales as you wish. All of these examples are active by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.plural /^(ox)$/i, '\1en'
#   inflect.singular /^(ox)en/i, '\1'
#   inflect.irregular 'person', 'people'
#   inflect.uncountable %w( fish sheep )
# end

# These inflection rules are supported but not enabled by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.acronym 'RESTful'
# end
</code></pre>

<p>We can already see how to go about writing our inflections with the examples in this file, including some of the methods we can use, depending on what our edge case is. There are actually a lot of <a href="http://api.rubyonrails.org/classes/ActiveSupport/Inflector/Inflections.html">methods available</a> to us inside of our inflections block, some of the most helpful being <code>plural</code>, <code>singular</code>, <code>uncountable</code>, and <code>irregular</code>. In our case, we&rsquo;re dealing with an irregular inflection wherein <code>specimen</code> needs to be pluralized as <code>specimens</code>, so we&rsquo;ll use the <code>irregular</code> method, which takes two arguments: the singular and the plural form of the word as strings.</p>

<pre><code class="ruby">ActiveSupport::Inflector.inflections(:en) do |inflect|
  inflect.irregular 'specimen', 'specimens'
en
</code></pre>

<p>Awesome! Now our entire application will know about this inflection rule. And the really great thing about this is that our new rule that we just wrote is added at the top of this file, which means that our irregular rule for <code>specimen</code> will be the first of the singularization and pluralization rules that is run. This ensures that our rules will always run before any of the preexisting rules that come with <code>ActiveSupport::Inflector</code>.</p>

<p>Whew &mdash; that was quite an inflection adventure! But now the next time we have a grammar mistake, we can fix it easily, just like this slightly strange puppet (is a gopher? A beaver? I don&rsquo;t know!) keeps telling us to do:</p>

<iframe src="//giphy.com/embed/DIBVWfW8vtQli" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>ActiveSupport::Inflector</code> handles a lot of the grammar rules in Rails. The <code>inflections.rb</code> file is where we can write our own inflection rules. Check out all the preexisting inflections in the Rails <a href="https://github.com/rails/rails/blob/92f567ab30f240a1de152061a6eee76ca6c4da86/activesupport/lib/active_support/inflections.rb">source code</a>.</li>
<li>Curious how Rails knows what grammar rules to follow? Check out <a href="http://ilanasufrin.github.io/blog/2014/07/30/a-rails-grammar-lesson/">this blog post</a>, which explains it all.</li>
<li>If you are very brave, dig through the <a href="https://github.com/rails/rails/blob/6c75a111995a9aab09e19c2b6a8a42162f689bc6/activesupport/lib/active_support/inflector/inflections.rb">source code</a> for all of the methods available to <code>inflections</code>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unlocking Ruby Keywords: Begin, End, Ensure, Rescue]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/08/25/unlocking-ruby-keywords-begin-end-ensure-rescue/"/>
    <updated>2015-08-25T08:40:04-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/08/25/unlocking-ruby-keywords-begin-end-ensure-rescue</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/VAG0Ct1MbUCju" width="480" height="268" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>I recently went down a little bit of rabbit hole in order to do some <a href="http://vaidehijoshi.github.io/blog/2015/08/18/safer-sql-using-activerecord-transactions/">digging on database transactions</a>. And when I say &ldquo;a little bit&rdquo;, I mostly mean &ldquo;a lot bit&rdquo;. I opened up the Rails source code for <code>ActiveRecord::Transactions</code>, and I saw some interesting terms I hadn&rsquo;t seen in awhile.</p>

<p>Back when I was first learning Ruby a year ago, I remember reading about keywords. At the time, the only thing that <em>really</em> set them apart for me was the fact that they had special syntax highlighting in my text editor! (Yes, really.) But when I saw them again in the Rails source code, I thought it would be time to get a quick refresher on a few keywords that I saw again and again.</p>

<p>But first: what <em>are</em> keywords, exactly? Well, they&rsquo;re definitely not objects, but instead are reserved words, which are actually <a href="http://stackoverflow.com/a/9446185">defined in the Ruby parser</a>. In fact, there&rsquo;s a whole slew of keywords in Ruby, but the ones that I&rsquo;m the most interested in sharing with you are <code>begin</code>, <code>end</code>, <code>ensure</code>, and <code>rescue</code>. So let&rsquo;s start unlock the door to Ruby with these keywords!</p>

<!--more-->


<h2>Begin + End</h2>

<iframe src="//giphy.com/embed/shVNt6dRCNMbu" width="480" height="269" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>The <code>begin</code> and <code>end</code> blocks are and interesting way of defining a bunch of code that needs to run on it&rsquo;s own, in its own context. Between the <code>begin</code> and <code>end</code> keywords, we can put all the code that we need to run on its own. Just like with normal methods, whatever is the last expression that is evaluated in the <code>begin end</code> block is the result that will be return.</p>

<pre><code class="ruby">def method_name
    begin
        # our method logic goes here
    end
end
</code></pre>

<p>Interestingly, the <code>def method_name end</code> keyword syntax of defining a method is also nothing more than a <code>begin end</code> block! I think that this <a href="http://rubylearning.com/satishtalim/ruby_exceptions.html">RubyLearning tutorial</a> explains this pretty well:</p>

<blockquote><p>&ldquo;It is to be noted that the body of a method definition is an implicit begin-end block; the begin is omitted, and the entire body of the method is subject to exception handling, ending with the end of the method.&rdquo;</p></blockquote>

<p>So, if the <code>begin end</code> syntax is just like writing a regular Ruby method, when would we ever use it? Well, it turns out that the <code>begin end</code> block can be helpful for defining chunks of code that need to execute in a certain order. For example, if we wanted to write a method that would split a group of <code>Book</code> objects into various batches, we might have something like this:</p>

<pre><code class="ruby">def create_or_update_batch
    if @batch.nil?
        @batch = BookBatch.create(book_batch.batch_attrs)
    end

    @batch.update
end
</code></pre>

<p>What we&rsquo;re trying to do here is twofold: first, we want to calculate our <code>BookBatch</code> based on some attributes (<code>batch_attrs</code>) that we&rsquo;re passing in, and then <code>create</code> it. And once we&rsquo;ve done that, we want to <code>update</code> it.</p>

<p>We&rsquo;re always going to want to <code>create</code> our <code>BookBatch</code> if it doesn&rsquo;t already exist, definitely before we go about updating it. We can use the <code>begin end</code> syntax to do the same thing:</p>

<pre><code class="ruby">def create_or_update_batch
  @batch ||= begin
    BookBatch.create(book_batch.batch_attrs)
  end

  @batch.update
end
</code></pre>

<p>In this case, if a <code>@batch</code> instance doesn&rsquo;t already exist, the code between the <code>begin end</code> will run and then the return value (a new <code>BookBatch</code> instance) will be assigned to the <code>@batch</code> instance variable. Only then will the <code>@batch.update</code> line be run.</p>

<p>It turns out that this kind of <a href="http://stackoverflow.com/a/13279295">method architecture</a> takes advantage of the Ruby interpreter&rsquo;s stack. The <code>||=</code> assignment that we are using before the <code>begin end</code> block just takes the last thing from the stack (in this case, <code>BookBatch.create</code>), and assigns it to <code>@batch</code>. Because the code in the <code>begin end</code> block runs independently in its own context, we can use it to contain and encapsulate a bit of logic. This is especially helpful if we want to <code>rescue</code> from an error!</p>

<h2>Rescue</h2>

<iframe src="//giphy.com/embed/3o85xAwT5hvVXhyuli" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>The <code>rescue</code> keyword is pretty cool, and is used by Rubyists quite a lot. It functions to handle exceptions, and takes a single argument: the class/type of error that you want to rescue from.</p>

<pre><code class="ruby">
def create_or_update_batch
  @batch ||= begin
    BookBatch.create(book_batch.batch_attrs)
  end

  @batch.update

rescue
    raise_book_batch_error
end
</code></pre>

<p>One important thing about <code>rescue</code>: it&rsquo;s always written at the same level as our method signature! In the example above, we have written our own <code>raise_book_batch_error</code> method, which will handle the exception once we&rsquo;ve recused from this method. We can pass a specific type of error, or we can allow <code>rescue</code> to default. If you don&rsquo;t pass any parameters to the <code>rescue</code> clause, it defaults to <code>StandardError</code> and will rescue any error by default.</p>

<p>Another important note about <code>rescue</code> is that is occurs at the same level as our method signature. So, if we want to <code>rescue</code> from our <code>create_or_update_batch</code> method, we need to have <code>rescue</code> on the same level as <code>def create_or_update_batch</code>. We could also rescue from <em>inside</em> of a <code>begin end</code> block:</p>

<pre><code class="ruby">
def create_or_update_batch
  @batch ||= begin
    BookBatch.create(book_batch.batch_attrs)

  rescue ActiveRecord::AttributeAssignmentError
  end

  @batch.update

rescue
    raise_book_batch_error
end
</code></pre>

<p>In this case, the <code>rescue</code> clause inside of our <code>begin end</code> block will rescue any exceptions in its own context. It&rsquo;s also important to note that only one <code>rescue</code> clause of a group will ever be executed.</p>

<h2>Ensure</h2>

<iframe src="//giphy.com/embed/oToYqq3jbiRry" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>


<p>All of these blocks can start to be a little much after awhile. Sometimes, all you want to do is make sure that a specific piece of code will always run! Luckily, that&rsquo;s what the <code>ensure</code> keyword is for. This keyword starts a section of code that is always run when an exception is raised. And just like <code>rescue</code>, it&rsquo;s written at the same level as our method&rsquo;s signature.</p>

<pre><code class="ruby">
def create_or_update_batch
  @batch ||= begin
    BookBatch.create(book_batch.batch_attrs)
  end

  @batch.update

rescue
    raise_book_batch_error

ensure
    clean_up_orphaned_book_batches
end
</code></pre>

<p>In the example above, we&rsquo;re ensuring that even if a <code>BookBatch</code> was created and didn&rsquo;t get associated in the correct way and was orphaned, the <code>clean_up_orphaned_book_batches</code> method would always run. A good way to think about the <code>ensure</code> keyword is that its the last thing that will run in the method, and it will run no matter what, every single time.</p>

<p>The unique thing about <code>ensure</code> is that it runs <em>even if</em> there were any errors that were raised. The best practice is to usually put <code>ensure</code> at the end, so that the last part of the method will run.</p>

<p>The <code>begin</code>, <code>end</code>, <code>rescue</code>, and <code>ensure</code> methods are a little tricky to understand all together. But once we break them apart and figure out how they work on their own, things start to make a little more sense. Hopefully, diving into the rabbit hole of the Rails source code will be a little easier now. At the very least, we now have the keys to the wonderful world of Ruby keywords!</p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>begin end</code> block can be used to execute a block of code in a specific context. <code>Rescue</code> can be used to handle errors, while <code>ensure</code> will always run at the end of a method. The Ruby documentation has the complete list of Ruby keywords, and it&rsquo;s clearly and thoroughly written. Check it out <a href="https://github.com/ruby/ruby/blob/trunk/doc/keywords.rdoc">over here</a>!</li>
<li>Check out this great <a href="http://blog.rubybestpractices.com/posts/rklemme/003-The_Universe_between_begin_and_end.html">blog post</a> with lots of examples on <code>begin</code> and <code>end</code>, and how to use them in the context of a method.</li>
<li>Curious how <code>ensure</code> works in the context of an application? Here&rsquo;s a <a href="https://blog.newrelic.com/2014/12/10/weird-ruby-2-rescue-interrupt-ensure/">blog post</a> that dives into exactly that!</li>
</ul>

]]></content>
  </entry>
  
</feed>
