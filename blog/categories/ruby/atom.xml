<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-06-08T22:34:56-04:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Refactoring to Reveal Rails Group_by]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/06/09/refactoring-to-reveal-rails-group-by/"/>
    <updated>2015-06-09T08:43:24-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/06/09/refactoring-to-reveal-rails-group-by</id>
    <content type="html"><![CDATA[<p><img src="http://img.pandawhale.com/post-10513-Code-Refactoring-Cat-in-Bathtu-U295.gif" style="display: block; margin-left: auto; margin-right: auto;"/></p>

<p>There are a lot of opportunities in programming to feel pretty silly about yourself. I&rsquo;m sure that the more coding experience you have, the less often these moments actually occur. But early on in your career, they seem to happen quite often &ndash; or they do to <em>me</em>, at least.</p>

<p>I had one of those moments a couple weeks ago, when I wrote a super long method and then asked a senior developer to take a look at it. While I was writing it, something seemed inherently wrong. I was sure there was a better way to do it, but I guess my Googling skills aren&rsquo;t quite superb yet, because I couldn&rsquo;t find quite the right answer anywhere. It was then that I decided to ask someone who would know exactly which tool to reach for.</p>

<p>What happened next was pretty awesome, albeit slightly depressing. I watched my code be refactored from ten lines down to a single line. It blew my mind &ndash; and not just because I didn&rsquo;t know that this method even <em>existed</em>, but because I wanted to know how it worked! So, I did some digging and learned a bit about the method that I wrote which, as it turns out, already existed: the Rails <code>group_by</code> method on Enumerables.</p>

<!--more-->


<h2>Data Is For Manipulating</h2>

<p>I started off writing my super long method because I wanted to structure my data in a very specific way. In fact, we&rsquo;ll probably want to structure the data in our Bookstore eCommerce app in a very similar way, too, so let&rsquo;s use that as our working example.</p>

<p>For our admin panel, we want a list of <code>Author</code> objects, categorized by <code>genre</code>. Because our collection of <code>Books</code> is going to grow extensively, it would be helpful for an admin to know which authors are included in a <code>genre</code> or time period. Eventually, this could be used by admins to add new authors by a genre, to filter or sort by a genre, or to calculate an author count per genre, and figure out which authors to add to our collection of books.</p>

<p>Right now, our collection of <code>Author</code> objects isn&rsquo;t very big, but has just enough information for us to start implementing this functionality:</p>

<pre><code class="ruby">&gt; Author.all
=&gt; [{#&lt;Author:0x192ajk21a6d0b0 last_name: "Shakespeare", genre: "Renaissance"&gt;}, 
{#&lt;Author:0w917qwl38f6s8v6 last_name: "Homer", genre: "Classics"&gt;}, 
{#&lt;Author:0x390akd23a5d9m4 last_name: "Faulkner", genre: "Southern Gothic"&gt;}, 
{#&lt;Author:1r103aur58b7c4r2 last_name: "Marlowe", genre: "Renaissance"&gt;}]
</code></pre>

<p>Even though our data is easy to read now, we can be sure that it isn&rsquo;t going to stay that way. But we know that if we structure each of our objects correctly, we could have something simple, like this, in our view:</p>

<pre><code class="ruby">div
  - Author.sort_by_genre.each do |genre, author|
    h2 = genre
    - author.each do |a|
      p = a.last_name
</code></pre>

<p>I&rsquo;m a big fan of slim, which is what I&rsquo;ve used above, but this view would still be pretty minimal when using another templating language such as erb.</p>

<p>Given that this is the view we want to render, we can use this information to structure our data. I&rsquo;m thinking a hash is the tool for the job, with each key being a <code>genre</code> name, and the value being an array of <code>Author</code> objects that we can iterate through for each specific <code>genre</code>.</p>

<p>It would be nice if we could call something like <code>Author.sort_by_genre</code> and have it return a structure like this:</p>

<pre><code class="ruby">=&gt; {"Renaissance": [Shakespeare, Marlowe], 
"Southern Gothic": [Faulkner], 
"Classics": [Homer]}
</code></pre>

<p>So now that we know what we <em>want</em> our data to look like, let&rsquo;s write it the ugly way, just like I did!</p>

<h2>The First Iteration</h2>

<p>To start with, we know that we want to return a hash. So we can start by instantiating a hash, which will be our <code>authors_by_genre</code>. We also know that we&rsquo;ll need all the <code>Author</code> objects in an array; since we&rsquo;re specifically looking for an author&rsquo;s <code>last_name</code> and <code>genre</code>, we can query for those directly. And we can return our empty hash, since that will eventually be filled up:</p>

<pre><code class="ruby">def sort_by_genre
  authors_by_genre = {}
  authors = Author.all.collect { |author| [author.last_name, author.genre] }

  authors_by_genre
end
</code></pre>

<p>Okay, so now we need to fill up our hash. We have our <code>authors</code> variable, which is set to the collection of all <code>Author</code> objects. We will need to iterate through all of them, and put that <code>Author</code> in the correct array for the right <code>genre</code> key. If the right <code>genre</code> key doesn&rsquo;t exist, we&rsquo;ll need to create a key for that author&rsquo;s <code>genre</code>. We can accomplish this with another iteration. Now our method looks like this:</p>

<pre><code class="ruby">class Author
  class &lt;&lt; self
    def sort_by_genre
      authors_by_genre = {}
      authors = Author.all.collect { |author| [author.last_name, author.genre] }

      authors.each do |genre, author|
        if authors_by_genre[genre]
          authors_by_genre[genre] &lt;&lt; author
        else
          authors_by_genre[genre] = [author]
        end
      end

      authors_by_genre
      end
    end
  end
end
</code></pre>

<p>Okay&hellip;so hopefully, by this point, you should be thinking to yourself: <em>This isn&rsquo;t just ugly, it&rsquo;s also <strong>super</strong> inefficient</em>. And you&rsquo;d be right. It&rsquo;s pretty bad.</p>

<iframe src="//giphy.com/embed/asIa0FVaBSQNO" width="480" height="307" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>If you weren&rsquo;t sure how bad it really is, think about all the queries we&rsquo;re making! And how many times we&rsquo;re iterating! As soon as I finished writing this and got it working, I knew it was <em>definitely</em> not the right approach. But the first step is to get it working. Now, we need to seriously consider how we can make it right and make it fast.</p>

<p>You know what what this means, right? Refactoring time.</p>

<h2>Group All The Things</h2>

<p>A quick way to refactor some of the messiness from our first iteration is by first changing how we initialize our hash object, and also modifying how we go about deciding whether to create a new key or add to a key that already exists.</p>

<p>Enter the <code>each_with_object</code> method! This is a pretty rad method I learned about while refactoring my first iteration of this <code>sort_by_genre</code> method. The <code>each_with_object</code> method requires a single argument: the object that you want to pass to it in each iteration. In our case, we&rsquo;ll pass it a hash. And since the items we want to actually &ldquo;categorize&rdquo; are our <code>Author</code> objects, we&rsquo;ll call <code>each_with_object</code> on our collection of <code>Authors</code>:</p>

<pre><code class="ruby">class Author
  class &lt;&lt; self
    def sort_by_genre
      Author.all.each_with_object({}) {  }
    end
  end
end
</code></pre>

<p>Now, what about that block &ndash; what goes inside? Well, we can think about what we want to do with each of our <code>Author</code> objects that we&rsquo;re iterating over. Inside of our hash, which we&rsquo;re passing explicitly as an argument to <code>each_with_object</code>, we want to either find the correct key and put the correct <code>Author</code> into that array, or create a new key based on the current <code>Author</code> object&rsquo;s genre. We can write that quite nicely by using the <code>||=</code> <strong>or equals</strong> operator, which will assign a new object, or whatever is to the right of the operator, equal to the left side of the pipes, or whatever is to the left of the operator:</p>

<pre><code class="ruby">class Author
  class &lt;&lt; self
    def sort_by_genre
      Author.all.each_with_object({}) { |author, hash| (hash[author.genre] ||= []) &lt;&lt; author }
    end
  end
end
</code></pre>

<p>Much better, right? In this second iteration, we&rsquo;re passing a hash directly to the <code>each_with_object</code> method, and basically telling it, <em>Find the key in the hash I just passed you that is equal to this author&rsquo;s genre. And if no such key exists, make one, set it equal to an empty array, and then put this current author into that array</em>.</p>

<p>The order of our or equals operator is particularly important, because if it were switched, it would never run what is on the right side of the pipes. The <code>||=</code> operator is exactly like the <code>||</code> operator in that it will run what is to its right <em>only</em> if what is to its left evaluates to <code>false</code>. This is what keeps our method from trying to create multiple keys again and again, and instead forces it to find an existing key first. The super cool thing about the <code>||=</code> operator is that it is actually assigning a new key value to an empty array, which cuts out a lot of extra lines we had in our first iteration!</p>

<p>Okay, so this second iteration has been a vast improvement. But I think it&rsquo;s time for some serious refactoring magic. Are you ready? Okay. This <em>entire</em> method can be rewritten into a single, simple line:</p>

<pre><code class="ruby">class Author
  class &lt;&lt; self
    def sort_by_genre
      Author.all.group_by(&amp;:genre)
    end
  end
end
</code></pre>

<p>Yup. I kid you not.</p>

<iframe src="//giphy.com/embed/sHytgXD2vlNVC" width="480" height="376" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>This is the magic of the Rails <code>group_by</code> method, which collects an enumerable into sets, grouping it by the result of a block. This method takes a proc using the ampersand shortcut as an argument (which we started using last week!). The <code>group_by</code> method is passed the symbol <code>:genre</code>, which is an attribute on each <code>Author</code> object, and corresponds to a <code>genre</code> column in the <code>authors</code> table. So, we are effectively grouping all of our <code>Author</code> objects by the result of calling <code>.genre</code> on each object. In other words, we&rsquo;re grouping by the <code>genre</code> attribute since the attribute corresponds to an <code>attr_accessor</code> method in the class.</p>

<p>And now, if we call our <code>sort_by_genre</code> class method, we get the exact data structure we were hoping for:</p>

<pre><code class="ruby">&gt; Author.sort_by_genre
=&gt; {"Renaissance": [{#&lt;Author:0x192ajk21a6d0b0 last_name: "Shakespeare", genre: "Renaissance"&gt;}, 
{#&lt;Author:1r103aur58b7c4r2 last_name: "Marlowe", genre: "Renaissance"&gt;}], 
"Southern Gothic": [{#&lt;Author:0x390akd23a5d9m4 last_name: "Faulkner", genre: "Southern Gothic"&gt;}], 
"Classics": [{#&lt;Author:0w917qwl38f6s8v6 last_name: "Homer", genre: "Classics"&gt;}]}
</code></pre>

<p>Hooray! Or maybe not hooray. Maybe instead of hooray, you feel like I did when I realized that you could refactor all of this into one line:</p>

<blockquote class="twitter-tweet tw-align-center" lang="en"><p lang="en" dir="ltr">PROGRAMMING:&#10;Write a 10-line method.&#10;Feel proud when it works.&#10;Find out you can write the same thing in a single line.&#10;Cry in the corner.</p>&mdash; Vaidehi Joshi (@vaidehijoshi) <a href="https://twitter.com/vaidehijoshi/status/601156228723642369">May 20, 2015</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p><br></p>

<p>Although it made me feel pretty silly, the actual process of writing the <code>group_by</code> method from scratch was a really great learning experience. I ended up using the examples above in a talk I gave on refactoring at <a href="http://www.twitter.com/reddotrubyconf">Red Dot Ruby Conference</a> in Singapore last week. And I actually recreated the <em>exact same</em> functionality when I had to write my <em>own</em> <code>groupBy</code> function in JavaScript for a React component I had to build! I guess that however deep of a rabbit hole refactoring can be, sometimes it&rsquo;s exactly the right kind of deep dive you need to learn how something works under the hood. I still totally feel like that cat in the bathtub whenever I do it &ndash; but I&rsquo;m kind of okay with that.</p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>group_by</code> method takes a block, which it uses to group a collection of objects. The <code>each_with_object</code> method takes an object as an argument, and a block which tells it how to sort the collection you call the method upon.</li>
<li>Read more on the <code>group_by</code> method in the <a href="http://apidock.com/rails/Enumerable/group_by">Rails docs</a>, which also has a great example!</li>
<li>Looking for another example of how to implement Rails&#8217; <code>group_by</code> in a view? Check out <a href="https://ariejan.net/2007/01/12/rails-group-results-by-week-using-group_by/">this blog post</a>.</li>
<li>Did you know that Ruby also has a similar <code>group_by</code> method? It&rsquo;s great when you want to <a href="http://ruby-doc.org/core-2.2.2/Enumerable.html#method-i-group_by">return a hash</a> where the keys are evaluated by a block!</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Smells and Ruby Shorthand: Unpacking Ampersand + To_proc]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/06/02/code-smells-and-ruby-shorthand-unpacking-ampersand-plus-to-proc/"/>
    <updated>2015-06-02T08:45:24-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/06/02/code-smells-and-ruby-shorthand-unpacking-ampersand-plus-to-proc</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/918rCUjV2XWhi" width="480" height="360" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>There aren&rsquo;t too many things that bring me down when I&rsquo;m deep into programming. But there&rsquo;s always one thing that&rsquo;ll stop me dead in my tracks: a code smell. In the context of programming, a code smell is something that tells you that your code is&hellip;well, a bit <em>off</em>.</p>

<p>Whether you&rsquo;ve been programming for months or for decades, you&rsquo;ll run into &ldquo;code that smells&rdquo; again and again. Except the better that you get, you&rsquo;ll anticipate your code smelling, or before you even write it, you&rsquo;ll know that it&rsquo;s going to stink. For me, a lot of my code that tends to smell are sections where I&rsquo;ve duplicated what I&rsquo;ve written, which is to say that I&rsquo;ve written something that&rsquo;s identical or at least very, very similar to another piece of code in my application. I&rsquo;ve noticed that I&rsquo;ve started catching myself as I write duplicated code, which is a sign that I&rsquo;m getting better as a developer &ndash; hooray!</p>

<p>But, there are a lot of <a href="http://en.wikipedia.org/wiki/Code_smell#Common_code_smells">common code smells</a>, and I definitely still can&rsquo;t catch all of them in my own code. Generally, if any part of your program has a common code smell, it&rsquo;s a sign that you need to rethink how your system is structured on a deeper level, and that it&rsquo;s probably time to start refactoring.</p>

<p>Recently, I&rsquo;ve noticed that I&rsquo;ve been sniffing out the same issue in my code: long methods. So I did a bit of investigating and found that there are some cool ways to shorten up your longer methods. Thanks to Ruby magic, we have easy access to methods like <code>to_proc</code> in the form of &ldquo;ampersand and object&rdquo;, or the <strong>&amp;:</strong> syntax. If you have no clue what those are, don&rsquo;t worry. I didn&rsquo;t either! Until I wrote this post, obvs.</p>

<!--more-->


<h2>A Slim Method Is A Beautiful Method</h2>

<p>In our eCommerce bookstore app, we&rsquo;re storing our <code>Order</code> <code>amount</code> totals as BigDecimals. You might remember why BigDecimals <a href="http://vaidehijoshi.github.io/blog/2015/02/10/money-makes-the-world-go-round-using-money-rails-and-bigdecimal/">are better than floats</a> when it comes to performing accurate monetary calculations. But even though we&rsquo;re using BigDecimal on the backend, there may be times when we want to convert our decimals back into floats. Like what if we want to start integrating a JavaScript frontend? (yes, I went there). The point is, we should be able to do something like that pretty easily, especially if we wanted to serialize and return a JSON object that has the correct object type.</p>

<p>We&rsquo;d probably start by iterating through all of our order amounts and turn them into floats, like this:</p>

<pre><code class="ruby">class Order
    class &lt;&lt; self
        def amounts_to_floats
            Order.all.map do |order|
                order.amount.to_f
            end
        end
    end
end
</code></pre>

<p>Well, it does the job. But&hellip;it doesn&rsquo;t look so great, does it? Let&rsquo;s cut it down:</p>

<pre><code class="ruby">class Order
    class &lt;&lt; self
        def amounts_to_floats
            Order.all.map {|order| order.amount.to_f }
        end
    end
end
</code></pre>

<p>Okay, let&rsquo;s make it a little fancier and throw in the <code>pluck</code> method, which will query for only the to grab <em>only</em> an <code>Order</code>&rsquo;s <code>amount</code>?</p>

<pre><code class="ruby">class Order
    class &lt;&lt; self
        def amounts_to_floats
            Order.pluck(:amount).map {|amount| amount.to_f }
        end
    end
end
</code></pre>

<p>I guess it&rsquo;s better, but still not as good as it could be. Are you thinking what I&rsquo;m thinking? There&rsquo;s <em>gotta</em> be a better way!</p>

<p><img src="http://provensal.com/lbb/wp-content/uploads/2013/03/better_way.jpg" style="display: block; margin-left: auto; margin-right: auto;"></p>

<h2>A Proc And An Object Walk Into A Bar&hellip;</h2>

<p>As is the case with most things in programming, if we wish for a better way to do something, we can generally assume that there is! And in our case, the better way to do it is by using something called <strong>ampersand and object</strong>.</p>

<p>And we can implement it on our <code>amounts_to_floats</code> method like so:</p>

<pre><code class="ruby">class Order
    class &lt;&lt; self
        def amounts_to_floats
            Order.pluck(:amount).map(&amp;:to_f)
        end
    end
end
</code></pre>

<p>The result of this will be the exact same thing as the <code>map</code> we wrote above:</p>

<pre><code class="ruby">&gt; Order.amounts_to_floats
=&gt; [210.99, 150.5, 24.99, 391.99, 120.25]
</code></pre>

<p>So, what happened here? Well, let&rsquo;s just start with what we know for sure.</p>

<ol>
<li><p>We took all the <code>Order</code> objects and queried for just their <code>amounts</code>, which are in <code>BigDecimal</code> format.</p></li>
<li><p>The <code>pluck</code> method returns an array of the attributes that you query for, so, which would mean that our array would look something like this:
<code>[#&lt;BigDecimal:7f87ed12b2f0,'0.21099E3',18(18)&gt;, #&lt;BigDecimal:7f87ed121700,'0.1505E3',18(18)&gt;, #&lt;BigDecimal:7f87ed119348,'0.2499E2',18(18)&gt;...]</code></p></li>
<li><p>Okay, so then we mapped over all of these amounts, right? And somehow we called <code>.to_f</code> on all of them. Which returned the array that we were hoping for:
<code>[210.99, 150.5, 24.99, 391.99, 120.25]</code></p></li>
</ol>


<p>All of this begs one question: how on earth did the <code>&amp;</code> (ampersand) know to call <code>to_f</code> on each of our objects? And how did <code>map</code> know what to do with the ampersand that we passed it?</p>

<p>Time to find out.</p>

<h2>Procs on Procs</h2>

<iframe src="//giphy.com/embed/umwRSMxcXW31m" width="480" height="244" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Whenever something seems super daunting, I go back to the basics. Which is exactly what I think we should do here, too. We can all agree that in Ruby is an object, right? And methods are how we send messages to objects. With that in mind, let&rsquo;s look back at that confusing line of code:</p>

<pre><code class="ruby">Order.pluck(:amount).map(&amp;:to_f)
</code></pre>

<p>We know <code>Order.pluck(:amount)</code> to be an array &ndash; it&rsquo;s an object, which means it&rsquo;s the <em>receiver</em> of our method. That means that <code>.map</code> is our method. And <code>map</code> has been passed <code>&amp;:to_f</code>, which seems to have replaced the usual <code>do end</code> or <code>{}</code> blocks that generally accompany the <code>map</code> iterator.</p>

<p>At this point, if you&rsquo;re thinking that the <code>&amp;</code> ampersand is responsible for executing that <code>to_f</code> method on each of the elements of the array, you&rsquo;re definitely onto something.</p>

<p>In fact, the <code>&amp;</code> calls <em>another</em> method on the object: <code>to_proc</code>. The ampersand calls <code>to_proc</code> on whatever comes after it. In our case, it&rsquo;s the <code>to_f</code>. But it&rsquo;s not just the plain old method <code>to_f</code> &ndash; it&rsquo;s actually the <em>symbol</em>, <code>:to_f</code>.</p>

<p>And we can double check this by looking at <a href="http://ruby-doc.org/core-1.9.3/Symbol.html#method-i-to_proc">the Ruby docs</a>! The <code>to_proc</code> method is defined on the <code>Symbol</code> class:</p>

<blockquote><p><code>to_proc</code> Returns a Proc object which responds to the given method by sym.</p></blockquote>

<p>So all the <code>&amp;</code> is doing is: <code>:to_f.to_proc</code>. It turns the symbol into a proc, and whatever object you pass to it, it&rsquo;ll call that method on that object. You&rsquo;re basically telling the <code>map</code> function, <em>Hey, I already have this method I want to call on every single item you&rsquo;re iterating over. So when you invoke yourself on the receiving object, run this code that I&rsquo;m passing you.</em></p>

<p>Because <code>:to_f</code> isn&rsquo;t actually a block, the ampersand tries to make it a block by calling <code>to_proc</code> on it. This means that you can pass any method to <code>&amp;</code> in symbol form, and it will convert it to and invoke that proc.</p>

<p>But what if you didn&rsquo;t want to pass it a defined method in Ruby as a symbol? What if, instead, you wanted to write your own block and pass it to <code>&amp;</code> explicitly? That would look something like this:</p>

<pre><code class="ruby">half_off_sale = Proc.new { |amount| amount/2 }

Order.pluck(:amount).map &amp;half_off_sale
=&gt; [#&lt;BigDecimal:7f87ec20e4c0,'0.105495E3',18(45)&gt;, #&lt;BigDecimal:7f87ec20e3d0,'0.7525E2',18(45)&gt;, #&lt;BigDecimal:7f87ec20e2e0,'0.12495E2',18(45)&gt;...]
</code></pre>

<p>Pretty cool, right? In this case, we created a <code>half_off_sale</code> proc, that we passed directly to the ampersand. The <code>&amp;</code> didn&rsquo;t have to make it a proc (meaning that it didn&rsquo;t have to invoke <code>to_proc</code>) since we already passed it one. So when <code>map</code> iterated through all the amounts, it yielded to our <code>half_off_sale</code> proc, and ran that code on every single element in our array of amounts.</p>

<p>As you can see, the ampersand and object and <code>to_proc</code> methods can be pretty powerful &ndash; particularly when they&rsquo;re combined into this handy little shortcut! That doesn&rsquo;t mean you have to use them all the time, but if you understand the fundamentals of how they work, they can really help clean up your code, especially when it&rsquo;s pretty smelly.</p>

<p>This is just a primary introduction to the concepts of ampersand and object and <code>to_proc</code>. There&rsquo;s definitely a lot more to them, and they can get quite complicated. I&rsquo;m still learning about them myself! But, I&rsquo;m going to keep reading about how procs work and, hopefully, there&rsquo;ll be a forthcoming Technical Tuesdays post about how to pass methods to procs! Until then, keep sniffin&#8217; out those code smells, my friends!</p>

<iframe src="//giphy.com/embed/LeaMGoMmMGrf2" width="480" height="360" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>The <code>&amp;</code> (ampersand) can be used with an iterator like <code>map</code>, and will call <code>to_proc</code> on whatever symbol you pass it, unless you pass it a block explicitly.</li>
<li>More examples and explanations on <a href="http://stackoverflow.com/questions/9429819/what-is-the-functionality-of-operator-in-ruby">these</a> <a href="http://stackoverflow.com/questions/2259775/what-do-you-call-the-operator-in-ruby">two</a> StackOverflow posts.</li>
<li>Here&rsquo;s a <a href="http://www.dan-manges.com/blog/29">great blog post</a> on all the ways you can use <code>&amp;</code> to manipulate ActiveRecord models.</li>
<li>If you&rsquo;re still curious about different ways to pass around procs, check out <a href="http://ablogaboutcode.com/2012/01/04/the-ampersand-operator-in-ruby/">this post</a>, which is what I used when I was learning about them!</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Investigating Ruby's Global Functions + Kernel Module With Puts]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/05/12/investigating-rubys-global-functions-plus-kernel-module-with-puts/"/>
    <updated>2015-05-12T08:09:27-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/05/12/investigating-rubys-global-functions-plus-kernel-module-with-puts</id>
    <content type="html"><![CDATA[<iframe src="//giphy.com/embed/10Vy7fN9fr7dD2" width="480" height="361" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>When you&rsquo;re a relatively new developer, it&rsquo;s easy to get caught up in all of the things that you don&rsquo;t know. And boy is <em>that</em> a long, long list of things. But there&rsquo;s also another list that we should probably consider and revisit from time to time: the list of all the things we thought we knew, but didn&rsquo;t <em>really</em> understand when we learned them.</p>

<p>Last week, while developing some curriculum for an Intro to Programming course, my co-teacher and I had one of those moments. We were trying to draw a diagram to explain the concept of an object &ldquo;receiving&rdquo; a method. As I looked back through our code snippets, I noticed that we were using very basic methods like <code>puts</code> and <code>gets</code> quite often, as most Ruby tutorials usually do. And then I realized something: I had no clue what the receiver of the <code>puts</code> method was.</p>

<p>We both just sat there, partly perplexed and partly dumbfounded. How could we not know how <code>puts</code> and <code>gets</code> really worked? We used them all the time when we were learning to code, so perhaps we didn&rsquo;t really think past the flexibility of these methods. But now that we are both more seasoned programmers, it seemed strange that we had never really thought about this before.</p>

<p>So, I did exactly what any good developer would do: I asked Twitter. Well, okay, I asked Twitter&hellip;and then I put on my detective hat and did some investigating of my own.</p>

<!--more-->


<h2>Puts, I love you, but you&rsquo;re bringing me down</h2>

<blockquote class="twitter-tweet tw-align-center" lang="en"><p lang="en" dir="ltr">RUBYISTS, please help: what is the receiver of the puts and gets methods? Is it the main Object? I need to know, it&#39;s driving me crazy</p>&mdash; Vaidehi Joshi (@vaidehijoshi) <a href="https://twitter.com/vaidehijoshi/status/596465002669875201">May 8, 2015</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>I have a bone to pick with the <code>puts</code> method. Well, okay, two bones I guess. First, it has no explicit receiver:</p>

<pre><code>♥ irb
2.2.0 :001 &gt; puts "wat"
wat
 =&gt; nil 
</code></pre>

<p>And second, it&rsquo;s just REALLY hard to figure out what on earth is happening with this method. In fact, the hardest part about understanding <code>puts</code> was figuring out exactly <em>where</em> inside of Ruby it lived.</p>

<p>Apparently though, there&rsquo;s a method for that &ndash; well, two methods, actually. The <code>owner</code> and the <code>receiver</code> methods can be used to ask a method where it lives and who it can be called on. We can just pass it the name of the method we&rsquo;re curious about as a symbol, and then ask it where it belongs:</p>

<pre><code>2.2.0 :002 &gt; method(:puts).receiver
 =&gt; main 

2.2.0 :003 &gt; method(:puts).owner
 =&gt; Kernel 
</code></pre>

<p>WAT. It seemed like <code>main</code> was the receiver of this method, while <code>Kernel</code> was the owner, or the place where this method was actually defined.</p>

<p>But did that mean that <code>main</code> was also self within the context of <code>irb</code>? And what <em>was</em> <code>main</code>, exactly? There was only one way to find out:</p>

<pre><code>2.2.0 :004 &gt; method(:gets).receiver == self
 =&gt; true 

2.2.0 :005 &gt; self
 =&gt; main 

2.2.0 :006 &gt; self.class
 =&gt; Object
</code></pre>

<p>Pretty weird, right? But hang on&hellip;there was a line up there that was pretty new for me. Something about a <code>Kernel</code>? Let&rsquo;s do a bit more detective work.</p>

<h2>Tell Me &lsquo;Bout Them Kernels</h2>

<iframe src="//giphy.com/embed/rambtrormFyWQ" width="480" height="268" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Okay, you&rsquo;re probably wondering: <em>So that <code>Kernel</code> thing &ndash; what&rsquo;s the deal?</em> Well, it turns out that <code>Kernel</code> is a module, and if you&rsquo;re like me, you probably haven&rsquo;t thought about it that much until now.</p>

<p>But what you might remember about modules is that they have to be mixed into a class in order to be included; that is to say, in order for a class or instances of a class to have access to methods in a module, that module has to be included or extended into the class.</p>

<p>Which means that <code>Kernel</code> has to be included into a Ruby class. But&hellip;which one? To figure out, we need to think back to what <code>self</code> was within the context of <code>irb</code>: <code>main</code>. If we try to ask <code>main</code> for its ancestors (so that we can deduce where the <code>Kernel</code> module is coming into play), we get this error:</p>

<pre><code>2.2.0 :007 &gt; main.ancestors
NoMethodError: undefined method `ancestors' for main:Object
  from (irb):75
  from /usr/bin/irb:12:in `&lt;main&gt;'
</code></pre>

<p>Okay, not so great. But hang on a second&hellip;since we know that <code>main</code> is an instance of the <code>Object</code> class, we can just ask the <code>Object</code> class who its ancestors are!</p>

<pre><code>2.2.0 :008 &gt; Object.ancestors
 =&gt; [Object, Kernel, BasicObject] 
</code></pre>

<p>Nice! We found <code>Kernel</code>, and it looks like it&rsquo;s included the <code>Object</code> class. We can figure this out because it appears to the right of <code>Object</code>, which means it has been mixed into the class to its left.</p>

<p>So, if a method like <code>puts</code> is written in the <code>Kernel</code> module, what can it be called on? Who is doing the &ldquo;receiving&rdquo; of this method call? Well, according to <a href="http://ruby-doc.com/docs/ProgrammingRuby/html/ref_m_kernel.html">the Ruby docs</a>, pretty much anything:</p>

<blockquote><p>The Kernel module is included by class Object, so its methods are available in every Ruby object. These methods are called without a receiver and thus can be called in functional form.</p></blockquote>

<p>So, theoretically-speaking, if the Kernel module is included by class Object, and is therefore available to <em>every</em> Ruby object, we should be able to call <code>puts</code> on a <code>String</code> instance, right?</p>

<pre><code>2.2.0 :009 &gt; "".puts('wat')
NoMethodError: private method `puts' called for "":String
  from (irb):79
  from /usr/bin/irb:12:in `&lt;main&gt;'
</code></pre>

<p>Uh oh! Maybe we can&rsquo;t. But&hellip;why not?</p>

<h2>Global Functions</h2>

<p>If you are smart cookie, you probably read that error and guessed that <code>puts</code> is a private method defined on <code>Kernel</code>. We can confirm this by using the <code>private_method_defined?</code> method to double check:</p>

<pre><code>2.2.0 :010 &gt; Kernel.private_method_defined?(:puts)
 =&gt; true
</code></pre>

<p>The fact that <code>puts</code> is a private method is important. It means that it can&rsquo;t be called explicitly by anyone else. But how is it, then, that we use this method so frequently and easily? Well, because its mixed in to class <code>Object</code>, it&rsquo;s accessible to any Ruby object &ndash; but only in the current context. This explains why <code>puts</code> never has to be called explicitly upon any object; instead, it will be called <em>implicitly</em> on whatever <code>self</code> happens to be. In other words, the method will be called on the current context of <code>self</code>.</p>

<p>It&rsquo;s also pretty crucial that a method like <code>puts</code> can be called in the current context of self. In fact, that&rsquo;s exactly what allows us to do this within a Ruby class:</p>

<pre><code class="ruby">Class Duck
  def self.swim
    puts "We're swimming."
  end

  def quack
    puts "Quack quack!"
  end
end
</code></pre>

<p>or something like this in <code>irb</code>:</p>

<pre><code>2.2.0 :011 &gt; puts "Waddle waddle"
Waddle waddle
 =&gt; nil 
</code></pre>

<p>Even though the context of <code>self</code> changes from the Duck Class, to an instance of a Duck, back to <code>main</code> in <code>irb</code>, we have access to <code>puts</code> in all contexts. It&rsquo;s kind of magical, if you think about it: a single private method, defined in a module, trickles down to all Ruby objects that descend from it!</p>

<p>And this magic has a name: <strong>global functions</strong> work. Since methods like <code>puts</code> are defined on the <code>Kernel</code> and mixed into the <code>Object</code> class, they are accessible <em>everywhere</em>. They&rsquo;re private methods, which means they must be invoked without an explicit receiver (also known as a &ldquo;function form&rdquo; of method invocation).</p>

<p>I really liked the way that <a href="https://codequizzes.wordpress.com/2014/04/22/rubys-kernel-module/">this blog post</a> explains the concept:</p>

<blockquote><p>Virtually all Ruby objects inherit from Object and have access to the methods defined in the Kernel module, so Kernel’s private instance methods are accessible virtually anywhere in a Ruby program, regardless of self.</p></blockquote>

<p>And you know what&rsquo;s even cooler? These global functions defined on <code>Kernel</code> are used everywhere! In fact, you probably don&rsquo;t even realize that you use them. Here are some of the ones that surprised me:</p>

<ul>
<li><code>gets</code></li>
<li><code>chomp</code></li>
<li><code>sleep</code></li>
<li><code>require</code></li>
<li><code>gem</code></li>
<li><code>rand</code></li>
<li><code>gsub</code></li>
<li><code>proc</code></li>
<li><code>eval</code></li>
</ul>


<p>Yup. All of these methods are defined on <code>Kernel</code>, available to all objects (including <code>main</code> as <code>self</code> in <code>irb</code>), and don&rsquo;t need a receiver to be called!</p>

<iframe src="//giphy.com/embed/gLRDi5KnA3Fte" width="480" height="374" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Now that you know where all these methods live and where they come from, you probably feel pretty powerful. You also will hopefully feel more purposeful when you write even a simple <code>puts</code> statement in a line of code.</p>

<p>Perhaps the moral of the story here is to never take code for granted: always question how it works and try to understand exactly what&rsquo;s going on in every line that you type.</p>

<p>The second moral is to use other developers on Twitter as resources to help you figure out what to Google, obvs.</p>

<h2>tl;dr?</h2>

<ul>
<li>The <code>Kernel</code> module is mixed into the <code>Object</code> class, which means all methods (including private methods!) defined on this module are accesible to all Ruby objects, making them &ldquo;global&rdquo; functions.</li>
<li>Even though a method&rsquo;s implicit receiver is <code>self</code>, the context of <code>self</code> changes depending on which class you are in; this is particularly important when dealing with &ldquo;global&rdquo; functions.</li>
<li>Curious about <code>main</code> and <code>self</code> in <code>irb</code>? Check out these two great <a href="http://www.sitepoint.com/rubys-top-self-object/">blog</a> <a href="https://banisterfiend.wordpress.com/2010/11/23/what-is-the-ruby-top-level/">posts</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Metaprogramming Dynamic Methods: Using Public_send]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/05/05/metaprogramming-dynamic-methods-using-public-send/"/>
    <updated>2015-05-05T08:38:29-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/05/05/metaprogramming-dynamic-methods-using-public-send</id>
    <content type="html"><![CDATA[<p><img src="http://imgs.xkcd.com/comics/hofstadter.png" style="display: block; margin-left: auto; margin-right: auto;"></p>

<p>A really amazing thing happened to me last week: I wrote some code that I was actually proud of! I was trying to solve an interesting problem for an application I started building at work recently, and I implemented the first solution that came into my mind. And after I took a step back from my text editor and actually looked at what I had written, I realized something. My code was actually <em>good</em>.</p>

<p>The very fact that I was so surprised and thrilled at the prospect of writing good code speaks volumes to the nature of programming. Most of the time I abhor the methods I write because I know they could be written better, but I don&rsquo;t have the syntactical flow (yet!) to write them well. So last week&rsquo;s incident of &ldquo;code pride&rdquo;, however fleeting, was rather noteworthy.</p>

<p>I looked back on my code over the weekend and thought about what made it seem so beautiful to me. What did I do differently that made me beam with pride knowing that I had been the one to write that particular method? The short answer to that question is: metaprogramming. <strong>Metaprogramming</strong> is nothing more than abstraction of code, which often means that your code will write more code for you! Of course, there are a lot of different techniques and approaches to this, and I&rsquo;m certainly no expert. But I did learn a little something about a meta method called <code>public_send</code>, and I&rsquo;ll show you just how I used it!</p>

<!--more-->


<h2>Gotta Dispatch? Do It Dynamically.</h2>

<p>Everything in Ruby &ndash; everything in programming, really &ndash; is just an abstraction. We sprinkle some syntactic sugar to make our lives easier and code simpler, but it&rsquo;s all just an abstraction of something else. When we&rsquo;re refactoring by metaprogramming, it&rsquo;s this same concept of abstraction that we have to keep in mind. And when we look for and find patterns within our code, it&rsquo;s generally a sign that we could be encapsulating and abstracting away that piece of functionality.</p>

<p>My favorite example of abstraction is <strong>method dispatching</strong>. Method dispatching is how we send a message to an object. And boy, do we do that a lot. Since everything in Ruby is an object, whenever you want an object to do something, you have to send it a message. And luckily, because Ruby is so great, the method we use to &ldquo;send&rdquo; messages is called just that: <code>send</code>.</p>

<p>The <code>send</code> method is called in our programs way more than we might realize. For example, if we open up our console and do some simple math:
<code>
2.2.0 &gt; 3 + 4
 =&gt; 7
</code>
what we&rsquo;re <em>really</em> doing is sending a message to the <code>3</code> Integer object, and telling it to perform an action (<code>+</code>) in terms of another object (the <code>4</code> Integer object):
<code>
2.2.0 &gt; 3.send(:+, 4)
 =&gt; 7
</code></p>

<p>The <code>send</code> method takes a parameter of either a string or symbol, which is the method name. The method name will always be the first parameter, and the second  parameters is passed to the method as an argument.</p>

<p>Now, this is great when you know that you want to add 3 and 4. But who is going to add 3 and 4 all of the time? No one, that&rsquo;s who. You&rsquo;re probably going to want to add 3 to 5, and 6, and on and on&hellip;</p>

<p>Enter <strong>dynamic dispatching</strong> to save the day!</p>

<iframe src="//giphy.com/embed/144RafbwKkBDva" width="480" height="269" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Dynamic dispatching, as the slightly odd yet adorable gif above demonstrates, involves sending various messages (read: methods) to objects, with the added caveat that our methods keep changing, depending on the situation. Dynamic dispatching also allows us to send different methods to objects in our program without any other object knowing the contents of that message. A good indicator for using dynamic dispatching is if you have call a method in a specific situation, but don&rsquo;t know what exactly that method will be.</p>

<p>Confused yet? Okay, okay, let me give you an example.</p>

<h2>You Can Send Whuteva You Like</h2>

<p>Knowing that you can use <code>send</code> to &ldquo;send&rdquo; different methods to an object is only half the fun. The other half is figuring out when to pull out this tool from your Toolbelt of Knowledge™ &ndash; yes, I&rsquo;m trademarking this phrase &ndash; and actually use it.</p>

<p>So&hellip;I guess it&rsquo;s time for me to show you a real-life example of how I used recently dynamic dispatch to invoke specific methods in my application! Hopefully to neither your surprise nor chagrin, I&rsquo;ll be using my eCommerce Bookstore example.</p>

<p>In my store, I have a paginated list of different books available for purchase. Each book has only a limited amount of space it can take up in the view, so as an admin of the site, it&rsquo;ll be up to me to decide how I want different books to show up. Some of my books have awesome book covers, so I want to use thumbnail images of their cover as the main &ldquo;viewable attribute&rdquo; in my store. Since I&rsquo;m using the <code>paperclip</code> gem, this will be pretty easy.</p>

<p>However, some books in my store don&rsquo;t even have book covers! My vast collection of Shakespearean plays, for example, would be much better served by making the author as the &ldquo;visible attribute&rdquo;, rather than nonexistent covers. And I think the <em>Game of Thrones</em> book series should have the book title as the &ldquo;visible attribute&rdquo;.</p>

<p>So, how can we handle this? Well, let&rsquo;s first look for any patterns.</p>

<h3>1. Look For Patterns</h3>

<p>In our view, we want to be able to show each <code>Book</code> object using its primary viewable attribute. The problem we&rsquo;re dealing with here is that an admin will mark different attributes for a <code>Book</code> object as &ldquo;viewable&rdquo;, which means that we can&rsquo;t predict whether it&rsquo;ll be a <code>title</code>, <code>author</code>, or an image. But we do know that every <code>Book</code> object has to have <em>some</em> &ldquo;viewable attribute&rdquo;.</p>

<p>Cool, so there is <em>some</em> sort of pattern emerging here: we need to render an attribute, and we don&rsquo;t know what it will be. Or&hellip;do we?</p>

<h3>2. Consider The Data</h3>

<p>Since we&rsquo;re building out an admin panel for this application, we know that every book needs to have a <code>title</code> and an <code>author</code>. The book cover (which we&rsquo;ll refer to as <code>media</code>) is optional, but the other two are not, which means we&rsquo;ll have a validation for our <code>Book</code> objects:</p>

<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  validates_presence_of :title, :author
end
</code></pre>

<p>This validation makes me think about the other things that will <em>always</em> be present on a <code>Book</code> object, and the first thing that comes to mind is a <code>viewable_by</code> attribute. If we think about it, an admin always has to mark <em>something</em> as &ldquo;viewable&rdquo;, and that &ldquo;viewable&rdquo; property can change when they update an object. So this is really a property unique to each <code>Book</code>, which means that it could very well be a column saved in the database.</p>

<p>So, we&rsquo;ll write a migration that adds a <code>viewable_by</code> column, which can never be <code>null</code>, and will always default to a <code>Book</code>&rsquo;s <code>title</code>:</p>

<pre><code class="ruby">class AddViewableByToBooks &lt; ActiveRecord::Migration
  def change
    add_column :books, :viewable_by, :string, null: false, default: "title"
  end
end
</code></pre>

<p>This migration might look pretty simple, but it is its very simplicity that lends itself so elegantly to some serious metaprogramming that we&rsquo;ll do next.</p>

<h3>3. Encapsulate And Abstract</h3>

<p>This last part can be the hardest to wrap our minds around, but it also happens to be the coolest. As it stands, our database has a column that will be populated with either a string value <code>"title"</code>, <code>"author"</code>, or <code>"media"</code>. These values will be changed and updated by an admin, and they will obviously and inevitably change. But here&rsquo;s what&rsquo;s not going to change: we&rsquo;re still going to want to render the value of whatever attribute is marked as &ldquo;visible&rdquo; &ndash; that is to say, whatever string value is saved as <code>viewable_by</code>.</p>

<p>If we think back to the pattern we just identified, we realize that the attribute changes, but what we want to do with it stays the same. No matter what the <code>Book</code> is <code>viewable_by</code>, we want to render it. We want to send a message to this object and tell it, <em>Hey Book! Whatever you are viewable by is exactly what you should show yourself as!</em></p>

<p>And this is where we can use <code>send</code> to encapsulate and abstract this away into a single method call. First, we&rsquo;ll want to add a method that checks whether this is an image &ndash; if it is, we&rsquo;ll hand it off to the <code>paperclip</code> gem to render the image:</p>

<pre><code class="ruby">def show_cover?
  self.viewable_by == 'media'
end
</code></pre>

<p>This method will return <code>true</code> if we the <code>viewable_by</code> attribute is set to <code>media</code>, and <code>false</code> if it&rsquo;s not. We can use this <code>boolean</code> return value in a conditional statement:</p>

<pre><code class="ruby">def book_html
  if show_cover?
    # Code here will generate and return
    # an html image tag to render in view.
  else
    send(self.viewable_by)
  end
end
</code></pre>

<p>Whoaaaaa, whut is happening? The answer is: something cool! This <code>book_html</code> method will render either a thumbnail image (which we let some other code worry about generating), or it returns a <code>title</code> or an <code>author</code>. And what&rsquo;s really cool is that, we could add other attributes to our table &ndash; like <code>year</code> or <code>genre</code> and render html based on that, as long as it was saved in our <code>viewable</code> column.</p>

<p>How does this work exactly? Well, whenever we create a new column in our database, we get two important methods for free: a reader and a writer. That means that we have both a <code>title=</code> and a <code>title</code> method.</p>

<p>If we look back to how the <code>send</code> method works, we&rsquo;ll remember that the <code>send</code> method takes a parameter of a string or a symbol, which is the name of the method to be called. When we call <code>send</code> and pass it the value of <code>self.viewable_by</code>, we&rsquo;ll actually be calling <code>send("title")</code> on an instance of <code>Book</code>. This will then call <code>title</code> on that instance of <code>Book</code>, returning that particular book&rsquo;s title as a string.</p>

<p>The cool thing about this code is that it&rsquo;s flexible, and has abstracted away a pattern into a dynamic method call, which is dispatched to the appropriate object at the appropriate time. But there&rsquo;s still one major issue with this code that I can see. Let&rsquo;s fix that.</p>

<h2>To Send Or To Public Send? That Is The Question.</h2>

<p>A lot of the most incriminating evidence against using the <code>send</code> method stems from the fact that <code>send</code> can even send <em>private</em> methods to an object. This can be dangerous for your application internally, and also leaves it vulnerable to external, malicious attacks.</p>

<p>A quick fix for this is to instead use <code>public_send</code>, which does exactly what you think it does: send only publicly-accessible methods to the object that is its receiver. Our final code now looks something like this:</p>

<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  validates_presence_of :title, :author

  def show_cover?
    self.viewable_by == 'media'
  end

  def book_html
    if show_cover?
      # Code here will generate and return
      # an html image tag to render in view.
    else
      public_send(self.viewable_by)
    end
  end
end
</code></pre>

<p>Nice! Not too shabby for our first attempt at metaprogramming all the things (or at least one thing).</p>

<p>As hard as it is to do, you can&rsquo;t be too hard on yourself when it comes to refactoring and metaprogramming. I honestly think it just comes with time, practice, and exposure. Eventually, you&rsquo;ll start to recognize the same patterns again and again, and you&rsquo;ll start to learn which tools are the right ones for the job.</p>

<p>Even though it takes a bit more effort, I think learning the different techniques of metaprogramming makes you better and both reading and writing code. By rewriting your old code and implementing some of those metaprogramming techniques, you take away some of the otherwise hard-coded lines in your application, and make it more flexible and dynamic.</p>

<p>If any or all of this sounds intimidating, that&rsquo;s because it is! But it&rsquo;s also not impossible, as I&rsquo;ve recently proven to myself (and hopefully to you). Luckily, Ruby gives us a lot of tools to meta program away our boilerplate code. It&rsquo;s just a question of knowing what those tools are so that you can use them when you see the perfect opportunity. And when you finally metaprogram something, you&rsquo;ll be so impressed with yourself that you&rsquo;ll let out a little squeal of glee like this little kitty and it&rsquo;ll be the cutest thing ever:</p>

<iframe src="//giphy.com/embed/117j1ldyb838Zi" width="480" height="382" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<h2>tl;dr?</h2>

<ul>
<li>We can use dynamic dispatching to send a method to an object without being explicit about the method&rsquo;s contents within our application. The <code>send</code> and <code>public_send</code> method are two ways of doing this, and both take a string or symbol as a parameter, and use that to call a method of the same name upon the receiving object.</li>
<li>Learn the basics of metaprogramming over <a href="http://ruby-metaprogramming.rubylearning.com/html/ruby_metaprogramming_2.html">here</a>, and check out the docs on <a href="http://ruby-doc.org/core-2.2.2/Object.html#method-i-send">send</a> and <a href="http://apidock.com/ruby/Object/public_send">public_send</a>.</li>
<li>Curious about the different types of dynamic method calls out there? This <a href="http://ruby.about.com/od/oo/ss/Dynamic-Method-Calls.htm">blog post</a> covers a few different kinds in depth.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tackling Those Tests, Part 1: The How, When, and What of Rspec Testing]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/04/14/tackling-those-tests-part-1-the-how-when-and-what-of-rspec-testing/"/>
    <updated>2015-04-14T08:17:03-04:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/04/14/tackling-those-tests-part-1-the-how-when-and-what-of-rspec-testing</id>
    <content type="html"><![CDATA[<p><img src="http://www.datamation.com/imagesvr_ce/306/philosophy-geeks.jpg" style="display: block; margin-left: auto; margin-right: auto; width: 50%; height: 50%;"></p>

<p>Up until two weeks ago, I had one great fear: <em>testing</em>. And, to be clear, when I say &ldquo;fear&rdquo;, what I actually mean is sheer terror.</p>

<p>My test-writing anxiety stems from the fact that I&rsquo;ve never really had to do it before. I mean, I&rsquo;ve had to make tons of tests <em>pass</em>, which means that I read other people&rsquo;s tests all the time. Yet I&rsquo;ve somehow made it thus far in my coding career without ever having to write relatively complex tests of my own. But that all changed a few weeks ago, when I was forced to finally confront my fear of testing.</p>

<p>The thing about conquering fears, however, is that usually involves doing the very thing that you&rsquo;re afraid of. So, I spent the better portion of a week learning how and when to write tests, all while encountering a couple painful bugs along the way. It was not a fun week, but the good news is that I can write a fully-functioning test suite now! And now that I know more about testing, I actually find it kind of fun &ndash; so fun, in fact, that I&rsquo;m going to share it with you!</p>

<!--more-->


<h2>Ain&rsquo;t No Spec Like Rspec</h2>

<p>Before we get into the how and when of testing, we first need to setup our Rails application with <code>rspec</code>, a behavior-driven development framework built specifically for testing in Ruby.</p>

<p>We&rsquo;ll first want to add <code>rspec-rails</code> to our the development and test group in our <code>Gemfile</code>:</p>

<pre><code class="ruby">group :development, :test do
  gem 'rspec-rails'
end
</code></pre>

<p>Next, we&rsquo;ll run a quick <code>bundle install</code>, and then generate a <code>/spec</code> folder by running <code>rails generate rspec:install</code>. We now have access to a <code>rails_helper.rb</code> and <code>spec_helper.rb</code> file inside of our <code>/spec</code> directory.</p>

<p>Finally, we&rsquo;ll want to add files for everything that we want to test. But let&rsquo;s start simple for now and just test our <code>ReadingList</code> model. The path to this spec file should be <code>/spec/models/reading_list_spec.rb</code>, so we&rsquo;ll need to add a <code>models</code> directory and a <code>reading_list_spec.rb</code> file.</p>

<p>Once we&rsquo;ve done that, we can check that everything is setup properly by running our <code>rspec</code> command:</p>

<pre><code>♥ rspec
No examples found.


Finished in 0.00023 seconds (files took 0.08619 seconds to load)
0 examples, 0 failures
</code></pre>

<p>You know what needs to happen next, right? It&rsquo;s time for us to write some tests.</p>

<iframe src="//giphy.com/embed/nhj799TYbxG80" width="480" height="235" frameBorder="0" style="max-width: 100%" class="giphy-embed" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>Okay, I feel your pain. But I promise, we&rsquo;re going to get through this together.</p>

<h2>Knowing What To Test</h2>

<p>I&rsquo;ve found that the best way to start writing tests is by picking one section to work on first. Otherwise, it can just be so overwhelming and might make you want to give up completely. Let&rsquo;s take a look at what our <code>ReadingList</code> model:</p>

<pre><code class="ruby">class ReadingList &lt; ActiveRecord::Base
  belongs_to :user
  has_many :books

  attr_accessor :read

  def books_read
    books.where(read: true).count
  end

  def books_unread
    books.where(read: false).count
  end

  def percentage_read
    read = books_read.to_f
    unread = books_unread.to_f

    calculate_percentage(read, unread)
  end

  def calculate_percentage(read, unread)
    ((read / unread) * 100).round(2)
  end
end
</code></pre>

<p>Whoa, this seems like a lot. But fear not! Programming is nothing more than breaking down big problems into smaller, bite-sized pieces. And that&rsquo;s exactly what we&rsquo;ll do when writing these tests.</p>

<p>Let&rsquo;s look at the <code>percentage_read</code> method to start. This is the instance method that we&rsquo;ll actually want to call somewhere in our view. It uses the number of books marked <code>read</code> (which will always be a boolean <code>true</code> or <code>false</code> value), and calculates the <code>User</code>&rsquo;s reading progress on the list, returning a percentage.</p>

<p>But even though this is the method we want to test, a deeper look reveals that it actually relies and calls upon three other methods: <code>books_read</code>, <code>books_unread</code>, and <code>calculate_percentage</code>. This should be a big red flag, because it means that we need to test these three methods individually, first. The flow of our code is actually directing us in our test-writing process: we can decide which tests to write and in which order by looking at our method&rsquo;s dependencies.</p>

<p>So, let&rsquo;s hop to it:</p>

<ul>
<li>We&rsquo;ll start by first requiring <code>rails_helper</code> in our <code>reading_list_spec.rb</code>, and stubbing out our tests with a block:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">rails_helper</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span><span class="o">&lt;</span><span class="sr">/li&gt;</span>
</span><span class='line'><span class="sr">&lt;/u</span><span class="n">l</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="no">RSpec</span><span class="o">.</span><span class="n">describe</span> <span class="no">ReadingList</span><span class="p">,</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:model</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">describe</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="c1">#percentage_read&amp;rdquo; do</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>We can use a <code>describe</code> block to break up our tests into different sections. They will come in handy as our tests start to grow, and will make our test suite easier to read &ndash; not just when we come back to look at them later, but also when another developer digs through our code. The <code>#</code> symbol before our method name denotes that <code>percentage_read</code> is an instance method, another important distinction to make as we go about adding more tests.</p>

<ul>
<li>Next, we&rsquo;ll describe what our method <em>should</em> do by using <code>it</code> blocks</li>
</ul>


<pre><code class="ruby">  describe "#percentage_read" do
    it "finds the number of read books in a list" do
    end

    it "finds the number of unread books in a list" do
    end

    it "calculates a percentage when given two values" do
    end

    it "calculates the percentage of books read in a list" do
    end
  end
</code></pre>

<ul>
<li>Now we need to add some data &ndash; but not too much! We only want enough data to test the functionality of our method. Let&rsquo;s create a list with two books, one marked read and the other not marked read. We&rsquo;ll add this before our <code>describe</code> and <code>it</code> blocks:</li>
</ul>


<pre><code class="ruby">  let(:list) { ReadingList.create!(title: "Vaidehi's List" }
  let(:book1) { list.books.build(title: "A Game Of Thrones", read: true) }
  let(:book2) { list.books.build(title: "A Storm Of Swords", read: false) }
</code></pre>

<p>Wait, what&rsquo;s that <code>let</code> doing in there? The answer is: something magical! It creates an instance of <code>ReadingList</code> and makes a reference to it called <code>list</code>, which is then accessible to us in each of our <code>it</code> blocks. The <code>let</code> syntax is <a href="http://www.reddit.com/r/ruby/comments/2bcz12/newbie_to_rspec_why_use_let_instead_of_a_local/">an alternative</a> to creating local variables inside <em>every single</em> one of our <code>it</code> blocks.</p>

<ul>
<li>Finally, we&rsquo;ll add some expectations for our model&rsquo;s behavior when each method is called. Our finished test suite now looks like this:</li>
</ul>


<pre><code class="ruby">RSpec.describe ReadingList, :type =&gt; :model do
  let(:list) { ReadingList.create!(title: "Vaidehi's List" }
  let(:book1) { list.books.build(title: "A Game Of Thrones", read: true) }
  let(:book2) { list.books.build(title: "A Storm Of Swords", read: false) }

  describe "#percentage_read" do
    it "finds the number of read books in a list" do
      expect(list.books_read).to eq(1)
    end

    it "finds the number of unread books in a list" do
      expect(list.books_unread).to eq(1)
    end

    it "calculates a percentage when given two values" do
      expect(list.calculate_percentage(3.0, 4.0)).to eq(75.00)
    end

    it "calculates the percentage of books read in a list" do
      expect(list.percentage_read).to eq(50.00)
    end
  end
end
</code></pre>

<p>Each one of our tests is just a single line, specifying our exact expectations! Pretty awesome, right? This makes for relatively DRY code, which is pretty easy to understand.</p>

<h2>Testing Your Assumptions</h2>

<p>Now that we know <em>how</em> to write tests, it&rsquo;s time to address the question of <em>when</em> and <em>what</em> to test. Here&rsquo;s a good rule of thumb that I adhere to: <strong>test your assumptions</strong>. Whenever we write code, we make a ton of assumptions. The problem with making assumptions, however, is that you forget or don&rsquo;t realize that you made them, and then they end up coming back to screw you.</p>

<p><img src="http://www.explainxkcd.com/wiki/images/e/e6/when_you_assume.png" style="display: block; margin-left: auto; margin-right: auto;"></p>

<p>In fact, even the tests we just wrote are based on a lot of assumptions. And there are a lot of things that we haven&rsquo;t considered. For example:</p>

<ol>
<li>Does the <code>read</code> attribute on a <code>ReadingList</code> object only accept a <code>boolean</code> value? What if someone tries to pass a non-boolean value as <code>read</code>?</li>
<li>What is the default value of the <code>read</code> attribute?</li>
<li>What if <code>read</code> is nil &ndash; what will break?</li>
<li>What if the return value of <code>books_unread</code> is <code>0</code>?</li>
</ol>


<p>Just FYI, I discovered the answer to number 4, which looks like this:</p>

<blockquote class="twitter-tweet tw-align-center" lang="en"><p>Uh oh&#8230;I did a bad thing: <a href="http://t.co/uFZEkyCPRl">pic.twitter.com/uFZEkyCPRl</a></p>&mdash; Vaidehi Joshi (@vaidehijoshi) <a href="https://twitter.com/vaidehijoshi/status/583994491570229249">April 3, 2015</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>This is all to say that we must write tests for behavior that <em>should</em> and <em>should not</em> occur. We&rsquo;d probably want to write validations to prevent <code>nil</code> values, and we&rsquo;d definitely want to raise an error whenever we try to divide by <code>0</code>. We aren&rsquo;t just testing for what we can see &ndash; we also need to test for things we can&rsquo;t see, and any edge cases that we can think of.</p>

<p>Learning the how, when, and what of testing is a process that comes with time and practice. The more tests you write, the better you&rsquo;ll get at testing. Of course, there are few tips and tricks of the testing trade that can very quickly and easily save you a lot of heartache.</p>

<p>Tune in again next Tuesday, when I&rsquo;ll delve into generating fixtures for test data using FactoryGirl &ndash; a trick that&rsquo;s going to make your testing life so much easier.</p>

<h2>tl;dr?</h2>

<ul>
<li>All <code>rspec</code> tests have an <code>it</code> block, which describes what behavior is expected. This block should never be too big, and contains an assertion of what expected value should be returned.</li>
<li>The <code>let</code> syntax allows for lazy evaluation and keeps you from having to create a new instance of an object inside of every single <code>it</code> block. Check out more on the <code>let</code> and <code>let!</code> helper methods over on <a href="http://stackoverflow.com/questions/17407733/trouble-differentiating-rspecs-let-vs-let">this Stack Overflow answer</a> or on <a href="https://www.relishapp.com/rspec/rspec-core/v/2-5/docs/helper-methods/let-and-let">this blog post</a>.</li>
<li>Use <code>describe</code> blocks to divide up your tests into sections, based on functionality and code cohesion. You can also use <code>context</code> blocks to assert different scenarios that could occur during one method call. Read about the <a href="http://lmws.net/describe-vs-context-in-rspec">difference between describe and context</a>.</li>
<li>Find out more about different rspec testing conventions at <a href="http://betterspecs.org/">Better Specs</a>.</li>
</ul>

]]></content>
  </entry>
  
</feed>
