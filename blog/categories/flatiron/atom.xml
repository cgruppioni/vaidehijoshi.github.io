<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Flatiron | Words and Code]]></title>
  <link href="http://vaidehijoshi.github.io/blog/categories/flatiron/atom.xml" rel="self"/>
  <link href="http://vaidehijoshi.github.io/"/>
  <updated>2015-07-07T09:01:02-04:00</updated>
  <id>http://vaidehijoshi.github.io/</id>
  <author>
    <name><![CDATA[Vaidehi Joshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Fog Creek Fellowship: Lessons in Fearlessness and Fortitude]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2015/01/23/the-fog-creek-fellowship-lessons-in-fearlessness-and-fortitude/"/>
    <updated>2015-01-23T14:04:16-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2015/01/23/the-fog-creek-fellowship-lessons-in-fearlessness-and-fortitude</id>
    <content type="html"><![CDATA[<p>There are a lot of scary things out there. To start, there are lions and tigers and bears. But if you go a bit below the surface, that&rsquo;s where you&rsquo;ll hit the dark stuff &ndash; the kind of stuff that I was forced to confront when I started as a student at <a href="http://www.flatironschool.com">The Flatiron School</a>.</p>

<p>Sure, learning how to program is really hard &ndash; it&rsquo;s not just learning another language, it&rsquo;s learning an entirely new way to think. But, working on code is far easier than working on yourself. My twelve weeks at The Flatiron School pushed me to deal with some tough thoughts, most of which had always lurked in the skeleton closets of my mind: <em>I don&rsquo;t know if I can do this. I&rsquo;m not cut out for this. I&rsquo;m not prepared. I&rsquo;m not smart enough. I won&rsquo;t fit in. I can&rsquo;t undersand. I won&rsquo;t understand.</em></p>

<p>Most of us have all had these thoughts at some point in our lives, regardless of what we look like or what we do for a living. Some of us have stopped dead in our tracks, sometimes unable to move beyond them at all. But learning to code meant dealing with these fears on a daily basis; at some point, I just stopped listening to them entirely.</p>

<!-- more -->


<h2>The Fog Creek Fellowship</h2>

<p>Before I learned to code, I was a writer and a teacher. In other words, I had no background in computer science or software developement. Now, it&rsquo;s already pretty terrifying to enter a new field in which you have no experience. But it gets <a href="http://thinkprogress.org/economy/2013/09/10/2599491/women-stem/">even more frightening</a> when you realize that only 25% of the industry is female and that 71% of your coworkers are white. All these facts combined can be fairly paralyzing &ndash; it&rsquo;s no wonder, then, that so many women and minorities choose not to enter STEM fields.</p>

<p>After graduating from Flatiron, I found myself facing an entirely new sea of questions: <em>Am I prepared for all these technical interviews? How do I negotiate a salary? What offer should I accept? What&rsquo;s the best job for me? Do I want to be the only woman in an all-male tech team?</em> Luckily, I didn&rsquo;t have to swim through this alone. Instead, I had a support system gliding along beside me the entire way: <a href="http://blog.fogcreek.com/announcing-the-fog-creek-fellowship/">The Fog Creek Fellowship</a>.</p>

<p>Forged through a partnership with the Flatiron School, the fellowship is dedicated to creating a more diverse and welcoming tech community by nurturing a select group of female Flatiron graduates as they look for their first programming jobs. Fellows are paired with a Fog Creek, Trello, or StackExchange developer &ndash; who just so happen to be some of the best coders in the country &ndash; and have the opportunity to create long-lasting relationships through pair programming sessions, interview prep, and technical talks.</p>

<blockquote class="twitter-tweet tw-align-center" lang="en"><p>Class two began today! <a href="http://t.co/LUaRwAnLUW">http://t.co/LUaRwAnLUW</a> &amp; the list of additional companies getting involved is so inspiring! <a href="http://t.co/hFaCy5HUlg">pic.twitter.com/hFaCy5HUlg</a></p>&mdash; Elizabeth Hall (@Liz_Hall1) <a href="https://twitter.com/Liz_Hall1/status/552204196016312320">January 5, 2015</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<h2>Fearlessness</h2>

<p>I wasn&rsquo;t sure what to expect when I started the fellowship. Thankfully, my <a href="https://twitter.com/ianthehenry">phenomenal mentor Ian</a> was full of ideas. Thinking back on it now, I realize that all of our mentors helped us to confront the things that we were the most uncomfortable (read: afraid) of.</p>

<p>A lot of us didn&rsquo;t understand a lot of the computer science concepts that were coming up in technical interviews, so the mentors took the time to review tougher technical topics, and encouraged us to always speak up if ever we were confused.</p>

<blockquote class="twitter-tweet tw-align-center" lang="en"><p>Trello devs taking a break from making <a href="https://twitter.com/trello">@trello</a> awesome to help some <a href="https://twitter.com/FlatironSchool">@FlatironSchool</a> devs be more awesome <a href="https://twitter.com/hashtag/fogcreek?src=hash">#fogcreek</a> <a href="http://t.co/bS2iTQfpRm">pic.twitter.com/bS2iTQfpRm</a></p>&mdash; Michael Pryor (@michaelpryor) <a href="https://twitter.com/michaelpryor/status/555807419214102528">January 15, 2015</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p><br></p>

<p>I always wanted to learn more about Objective C and iOS, so my mentor and I built a simple iPhone app that implemented the New York Times API and showed the top stories of the day. It was undoubtedly hard, but everything that&rsquo;s new and different always is. Ian helped me face my doubts head on, and nudged me to be unafraid of making mistakes or being wrong.</p>

<p>All the mentors and mentees hung out together, ate lunch, and talked tech and non-tech topics. And when I was trying to choose between a few different offers, they helped me talk through what I wanted out of my job, and which position would make me happy. We talked about everything from what we wanted our careers to look like in five years, to the pipeline problem for women in tech.</p>

<h2>Fortitude</h2>

<p>It takes a great deal of grit and strength of mind to endure and accept obstacles that come your way. To be a woman in technology, you need ample amounts of fortitude. There&rsquo;s really no other way to put it: <a href="http://www.payscale.com/career-news/2014/12/what-it's-really-like-for-women-in-tech">it&rsquo;s</a> <a href="http://www.washingtonpost.com/blogs/on-leadership/wp/2015/01/20/the-women-who-make-it-in-tech/">hard</a> to be a <a href="http://www.geekwire.com/2015/commentary-bring-binders-full-women-tech-must-get-page/">woman</a> in <a href="http://thinkprogress.org/economy/2013/09/10/2599491/women-stem/">tech</a>. It&rsquo;s hard to be <a href="http://www.theverge.com/2015/1/20/7856467/airbnb-diversity-report-gender-race-interactive-chart">a person of color</a> in tech. But the only way that we can begin to change the reality of the situation is by bringing in more women and minorities into the industry.</p>

<p>Granted, the solution to the problem might come in different shades for various people. Whether that means creating relationships based on trust and openness (such as the ones that we had with our mentors), or providing the resources to build confidence (like technical talks or interview prep), they&rsquo;re all steps in the right direction. If enough people follow suit, the industry will soon have an entirely new generation of developers and engineers, each of whom will pay it forward.</p>

<p>From my own personal experience at Fog Creek Software, I can definitely vouch for the simplicity of a safe, welcoming space for women. If you&rsquo;re wondering how you can change the industry, I&rsquo;d say that this is a good way to start. I suppose that it&rsquo;s a simple thing, really, but it makes a world of difference. Both Fog Creek and the Flatiron School are communities that acknowledge a problem and then proceed to create an environment that mirrors a world that we want to one day live in.</p>

<p>I&rsquo;d consider myself one of the lucky few who has been a part of this incremental change. The Flatiron School and the Fog Creek Fellowship opened so many doors for me &ndash; doors that I know I could have never opened on my own. As I take my first step and start a new job as a developer, I&rsquo;m realizing that the fellowship isn&rsquo;t really over. It&rsquo;s just that my role in it is changing. Soon, it&rsquo;ll be my turn to help open the very same doors for someone else.</p>

<p>Hopefully, she&rsquo;ll be even more fearless than me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[To Understand Recursion, You Must First Understand Recursion]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2014/12/14/to-understand-recursion-you-must-first-understand-recursion/"/>
    <updated>2014-12-14T22:32:29-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2014/12/14/to-understand-recursion-you-must-first-understand-recursion</id>
    <content type="html"><![CDATA[<p><img src="http://xkcdsw.com/content/img/1105.gif" style="display: block; margin-left: auto; margin-right: auto;"></p>

<p>Recursion is kind of like the cloud &ndash; it&rsquo;s hard to explain and you might not ever see it, but it definitely is a thing. Yet we deal directly with recursion more than we may realize.</p>

<p><strong><em>Recursion</em></strong> is the process of repating a procedure or action. In Ruby, we put all of our procedures inside of a method, and we use loops to repeat those procedures again and again. So, if we have methods and loops, what&rsquo;s the need for recursion?</p>

<p>Well, as Rubyists, we&rsquo;re pretty lucky to work with a language that&rsquo;s intuitive and human-friendly. We like to read and write code that&rsquo;s actually comprehensive and (ideally) can be understood and appreciated by programmers and non-programmers alike. It turns out that recursion is a big part of that. It can make our code more readable and can even help it run faster.</p>

<!-- more -->


<h2>Functionally Recursive Babushkas</h2>

<p>In Ruby, we use recursion when we call a method from within itself. Sometimes, when you&rsquo;re within the scope of a method, you want to repeat the same action again from inside of it. Functional recursion achieves exactly that goal.</p>

<p>One of the best metaphors for recursion that I&rsquo;ve heard comes from my friend and <a href="http://jimmykuruvilla.github.io/">fellow classmate, Jimmy</a>. He explained recursion as a set of nested Russian matryoshka (aka babushka) dolls:</p>

<p><img src="http://www.russia-ex.com/images/blog/Matryoshka-Dolls-1.jpg" style="display: block; margin-left: auto; margin-right: auto;"></p>

<p>These dolls work in a pretty interesting way. Within each one, there is another doll that is exactly the same. You have multiple copies of the same doll, each within another, until eventually, you get to the smallest doll.</p>

<p>In the programming context, the smallest doll is your <strong>base case</strong>. The base case is imperative when it comes to utilizing recursion. It&rsquo;s how you tell your recursive method when to <em>stop</em> calling itself from inside of itself.</p>

<p>Imagine what would happen if you didn&rsquo;t have a final doll to end with &ndash; you&rsquo;d just keep going and going and going until, eventually, your head would probably explode:</p>

<iframe src="//giphy.com/embed/MrZTFRJ8F4n6" width="480" height="641" frameBorder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p><br></p>

<p>Or, more likely, you&rsquo;d be stuck in something like an infinite loop, and you&rsquo;d eventually use more memory than whatever was available to you in the stack, ending up with an error like <code>SystemStackError: stack level too deep</code> or <code>Stack overflow!</code>.</p>

<p>These kinds of errors are good reminders of how dangerous recursion can be. But don&rsquo;t let that dissuade you! Recursion can also be pretty powerful, especially if you want to repeat a function multiple times.</p>

<h2>Recursion, Rinse, Repeat</h2>

<p>A classic example for explaining recursion is calculating factorials. Just in case you need a refresher: a factorial is the product of an integer and all the integers below it, up to the number 1. The factorial of 4 would be written out as: <code>4 * 3 * 2 * 1</code>, or <code>24</code>.</p>

<p>Now, we could very easily write this using a <code>while</code> loop:</p>

<pre><code class="ruby">def factorial(num)
  factorial_count = 1
  while num &gt; 0
    factorial_count *= num
    num -= 1
  end 
  puts factorial_count
end
</code></pre>

<p>But let&rsquo;s look at this code for a second. What exactly happens when our compiler runs this code? Well, a lot of stuff.</p>

<ol>
<li>First, it has to keep track of our counter, since we only ever want to calculate a factorial down to the number 1.</li>
<li>Then, it checks that the number being passed in as a parameter (for example, <code>num = 7</code>), is greater than 0.</li>
<li>If <code>num</code> is greater than 0, it will multiply <code>num</code> by the counter.</li>
<li>Then, it will decrease the counter by 1.</li>
<li>Finally, it repeats steps 1-4 again until <code>num = 0</code>, in which case it will and finally break out of the <code>while</code> loop.</li>
</ol>


<p>Okay. <strong>WHUT?!</strong> This seems like a lot of stuff to keep track of. And that <code>factorial_count</code> variable is pretty weird and counter-intuitive (pun <em>totally</em> intended). And if we were calculating the factorials for a larger numbr &ndash; say 70, instead of 7 &ndash; this would be a lot of logic to keep track of and repeat over and over.</p>

<p>Let&rsquo;s rethink this problem for a second. What we actually want to do is find the factorials of all the numbers smaller than 7 and greater than 1, and then just multiply them together. In fact, all we really want to do is repeat the same procedure of multiplication.</p>

<p>Instead of using a loop, we could write a method that takes in a single argument <code>num</code>, and actually use that same method to replicate the process of multiplication. That might look something like this:</p>

<pre><code class="ruby">def factorial(num)
  if (0..1).include?(num)
    return 1
  end
  num * factorial(num - 1)
end
</code></pre>

<p>There&rsquo;s something pretty interesting happening here. If we pass in the number 7 as our parameter for <code>num</code>, our compiler does the following:</p>

<ol>
<li>First, it immediately jumps past the <code>if</code> statement.</li>
<li>Next, it multiplies 7 by <code>factorial(6)</code></li>
<li>Then, inside of the <code>factorial(6)</code> method, it circumvents the <code>if</code> statement again, and multiplies 6 by <code>factorial(5)</code>.</li>
<li>Eventually, when it hits the <code>if</code> statement, it returns 1.</li>
</ol>


<p>Here&rsquo;s a visualization of what this looks like:</p>

<pre><code class="ruby">factorial(7) = 7 * factorial(6)
             = 7 * 6 * factorial(5)
             = 7 * 6 * 5 * factorial(4)
             = 7 * 6 * 5 * 4 * factorial(3)
             = 7 * 6 * 5 * 4 * 3 * factorial(2)
             = 7 * 6 * 5 * 4 * 3 * 2 * factorial(1)
             = 7 * 6 * 5 * 4 * 3 * 2 * 1
             = 5040
</code></pre>

<p>Does the Russian doll metaphor make a bit more sense now? Here are our seven dolls, each one nested within another. And our base case is 1, which is where our nesting and recursive function actually ends, helping us avoid a stack overflow error.</p>

<p>I think that the best part of this code, though, is that it&rsquo;s a <em>lot</em> easier to read. There&rsquo;s no counter, no loop, no incrementation. Just one clean and crisp method that you can use as many times as needed after defining it only once. And, if you think about it, the visual representation of the compiler&rsquo;s actions mimics exactly how a real human would write out and solve a factorial problem.</p>

<p>One of the most difficult aspects of programming is picking the right tool for a job. Sometimes, that tool might be recursion and make your job easier. Other times, it might be the completely wrong choice and infinitely complicate your life. But, the more that you code and get comfortable with recursion, the better you&rsquo;ll be at recognizing when to bust out the recursive wrench out of your toolbelt.</p>

<h2>tl;dr?</h2>

<ul>
<li><em>Recursion</em> is the process of calling a method or function from within itself.</li>
<li>Functional recursion <strong>must</strong> have a <em>base case</em> in order to avoid stack overflow errors.</li>
<li>Still curious? Check out <a href="http://vimeo.com/24716767">this video</a>, which introduces Ruby recursion in great depth.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[So You Wanna Ship Some Software, Eh?]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2014/11/30/so-you-wanna-ship-some-software-eh/"/>
    <updated>2014-11-30T18:05:55-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2014/11/30/so-you-wanna-ship-some-software-eh</id>
    <content type="html"><![CDATA[<p>Disheveled hair. Bags under your eyes. Hermit-like tendencies. Suffice it to say, project mode can do a <em>lot</em> of things to a person. It&rsquo;s the first time you&rsquo;re on your own, and the feeling of &ldquo;sink or swim&rdquo; will, inevitably, hit you in the face at some point or another.</p>

<p>But, project mode also teaches you a lot about what it means to focus and ship software. And it doesn&rsquo;t really matter that you&rsquo;ve only been coding for 9 weeks and that your application has only four models and that you&rsquo;re missing a ton of <code>&lt;div&gt;</code> tags. Why? Because the mistakes you make in your first application are ones that you&rsquo;ll never make again. So, inspired by <a href="http://blakedeboer.ghost.io/recent-lessons-learned/">Blake&rsquo;s post on lessons learned</a> from building a web application, here are a few things I learned in the process of shipping my first piece of software:</p>

<!-- more -->


<h2>1. Build something you actually care about</h2>

<p>This seems obvious, but it&rsquo;s worth repeating: don&rsquo;t choose a project or problem that you think other people would find interesting &ndash; choose something that <em>you</em> genuinely find interesting. If you aren&rsquo;t invested in the question that you&rsquo;re trying to answer, it&rsquo;s going to be evident in the product and demo. On the other hand, if you really care about what you&rsquo;re building, your passion will not only come through in your product and presentation, but will filter down and get other people excited about what you&rsquo;re building. It&rsquo;s also important to remember that <em>you</em>, more than anyone else, are going to have to look at your data and code; you might as well pick something you won&rsquo;t mind looking at for hours at a time, days on end.</p>

<h2>2. Ignore the OCD impulses, leave styling for later</h2>

<p>Possibly the biggest mistake we made while building our app was trying to make it look better before it was really done. We tried to implement some styling not only before we had picked a theme, but worse: before we actually knew what information we&rsquo;d ultimately end up displaying to our users. All in all, we probably wasted 6-10 hours collectively, all in a futile attempt to make a broken application look prettier. When the time finally came to actually style our application, a lot of time went in trying to reformulate our CSS to make it work with the theme that we chose. So, no matter how much it gnaws at you, leave the styling, design, and UX stuff until your application is fully-functional and, most importantly, <em>finished</em>.</p>

<h2>3. Set small goals &amp; short time limits</h2>

<p>One of the things that our group did quite well was building out one feature at a time and adding functionality to our application bit by bit. We did a good job of writing out and prioritizing the different kinds of functionality and types of features we could tackle in a given day. But it was much tougher to learn how much time to spend on actually building a feature out. A few days into project mode, we started setting time limits for ourselves, both individually and as a team. One person could only spend so much time working on a problem before opening it up to the group, and as a group, we could only debug a problem for so long before outsourcing to a TA or classmate. This minimized the number of hours we spent staring our screens without knowing which direction to go in next. With small, progressive goals to work towards and short spurts of time to complete them in, we were as a whole, far more productive.</p>

<h2>4. Do what you don&rsquo;t know</h2>

<p>I have this fear of routes. Correction: I <em>had</em> a fear of routes. How did I stop being scared of routing and that silly little <code>routes.rb</code> file? I forced myself to map out the routes with my group and take the lead in actually programming them out in our application.</p>

<p>While I coded, my project partner Joe (who&rsquo;s a super skilled router) helped me debug our routes, and made sure to explain why we were routing certain things in a specific way. And when we got to the CSS and styling, he took over the wheel while I helped him navigate the grid column framework in Bootstrap. This ended up being a super symbiotic relationship, because we both worked on the exact topics we knew that we were weak in, and both became better programmers in the process.</p>

<h2>5. Version control: &lsquo;Nuff said.</h2>

<p>If you&rsquo;re rusty on merging branches, making a commit, or merging conflicts, use project mode as an opportunity to conquer your git fears and learn as much as you can. Version control is awesome. It will probably (read: definitely) save you at some point in your project.</p>

<h2>tl;dr?</h2>

<ul>
<li>Build first, design later.</li>
<li>Write code that you care about.</li>
<li>Practice what you don&rsquo;t already know.</li>
<li>For the love of God, commit yo shit!</li>
</ul>


<p><img src="http://www.explainxkcd.com/wiki/images/d/de/git_commit.png" alt="git commit comic" style="display: block; margin-left: auto; margin-right: auto;"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Programming Makes You a Better Writer]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2014/11/19/how-programming-makes-you-a-better-writer/"/>
    <updated>2014-11-19T08:08:47-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2014/11/19/how-programming-makes-you-a-better-writer</id>
    <content type="html"><![CDATA[<p>When I was in my terrible twos, my mom walked in on me writing all over the white walls of our living room with a pencil. I didn&rsquo;t even know how to write, much less <em>what</em> to write. But apparently, even as a toddler, I knew that writing was exactly what I wanted to do. (Side note: when my dad got home, he made me erase everything I&rsquo;d written. But I digress.)</p>

<p>Suffice it to say that writing has always been the medium of choice when it comes to expressing myself. So when I set aside my literary pen eight weeks ago to learn how to code at <a href="http://www.flatironschool.com/">The Flatiron School</a>, I did it with a heavy heart. I knew I&rsquo;d be learning how to build amazing things with the powerful tools that programming gives you, but I also assumed that I&rsquo;d be abandoning my one true passion.</p>

<p>But I&rsquo;ve learned two important things since then: first, you probably shouldn&rsquo;t assume things randomly. Second, and more seriously, writing and coding are far more similar than they are different. And I&rsquo;ve realized that coding has not only made me a better writer &ndash; it has also made me a better person.</p>

<!-- more -->


<p>Writing is unanimously thought of as a communicative art form, something that is unrestricted and free-flowing, which can overcome you at any given moment; and when you&rsquo;re in that moment, you have to surrender yourself to that creative genius within. Programming&rsquo;s reputation, on the other hand, is far more rigid, dependent on logic, discipline, and structure. But as someone who is now trying to inhabit both of these worlds, I can tell you that writing also depends on order and coherence just as much as programming relies on creative flow, clarity, and communication. Ultimately, writing is just as much a puzzle as programming is a narrative.</p>

<h2>Intuition</h2>

<p>Words and code both depend on intuition. As you write, you have to be honest with yourself about why you make certain creative choices: does your favorite character really add anything significant to your narrative? Is your narrator&rsquo;s voice believable? Does the reader even want to keep reading after your opening paragraph?</p>

<p>The questions that programmers ask themselves aren&rsquo;t too different. Does this method do more than one thing? Can I encapsulate and abstract this function somewhere in my code to avoid repeating myself? Does this functionality even belong in my application&rsquo;s controller? And perhaps the most important question of all: can anyone else <em>understand</em> my code?</p>

<p>Writers and programmers don&rsquo;t just have to become comfortable with their art forms: they have to truly understand every aspect of them. Programmers internalize their code and what it does in the same way that writers embody their self-created literary worlds. While at first you may not be able to put your finger on what&rsquo;s missing from a piece of writing, the more you write, the better you get at articulating what makes a piece of writing work. Similarly, as a programmer, you don&rsquo;t initially make the most educated guesses as to where a bug in your code might be, or what kinds of methods belong in a certain class. But the more you code, the better your intuition becomes, and the better you get programming.</p>

<h2>Discipline</h2>

<p>One of the best parts of programming is that you can easily get instant feedback. Write your code, and you can immediately run it and see what works and what breaks. But more often than not, your code is broken and you are constantly working to fix it. This takes a tremendous amount of discipline.</p>

<p>Computer programming forces you to constantly evaluate (and then reevaluate) your creative choices. You have to work through problems methodically, and work towards creating a framework and structure that furthers the functionality of your application. But the thing is, the programming concept of &ldquo;Make it work, make it right, make it fast,&rdquo; attributed to <a href="http://c2.com/cgi/wiki?MakeItWorkMakeItRightMakeItFast">Kent Beck</a>, applies just as much to code in a text editor as it does to words on a page.</p>

<p>If you want to be a good writer, you have to be able to structure your stories and revisit your writing in various drafts. Strong writing is never created in the first draft; it requires a shit ton of work. Every single writer will tell you that the one of the hardest parts of their job is rewriting, editing, and then rewriting again. And just as programmers refactor their code, writers &ldquo;refactor&rdquo; their narratives, striving to eliminate superfluous words and unnecessary paragraphs. And the most prolific programmers and prophetic writers get to where they are because they are incredibly disciplined when it comes to their craft.</p>

<h2>Empathy</h2>

<p>Writers create for their readers. Programmers create for their users. Neither of them allows for complete solitude, and both of them force you to put yourself in someone else&rsquo;s shoes. Writers have to empathize with their characters in order to make them believable and reliable for their readers. Programmers have to not only think about how their users experience an application, but also the readability of their code when it comes to other developers joining a project. In both cases, there&rsquo;s very little room to be selfish.</p>

<p>You also learn to be kinder to yourself in the process. Writing and programming are equally hard, sometimes in the exact same way. In fact, all artistic endeavors are physically, mentally, and emotionally exhausting. But then again, isn&rsquo;t that supposed to be the case? You&rsquo;re creating something out of nothing &ndash; adding something to the universe that didn&rsquo;t already exist before <em>you</em> created it.</p>

<p>Code is a living, breathing piece of art. When you build and ship an application, it&rsquo;s (hopefully) consumed by users around the world, all the time. You&rsquo;re never really done creating your art. Words are not that different. You put yourself into your writing and release it out into the world, just as you&rsquo;d deploy an application, for all the world to see.</p>

<p>The idea of <a href="http://www.paulgraham.com/hp.html">hackers as artists</a> isn&rsquo;t a new one. The real question is, what about them is similar &ndash; and what can we learn about the creative process to become the best writers and programmers that we can be?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Asset WHUTline?: Revisiting the Asset Pipeline After JavaScript]]></title>
    <link href="http://vaidehijoshi.github.io/blog/2014/11/16/the-asset-whutline-revisiting-the-asset-pipeline-after-javascript/"/>
    <updated>2014-11-16T23:14:13-05:00</updated>
    <id>http://vaidehijoshi.github.io/blog/2014/11/16/the-asset-whutline-revisiting-the-asset-pipeline-after-javascript</id>
    <content type="html"><![CDATA[<p>Two weeks ago, I was introduced to the Asset Pipeline. I didn&rsquo;t really think much of it at first, and part of me even assumed that I&rsquo;d never really have to see it again. It was a little like going out on a pretty forgettable first date &ndash; nothing particularly intriguing about the whole thing, but it somehow leaves you feeling kind of confused and generally rather perplexed.</p>

<p>But here&rsquo;s the thing: I <em>did</em> see the Asset Pipeline again. And boy was it awkward. After learning JavaScript this week and brushing up on my Rails, I realized that I&rsquo;m going to run into the Asset Pipeline at some point or another, so I might as well get to know it a little better. Here&rsquo;s a little refresher just in case you haven&rsquo;t seen the Asset Pipeline in awhile, either.</p>

<!-- more -->


<h2>Why bother?</h2>

<p>Once upon a time, before Rails 3.0, anytime you wanted to include a JavaScript or CSS file in your application, you had to manually do it by including either a <code>&lt;script&gt;</code> or a <code>&lt;link&gt;</code> tag, like so:</p>

<p><code>&lt;script src="jquery.js" type="text/javascript"&gt;&lt;/script&gt;</code><br>
<code>&lt;link href="custom.css" rel="stylesheet" type="text/css"/&gt;</code></p>

<p>Imagine doing that for every single file in your application. Are you in pain yet? Yeah, me too.</p>

<p>Now imagine being able to create as many JavaScript and CSS files as your heart desired, <em>and</em> being able to include all of them together in one single, long concatenated file that would be delivered whenver the browser makes a page request.</p>

<p>Guess what? That&rsquo;s exactly what the Asset Pipeline does. Ultimately, the goal of the Asset Pipeline is to make your life as a programmer that much easier by helping you organize your JavaScript and CSS files (which, let&rsquo;s face it, you are going to <em>have</em> to use):</p>

<blockquote><p>&ldquo;I think empty folder and empty files are two of the pivotal innovations in Rails that has encouraged us to write clean applications since the framework appeared. And I think this is true because when you have a place for everything and everything is in it&rsquo;s place, things feel nice.&rdquo;</p></blockquote>

<p>&ndash; David Heinemeier Hansson, <a href="https://www.youtube.com/watch?v=cGdCI2HhfAU"><em>RailsConf 2011</em></a></p>

<h2>Explain me some pipeline</h2>

<p>The Asset Pipeline works directly with your JavaScript and CSS files (also known as assets), and functions within three main directories:</p>

<ol>
<li>The <code>app/assets</code> directory: for files that are owned by the application &amp; specific to the current project (such as custom images, JavaScript files or stylesheets).</li>
<li>The <code>lib/assets</code> directory: for assets for your own libraries&#8217; code.</li>
<li>The <code>vendor/assets</code> directory: for external libraries that are owned by someone else (for example, JavaScript plugins or CSS frameworks).</li>
</ol>


<p>Within your <code>assets</code> directory are two subdirectories: <code>app/assets/javascripts/</code> and <code>app/assets/stylesheets/</code>. The Asset Pipeline compiles any JavaScript and CSS files that you add to these folders and automatically adds them to every page of your application.</p>

<p>Within these folders are <em>manifests</em>, which, in the case of your CSS files, would be included as part of the default application layout in the <code>app/assets/stylesheets/application.css.scss</code> directory. A manifest sets directives to provide the exact order and list of files that should be concatenated and included in the single CSS file that is delivered to the browser.</p>

<h2>So&hellip;what exactly is a directive, again?</h2>

<p>Directives are nothing more than directions of which files to grab and glob together. In the comments at the top of any manifest, you can find something that looks like <code>*= require_tree</code>, which is a directory that includes the current directory plus its subdirectories.</p>

<p>The most basic directive is <code>require</code>, which will concatenate the content of the specified file only once into the final packaged asset (called the &ldquo;bundle&rdquo;).</p>

<p>Another common directive is <code>include</code>, which is similar to <code>require</code>, except that if it reads the same file more than once, it will insert it into the bundle again.</p>

<p>Other directives like <code>require_self</code> and <code>require_directory</code> are useful in grabbing the current file (such as the manifest file), a specified directory.</p>

<p>Directives are always are processed in the order that they are read in the file, with <code>require_tree</code> being the one exception to this rule.</p>

<h2>Help me help you (or just use a helper method)</h2>

<p>The Asset Pipeline has helper methods to make your life a little easier. Two of the most common helper methods are the <code>stylesheet_link_tag</code> and <code>javascript_include_tag</code>, which can be used to add CSS &amp; JavaScript to any page of your application.</p>

<p>Another useful method is <code>link_to</code>, which can replace the anchor <code>&lt;a&gt;</code> tags while linking to other parts of your application. This method takes two parameters: the string displayed as the anchor text for the link, and the route:</p>

<p>&#8220;`ruby</p>

<ul class="nav">
  <li><%= link_to 'Super Cute Kittens', kittens_path %></li>
  <%= render 'layouts/navigation_links' %>
</ul>


<p>&#8220;`</p>

<p>This helper method is pretty awesome because it allows you name a route and then target all of your link locations to your <code>routes.rb</code> file. This is particuarly great you&rsquo;re moving your website from say, <code>www.cats.com</code> to a new and improved dynamic website that follows RESTful conventions, like maybe <code>www.supercutekittens.com</code>. Imagine having to create absolute URLs for every single link on that website! Ok, don&rsquo;t panic, you don&rsquo;t have to.</p>

<h2>Protip:</h2>

<p>When you generate a scaffold or a controller(<code>rails g scaffold</code> or <code>rails g controller</code>), Rails also generates a JavaScript/CoffeeScript file and a CSS/SCSS file for that controller! This means that when I make my CatsController, Rails will also add a new file at <code>app/assets/javascripts/cats.js.coffee</code> and another at <code>app/assets/stylesheets/cats.css.scss</code>.</p>

<h2>tl;dr?</h2>

<ul>
<li>Keeping your assets in their proper place will make you a happier and more organized programmer.</li>
<li>The Asset Pipeline will make your application perform better. Remember that it&rsquo;s easier (and faster) for your browser to request one large file from the server, rather than a ton of small ones.</li>
<li>Other things to look into: <a href="http://guides.rubyonrails.org/asset_pipeline.html#what-is-fingerprinting-and-why-should-i-care-questionmark">Fingerprinting</a>, which makes the name of a file dependent purely on its content. When the file contents change, the filename also changes.</li>
<li>The Asset Pipeline is magical, yet <em>super</em> difficult to learn. You probably won&rsquo;t understand everything all at once. But hopefully you feel a less confused than this little guy. He&rsquo;s clearly had too much pipeline for one day:</li>
</ul>


<blockquote class="twitter-tweet tw-align-center" lang="en"><p>So, I met the asset pipeline today&#8230; <a href="http://t.co/gU43HTzmF6">pic.twitter.com/gU43HTzmF6</a></p>&mdash; Vaidehi Joshi (@VaidehiJoshi) <a href="https://twitter.com/VaidehiJoshi/status/529693995661021184">November 4, 2014</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>



]]></content>
  </entry>
  
</feed>
